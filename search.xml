<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JVM、JRE和JDK</title>
    <url>/2021/04/11/JVM%E3%80%81JRE%E5%92%8CJDK/</url>
    <content><![CDATA[<p>计算机高级语言的类型主要有编译型和解释型两种，而Java 语言是两种类型的结合。<br>Java首先利用文本编辑器编写 Java源程序，源文件的后缀名为.java；再利用编译器（javac）将源程序编译成字节码文件，字节码文件的后缀名为.class； 最后利用虚拟机（解释器，java）解释执行。</p>
<span id="more"></span>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494836063440655.png" class="lazyload" data-srcset="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494836063440655.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Alt Java"></p>
<p>JVM(Java Virtual Machine)就是一个虚拟的用于执行bytecode字节码的”虚拟计算机”。他也定义了指令集、寄存器集、结构栈、垃圾收集堆、内存区域。JVM负责将Java字节码解释运行，边解释边运行，这样，速度就会受到一定的影响。</p>
<p>不同的操作系统有不同的虚拟机。Java 虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，随处运行”。 Java虚拟机是实现跨平台的核心机制。如图所示：<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494837984812122.png" class="lazyload" data-srcset="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494837984812122.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Alt JVM"></p>
<p>Java Runtime Environment (JRE) 包含：Java虚拟机、库函数、运行Java应用程序所必须的文件。</p>
<p>Java  Development Kit (JDK)包含：包含JRE，以及增加编译器和调试器等用于程序开发的文件。</p>
<p>JDK、JRE和JVM的关系如图所示。<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494837979897855.png" class="lazyload" data-srcset="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494837979897855.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Alt 关系图"></p>
<p>  ·如果只是要运行Java程序，只需要JRE就可以。JRE通常非常小，其中包含了JVM。</p>
<p>  ·如果要开发Java程序，就需要安装JDK。</p>
<p><strong>Java环境搭建</strong></p>
<p>下载JDK<br>    下载地址：<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">www.oracle.com/technetwork/java/javase/downloads/index.html</a></p>
<p>点击下载JDK，会出现下载列表界面。首先，点击”Accept License Agreement”，然后选择对应的版本，下载即可。</p>
<p>注意：<br>    32位操作系统只能安装32位JDK；<br>    64位操作系统可安装32位JDK，也可以安装64位JDK。</p>
<p>安装JDK</p>
<p>安装过程和普通软件安装没什么区别，过程中会让你选择JDK和JRE安装目录，采用默认即可。也就是说，通通点击“下一步”就能完成安装。<br>安装成功后我们再进入JDK的安装目录，可以看到如下的结构：<br>其中：</p>
<pre><code>bin目录是存储一些可执行的二进制文件；

lib存储相关jar包；

src.zip是JDK相关JAVA类的源代码。</code></pre><p><strong>环境变量Path的配置</strong><br>&emsp;&emsp;环境变量是在操作系统中一个具有特定名字的对象， 它包含了一个或者多个应用程序所将使用到的信息。</p>
<p>&emsp;&emsp;Path是一个常见的环境变量，它告诉操作系统，当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下寻找此程序外，还应到哪些目录下寻找。</p>
<p>设置Parh环境变量：</p>
<ol>
<li><p>右键计算机——&gt;属性——&gt;高级系统设置<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494838772220505.png" class="lazyload" data-srcset="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494838772220505.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Alt 1"></p>
</li>
<li><p>单击环境变量按钮<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494838780549127.png" class="lazyload" data-srcset="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494838780549127.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Alt 2"></p>
</li>
<li><p>单击新建按钮，新建JAVA_HOME变量（用于说明JDK的安装目录）<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494838787522279.png" class="lazyload" data-srcset="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494838787522279.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Alt 3"></p>
</li>
<li><p>修改系统环境变量Path，在最前面追加%JAVA_HOME%\bin  并以;和原路径分隔。再增加：“.;”。这是表示当前目录的意思<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494838936169679.png" class="lazyload" data-srcset="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494838936169679.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Alt 4"></p>
</li>
</ol>
<p>注意：</p>
<pre><code>此处一定是英文分号而不是中文分号！！！

classpath配置问题：如果使用JDK1.5以上就不需要配置这个环境变量！JRE会自动搜索当前路径下的类文件及相关jar文件</code></pre><hr>
<p>2021-04-11注：目前从Oracle下载的jdk安装程序，安装完成以后无需配置环境变量，安装过程中会自动配置完成</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>flybird</title>
    <url>/2019/11/11/flybird/</url>
    <content><![CDATA[<h2 id="一个简单的C-小游戏"><a href="#一个简单的C-小游戏" class="headerlink" title="一个简单的C++小游戏"></a>一个简单的C++小游戏</h2><span id="more"></span>

<hr>
<h3 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Lines = <span class="number">35</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Columns = <span class="number">120</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LeftLineColumn = <span class="number">20</span>;</span><br><span class="line">HANDLE hOut;</span><br><span class="line">DWORD dword;</span><br><span class="line"><span class="keyword">char</span> tmp[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> cur_time, start_time, last_time;</span><br><span class="line"><span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawBird</span><span class="params">(<span class="keyword">double</span> xx, <span class="keyword">double</span> yy)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = (<span class="keyword">int</span>)(xx + <span class="number">0.5</span>);</span><br><span class="line">  <span class="keyword">int</span> y = (<span class="keyword">int</span>)(yy + <span class="number">0.5</span>);</span><br><span class="line">  <span class="keyword">static</span> DWORD dword;</span><br><span class="line">  <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;v&quot;</span>, <span class="number">1</span>, (COORD)&#123;x, y - <span class="number">1</span>&#125;, &amp;dword);</span><br><span class="line">  <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;&gt;&gt;&gt;&quot;</span>, <span class="number">3</span>, (COORD)&#123;x - <span class="number">1</span>, y&#125;, &amp;dword);</span><br><span class="line">  <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;^&quot;</span>, <span class="number">1</span>, (COORD)&#123;x, y + <span class="number">1</span>&#125;, &amp;dword);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearBird</span><span class="params">(<span class="keyword">double</span> xx, <span class="keyword">double</span> yy)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = (<span class="keyword">int</span>)(xx + <span class="number">0.5</span>);</span><br><span class="line">  <span class="keyword">int</span> y = (<span class="keyword">int</span>)(yy + <span class="number">0.5</span>);</span><br><span class="line">  <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot; &quot;</span>, <span class="number">1</span>, (COORD)&#123;x, y - <span class="number">1</span>&#125;, &amp;dword);</span><br><span class="line">  <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;   &quot;</span>, <span class="number">3</span>, (COORD)&#123;x - <span class="number">1</span>, y&#125;, &amp;dword);</span><br><span class="line">  <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot; &quot;</span>, <span class="number">1</span>, (COORD)&#123;x, y + <span class="number">1</span>&#125;, &amp;dword);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Write at Middle/Left */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">WriteMiddle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> l = <span class="built_in">strlen</span>(str);</span><br><span class="line">  <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, str, l, (COORD)&#123;(Columns - l) / <span class="number">2</span>, y&#125;, &amp;dword);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">WriteLeft</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> l = <span class="built_in">strlen</span>(str);</span><br><span class="line">  <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, str, l, (COORD)&#123;<span class="number">1</span>, y&#125;, &amp;dword);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitLeftSide</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lines; ++i)</span><br><span class="line">    <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;|&quot;</span>, <span class="number">2</span>, (COORD)&#123;LeftLineColumn, i&#125;, &amp;dword);</span><br><span class="line">  <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">  ++p; <span class="built_in">WriteLeft</span>(<span class="string">&quot;Help:&quot;</span>, p);</span><br><span class="line">  ++p; <span class="built_in">WriteLeft</span>(<span class="string">&quot; Press &lt;Space&gt; to&quot;</span>, p);</span><br><span class="line">  ++p; <span class="built_in">WriteLeft</span>(<span class="string">&quot;make the bird fly.&quot;</span>, p);</span><br><span class="line">  ++p; <span class="built_in">WriteLeft</span>(<span class="string">&quot; Don&#x27;t fall to the&quot;</span>, p);</span><br><span class="line">  ++p; <span class="built_in">WriteLeft</span>(<span class="string">&quot;ground or hit pipes&quot;</span>, p);</span><br><span class="line">  ++p; <span class="comment">// Empty line</span></span><br><span class="line">  ++p; <span class="built_in">WriteLeft</span>(<span class="string">&quot;Time:&quot;</span>, p);</span><br><span class="line">  ++p; <span class="comment">// Time</span></span><br><span class="line">  ++p; <span class="built_in">WriteLeft</span>(<span class="string">&quot;Fps:&quot;</span>, p);</span><br><span class="line">  ++p; <span class="comment">// Fps</span></span><br><span class="line">  ++p; <span class="comment">// Empty line</span></span><br><span class="line">  ++p; <span class="built_in">WriteLeft</span>(<span class="string">&quot;Score:&quot;</span>, p);</span><br><span class="line">  ++p; <span class="comment">// Score</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawLeftSide</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">  ++p; <span class="comment">// WriteLeft(&quot;Help:&quot;, p);</span></span><br><span class="line">  ++p; <span class="comment">// WriteLeft(&quot; Press &lt;Space&gt; to&quot;, p);</span></span><br><span class="line">  ++p; <span class="comment">// WriteLeft(&quot;make the bird fly.&quot;, p);</span></span><br><span class="line">  ++p; <span class="comment">// WriteLeft(&quot; Don&#x27;t fall to the&quot;, p);</span></span><br><span class="line">  ++p; <span class="comment">// WriteLeft(&quot;ground or hit pipes&quot;, p);</span></span><br><span class="line">  ++p; <span class="comment">// Empty line</span></span><br><span class="line">  ++p; <span class="comment">// WriteLeft(&quot;Time:&quot;, p);</span></span><br><span class="line">  <span class="built_in">sprintf</span>(tmp, <span class="string">&quot; %5.2lfs&quot;</span>, (<span class="keyword">double</span>)(cur_time - start_time) / CLOCKS_PER_SEC);</span><br><span class="line">  ++p; <span class="built_in">WriteLeft</span>(tmp, p);</span><br><span class="line">  ++p; <span class="comment">// WriteLeft(&quot;Fps:&quot;, p);</span></span><br><span class="line">  <span class="built_in">sprintf</span>(tmp, <span class="string">&quot; %5.2lf&quot;</span>, CLOCKS_PER_SEC / (<span class="keyword">double</span>)(cur_time - last_time));</span><br><span class="line">  ++p; <span class="built_in">WriteLeft</span>(tmp, p);</span><br><span class="line">  ++p; <span class="comment">// Empty line</span></span><br><span class="line">  ++p; <span class="comment">// WriteLeft(&quot;Score:&quot;, p);</span></span><br><span class="line">  <span class="built_in">sprintf</span>(tmp, <span class="string">&quot; %3d&quot;</span>, score);</span><br><span class="line">  ++p; <span class="built_in">WriteLeft</span>(tmp, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pipe</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> H, D; <span class="comment">// A Pipe, [x, x + 1] * ([0, H] and [D, Lines))</span></span><br><span class="line">  <span class="keyword">double</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">RandRange</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">rand</span>() % (r - l + <span class="number">1</span>) + l; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Pipe <span class="title">RandomPipe</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> br = <span class="built_in">RandRange</span>(<span class="number">8</span>, <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">int</span> h = <span class="built_in">RandRange</span>(<span class="number">3</span>, Lines - br - <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> (Pipe)&#123;h, h + br, (<span class="keyword">double</span>)x&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">CheckPipe</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">double</span> y, <span class="keyword">const</span> Pipe &amp;p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> px = (<span class="keyword">int</span>)(p.x + <span class="number">0.5</span>);</span><br><span class="line">  <span class="keyword">int</span> dx = std::<span class="built_in">min</span>(std::<span class="built_in">abs</span>(x - px), std::<span class="built_in">abs</span>(x - px - <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">if</span> (dx &gt; <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (dx == <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> y &gt; p.H - <span class="number">0.5</span> &amp;&amp; y &lt; p.D + <span class="number">0.5</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (dx == <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> y &gt; p.H + <span class="number">0.5</span> &amp;&amp; y &lt; p.D - <span class="number">0.5</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> y &gt; p.H + <span class="number">1.5</span> &amp;&amp; y &lt; p.D - <span class="number">1.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearPipe</span><span class="params">(<span class="keyword">const</span> Pipe &amp;p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> px = (<span class="keyword">int</span>)(p.x + <span class="number">0.5</span>);</span><br><span class="line">  <span class="keyword">if</span> (px != LeftLineColumn &amp;&amp; px + <span class="number">1</span> &lt; Columns) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.H; ++i)</span><br><span class="line">      <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;  &quot;</span>, <span class="number">2</span>, (COORD)&#123;px, i&#125;, &amp;dword);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p.D + <span class="number">1</span>; i &lt; Lines; ++i)</span><br><span class="line">      <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;  &quot;</span>, <span class="number">2</span>, (COORD)&#123;px, i&#125;, &amp;dword);</span><br><span class="line">    <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;  &quot;</span>, <span class="number">2</span>, (COORD)&#123;px + <span class="number">1</span>, p.H&#125;, &amp;dword);</span><br><span class="line">    <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;  &quot;</span>, <span class="number">2</span>, (COORD)&#123;px + <span class="number">1</span>, p.D&#125;, &amp;dword);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> x = px == LeftLineColumn ? px + <span class="number">1</span> : px;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.H; ++i)</span><br><span class="line">      <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot; &quot;</span>, <span class="number">1</span>, (COORD)&#123;x, i&#125;, &amp;dword);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p.D + <span class="number">1</span>; i &lt; Lines; ++i)</span><br><span class="line">      <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot; &quot;</span>, <span class="number">1</span>, (COORD)&#123;x, i&#125;, &amp;dword);</span><br><span class="line">    <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot; &quot;</span>, <span class="number">1</span>, (COORD)&#123;x, p.H&#125;, &amp;dword);</span><br><span class="line">    <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot; &quot;</span>, <span class="number">1</span>, (COORD)&#123;x, p.D&#125;, &amp;dword);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawPipe</span><span class="params">(<span class="keyword">const</span> Pipe &amp;p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> px = (<span class="keyword">int</span>)(p.x + <span class="number">0.5</span>);</span><br><span class="line">  <span class="keyword">if</span> (px &lt; LeftLineColumn) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (px != LeftLineColumn &amp;&amp; px + <span class="number">1</span> &lt; Columns) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.H; ++i)</span><br><span class="line">      <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;||&quot;</span>, <span class="number">2</span>, (COORD)&#123;px, i&#125;, &amp;dword);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p.D + <span class="number">1</span>; i &lt; Lines; ++i)</span><br><span class="line">      <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;||&quot;</span>, <span class="number">2</span>, (COORD)&#123;px, i&#125;, &amp;dword);</span><br><span class="line">    <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;--&quot;</span>, <span class="number">2</span>, (COORD)&#123;px, p.H&#125;, &amp;dword);</span><br><span class="line">    <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;--&quot;</span>, <span class="number">2</span>, (COORD)&#123;px, p.D&#125;, &amp;dword);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> x = px == LeftLineColumn ? px + <span class="number">1</span> : px;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.H; ++i)</span><br><span class="line">      <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;|&quot;</span>, <span class="number">1</span>, (COORD)&#123;x, i&#125;, &amp;dword);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p.D + <span class="number">1</span>; i &lt; Lines; ++i)</span><br><span class="line">      <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;|&quot;</span>, <span class="number">1</span>, (COORD)&#123;x, i&#125;, &amp;dword);</span><br><span class="line">    <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;-&quot;</span>, <span class="number">1</span>, (COORD)&#123;x, p.H&#125;, &amp;dword);</span><br><span class="line">    <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;-&quot;</span>, <span class="number">1</span>, (COORD)&#123;x, p.D&#125;, &amp;dword);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">HideCursor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  CONSOLE_CURSOR_INFO cci;</span><br><span class="line">  <span class="built_in">GetConsoleCursorInfo</span>(hOut,&amp;cci);</span><br><span class="line">  cci.bVisible = FALSE;</span><br><span class="line">  <span class="built_in">SetConsoleCursorInfo</span>(hOut,&amp;cci);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">  <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;mode con lines=%d cols=%d&quot;</span>, Lines, Columns);</span><br><span class="line">  <span class="built_in">system</span>(tmp);</span><br><span class="line">  hOut = <span class="built_in">GetStdHandle</span>(STD_OUTPUT_HANDLE);</span><br><span class="line">  <span class="built_in">HideCursor</span>();</span><br><span class="line">  <span class="built_in">InitLeftSide</span>();</span><br><span class="line">  <span class="built_in">WriteMiddle</span>(<span class="string">&quot;Flappy bird (Simple)&quot;</span>, Lines / <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">WriteMiddle</span>(<span class="string">&quot;--By _wyt&quot;</span>, Lines / <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">WriteMiddle</span>(<span class="string">&quot;Press any key to start...&quot;</span>, Lines / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">  _getch();</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pipe pipes[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Init</span>();</span><br><span class="line">  <span class="built_in">InitLeftSide</span>();</span><br><span class="line">  last_time = start_time = <span class="built_in">clock</span>();</span><br><span class="line">  score = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> g = <span class="number">35</span>; <span class="comment">// Gravitational acceleration, grid / s^2</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> vx = <span class="number">12.0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> x = <span class="number">27.0</span>;</span><br><span class="line">  <span class="keyword">double</span> y = <span class="number">5.0</span>, vy = <span class="number">0.0</span>;</span><br><span class="line">  <span class="keyword">int</span> pipe_n = <span class="number">0</span>;</span><br><span class="line">  pipes[pipe_n++] = <span class="built_in">RandomPipe</span>(Columns - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">kbhit</span>()) &#123;</span><br><span class="line">      <span class="keyword">char</span> c = _getch();</span><br><span class="line">      <span class="keyword">if</span> (c == <span class="number">32</span>) vy = <span class="number">-15.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cur_time = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">double</span> time_break = (<span class="keyword">double</span>)(cur_time - last_time) / CLOCKS_PER_SEC;</span><br><span class="line">    <span class="built_in">ClearBird</span>(x, y);</span><br><span class="line">    y = std::<span class="built_in">min</span>(vy * time_break + y, <span class="number">33.0</span>);</span><br><span class="line">    vy += g * time_break;</span><br><span class="line">    <span class="keyword">if</span> (y &lt; <span class="number">1</span> - <span class="number">1e-6</span>) &#123; y = <span class="number">1</span>; vy = <span class="number">.0</span>; &#125;</span><br><span class="line">    <span class="built_in">DrawBird</span>(x, y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pipe_n; ++i) &#123;</span><br><span class="line">      <span class="keyword">double</span> px = pipes[i].x, px2 = pipes[i].x - vx * time_break;</span><br><span class="line">      <span class="keyword">if</span> ((<span class="keyword">int</span>)(px + <span class="number">0.5</span>) != (<span class="keyword">int</span>)(px2 + <span class="number">0.5</span>)) &#123;</span><br><span class="line">        <span class="built_in">ClearPipe</span>(pipes[i]);</span><br><span class="line">        pipes[i].x = px2;</span><br><span class="line">        <span class="built_in">DrawPipe</span>(pipes[i]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pipes[i].x = px2;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Columns - pipes[pipe_n - <span class="number">1</span>].x &gt; <span class="number">30</span>)</span><br><span class="line">      <span class="built_in">DrawPipe</span>(pipes[pipe_n++] = <span class="built_in">RandomPipe</span>(Columns - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> failed = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pipe_n; ++i) &#123;</span><br><span class="line">      failed = failed || !<span class="built_in">CheckPipe</span>((<span class="keyword">int</span>)(x + <span class="number">0.5</span>), y, pipes[i]);</span><br><span class="line">      <span class="keyword">if</span> ((<span class="keyword">int</span>)(pipes[i].x + <span class="number">0.5</span>) &gt;= LeftLineColumn)</span><br><span class="line">        pipes[j++] = pipes[i];</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        ++score;</span><br><span class="line">    &#125;</span><br><span class="line">    pipe_n = j;</span><br><span class="line">    <span class="built_in">DrawLeftSide</span>();</span><br><span class="line">    <span class="keyword">if</span> (y &gt;= <span class="number">33.0</span> - <span class="number">1e-6</span> || failed) &#123;</span><br><span class="line">      <span class="built_in">DrawBird</span>(x, y);</span><br><span class="line">      <span class="built_in">WriteMiddle</span>(<span class="string">&quot;-------------------------------&quot;</span>, Lines / <span class="number">2</span> - <span class="number">2</span>);</span><br><span class="line">      <span class="built_in">WriteMiddle</span>(<span class="string">&quot;|                             |&quot;</span>, Lines / <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">      <span class="built_in">WriteMiddle</span>(<span class="string">&quot;|                             |&quot;</span>, Lines / <span class="number">2</span>);</span><br><span class="line">      <span class="built_in">WriteMiddle</span>(<span class="string">&quot;|                             |&quot;</span>, Lines / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">      <span class="built_in">WriteMiddle</span>(<span class="string">&quot;|                             |&quot;</span>, Lines / <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line">      <span class="built_in">WriteMiddle</span>(<span class="string">&quot;-------------------------------&quot;</span>, Lines / <span class="number">2</span> + <span class="number">3</span>);</span><br><span class="line">      <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;Your score: %d!&quot;</span>, score);</span><br><span class="line">      <span class="built_in">WriteMiddle</span>(tmp, Lines / <span class="number">2</span>);</span><br><span class="line">      <span class="built_in">WriteMiddle</span>(<span class="string">&quot;Press any key to exit...&quot;</span>, Lines / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">      _getch();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    last_time = cur_time;</span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">40</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> _ **** 嘿嘿，慢慢玩 _</p>
]]></content>
      <categories>
        <category>趣味</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>c++&amp;vector</title>
    <url>/2019/12/03/c-vector/</url>
    <content><![CDATA[<p>在c++中，vector是一个十分有用的容器。</p>
<p>作用：它能够像容器一样存放各种类型的对象，简单地说，vector是一个能够存放任意类型的动态数组，能够增加和压缩数据。</p>
<p>vector在C++标准模板库中的部分内容，它是一个多功能的，能够操作多种数据结构和算法的模板类和函数库。</p>
<span id="more"></span>

<p><strong>特别注意：</strong></p>
<p>使用vector需要注意以下几点：</p>
<p>1.加入头文件<code>&lt;vector&gt;</code></p>
<p>2.如果你要表示的向量长度较长（需要为向量内部保存很多数），容易导致内存泄漏，而且效率会很低；</p>
<p>3.Vector作为函数的参数或者返回值时，需要注意它的写法：</p>
<p> ==double Distance(vector<int>&amp;a, vector<int>&amp;b) 其中的“&amp;”绝对不能少！！！==</p>
<h2 id="一维vector"><a href="#一维vector" class="headerlink" title=" 一维vector"></a><center> 一维vector</center></h2><p><strong>创建一维vector：</strong></p>
<pre><code>vector&lt;int&gt; nums;       //不指定长度
vector&lt;int&gt; nums(n);    //指定长度为n</code></pre><p><strong>添加元素</strong></p>
<pre><code>nums.push_back(1);      //直接从数组末端添加
nums[i]=1;              //直接赋值给第i个位置
nums.insert(nums.begin()+i,a);  //在第i+1个元素前插入a</code></pre><p><strong>删除元素</strong></p>
<pre><code>nums.resize(nums.size-i);    //直接将数组长度减少，某种意义上删掉了后面i个
nums.pop_back();             //删掉最后一个元素
nums.erase(nums.begin()+i);  //删掉第i+1个元素
nums.erase(nums.begin()+i,nums.end()+j);    //删除区间[i,j-1],区间从0开始
nums.clear();                //清空</code></pre><p><strong>其它</strong></p>
<p>获取长度：nums.size();</p>
<p>排序(O(nlogn))：sort(nums.begin(),nums.end());</p>
<p>翻转：reverse(nums.begin(),nums.end());</p>
<p>合并两个vector：合并nums1和nums2，并将合并的数组赋值给nums</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nums1</span><span class="params">(m)</span>,<span class="title">nums2</span><span class="params">(n)</span></span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">nums.<span class="built_in">resize</span>(m+n);</span><br><span class="line"><span class="built_in">merge</span>(nums1.<span class="built_in">begin</span>(),nums1.<span class="built_in">end</span>(),nums2.<span class="built_in">begin</span>(),nums2.<span class="built_in">end</span>(),nums);</span><br></pre></td></tr></table></figure>

<h2 id="二维vector"><a href="#二维vector" class="headerlink" title="二维vector"></a><center>二维vector</center></h2><p><strong>创建M*n二维vector</strong></p>
<pre><code>vector&lt; vector&lt;int&gt; &gt; nums(m,vector&lt;int&gt;(n));   //m*n的二维vector</code></pre><p>解释：</p>
<p>定义了一个vector容器，元素类型为vector<int>，初始化为包含m个vector<int>对象，每个对象都是一个新创立的vector<int>对象的拷贝，而这个新创立的vector<int>对象被初始化为包含n个0。</p>
<p>vector<int>(n)表示构造一个无名且含n个0的vector<int>对象。</p>
<p><strong>动态创建m*n的二维vector</strong></p>
<p>==方法一==</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector &lt;<span class="keyword">int</span>&gt; &gt; nums;<span class="number">3</span></span><br><span class="line"></span><br><span class="line">nums.<span class="built_in">resize</span>(m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) nums[i].<span class="built_in">resize</span>(n);</span><br></pre></td></tr></table></figure>

<p>==方法二==</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector &lt;<span class="keyword">int</span>&gt; &gt; nums;</span><br><span class="line">nums.<span class="built_in">resize</span>(m,vector&lt;<span class="keyword">int</span>&gt;(n));</span><br></pre></td></tr></table></figure>
<p><strong>初始化二维数组</strong></p>
<pre><code>vector&lt;vector &lt;int&gt; &gt; nums(m ,vector&lt;int&gt;(n,0));    //m*n的二维vector，所有元素为0</code></pre><p>获得二维数组的行数：nums.size(); </p>
<p>获得二维数组的列数：nums[0].size()；</p>
<p><strong>数组遍历</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m = nums.<span class="built_in">size</span>(),n = nums[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">        cout&lt;&lt;nums[i][j]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用vector还可以用结构体类型哟"><a href="#用vector还可以用结构体类型哟" class="headerlink" title="用vector还可以用结构体类型哟"></a><del>用vector还可以用结构体类型哟</del></h3>]]></content>
      <tags>
        <tag>c++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>love</title>
    <url>/2021/04/13/love/</url>
    <content><![CDATA[<p>My love for you exists in every bit of life,like this code</p>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(meetMe || !meetMe) &#123; <span class="comment">//你见，或者不见我</span></span><br><span class="line">   <span class="keyword">await</span> there(&#123;</span><br><span class="line">      <span class="attr">me</span>: &#123;        <span class="comment">//我就在那里</span></span><br><span class="line">         <span class="attr">sad</span>: <span class="literal">null</span>, <span class="comment">//不悲 不喜</span></span><br><span class="line">         <span class="attr">happy</span>: <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(meetMe || !meetMe) &#123;    <span class="comment">//你念，或者不念我</span></span><br><span class="line">   <span class="keyword">await</span> there(&#123;</span><br><span class="line">      <span class="attr">feeling</span>: &#123;    <span class="comment">//情就在那里</span></span><br><span class="line">         <span class="attr">left</span>: <span class="number">0</span>,   <span class="comment">//不来 不去</span></span><br><span class="line">         <span class="attr">right</span>: <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(loveMe || !loveMe) &#123;    <span class="comment">//你爱，或者不爱我</span></span><br><span class="line">   <span class="keyword">await</span> there(&#123;     <span class="comment">//爱就在那里</span></span><br><span class="line">      <span class="attr">love</span>: <span class="literal">Infinity</span> <span class="comment">//不增不减</span></span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(withMe || !withMe) &#123;    <span class="comment">//你跟，或者不跟我</span></span><br><span class="line">   <span class="keyword">const</span> tomorrow = &#123; <span class="comment">//我的手就在你手里</span></span><br><span class="line">      <span class="attr">we</span>: myHands &amp;&amp; yourHands</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">Object</span>.freeze(tomorrow)    <span class="comment">//不舍不弃</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!myArms.has(you)) &#123;    <span class="comment">//来我的怀里</span></span><br><span class="line">   OR             <span class="comment">//或者</span></span><br><span class="line">   yourHeart.push(me) <span class="comment">//让我住进你的心里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>爱</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>爱</tag>
      </tags>
  </entry>
  <entry>
    <title>三行情话</title>
    <url>/2021/04/10/%E4%B8%89%E8%A1%8C%E6%83%85%E8%AF%97/</url>
    <content><![CDATA[<p>螃蟹在剥我的壳，笔记本在写我</p>
<p>漫天的我落在枫叶上、雪花上</p>
<p>而你在想我      ————《武汉大学-三行情诗》</p>
<span id="more"></span>

<h4 id="有一种理解"><a href="#有一种理解" class="headerlink" title="有一种理解"></a>有一种理解</h4><p>也是最美好的一种解释，即全文主宾倒装</p>
<p>我在剥螃蟹的壳、写笔记本，枫叶、雪花落在我上，而我在…</p>
<h4 id="有一种理解-1"><a href="#有一种理解-1" class="headerlink" title="有一种理解"></a>有一种理解</h4><p>也是对情感的绝望，即全文否定</p>
<p>螃蟹不可能在剥我的壳，笔记本不可能在写我，我不可能落在枫叶上、雪花上，而你也不可能在想我</p>
<h4 id="有一种理解-2"><a href="#有一种理解-2" class="headerlink" title="有一种理解"></a>有一种理解</h4><p>也是一种自欺欺人</p>
<p>只有当在螃蟹在剥我的壳，笔记本写我，我落在枫叶上、雪花上的时候，你才会想我</p>
]]></content>
      <categories>
        <category>爱</category>
      </categories>
      <tags>
        <tag>生活,爱</tag>
      </tags>
  </entry>
  <entry>
    <title>世界上没那么多错过</title>
    <url>/2020/02/03/%E4%B8%96%E7%95%8C%E4%B8%8A%E6%B2%A1%E9%82%A3%E4%B9%88%E5%A4%9A%E9%94%99%E8%BF%87/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="f0883e4a2eb1aa1381b3ba18f0ff3a6c51e49fa31e82c87cb9cf7bd705157243">6de660ac7b4e1815a73b127ec3abb05f51924f2811536e1624e23d55841dcfc3b15b449442c5c9931bd4010101b285b6b9b8e00c5d4344e2d3d77d2995b1c79a830705f1c6dfaa178056ed6a45908020f375498dd1050e1269dde668b04939d41aa33660746b2dc957b8989f7d9cd9c069bebcba9ba98ed6c7b0d1bdbdd5b8e5f2642d08b81bccf7225d9cde4b89eadece8fc5458c9b628cc4f27097c519b0ab5976bf641ccecdbd380fe9793d772e4284e5259d13008906d713f0df100eb9ee439dc69758c863877cd3856afc46e7bbbec1bbf00c38b1dd252e973abee74deb9d0886049447f8980e3bb31d77639b1b92269a7a2441752826401112cb60ccbc370b9fd7620d0ab8db6a40cc6a45b3aeb0117086cae0cee2e2673a38b4780ec4cb935ea2d2bb25f54a1414b38905aa07315b5875aec77880c545c4f4317ce41873e8edcf5167a95589b72547ef266fb1770e7eec99bb5b092300bdb094d1020d6cc0542c81fc94813cfbc8736a41a4fd38bfdbac53947c30a3d22f1ec3f759b4418cc66c45dfb0fc155b100b3ace70b0adf8ce69b5ba70b7f8862c5e782cfa384fc31025e2fdd92a4296fc023420d1372372ae8f542c0d7355b308b7e2df755d0ebc23c08ac15d8b52ce64e547854dd6b136ef20204a037745647b5a102c2b6f4d7669ca79545ec8685c57fcdf805941610af5328c9e743c338c29f5f47f7be1acc7753e3b0b487e3d870d406575a4304010430744f4a6b4a393a73b74819447c18db3208ea308343d4f67125626618aac8c8e011ee9ca77a59fab83d3e8f01b4856deba7addceb238b2f87164e4bed64060ddabf148e089baa4a07f0447199e8362df71b101aa1863aa38958920175a4b80b772dc103d09eaaa0191e7a076941f111ed06b1cc107f542b1910b3f8818790f3b8ab14d78989a29c63ee434677b1280eb853a6ec1309ad34cedba19091b4bc36cd447b97c455f62a4d059b7a85d4d71935b76f36bcac3ae1015fea0c5571e39bdf51947d9b569da0841631594c6e22449c8d288977d2a5c75eea45e55396023e4d76dce3c26dce4698798637a0839e6fe3eaabf1dde8efa542c6c4aac682f7ca02f56d9d3d4477c6e78c908a8e61657d2d836c5f6b9a7901a8fb4636ebd3fb5ceae5522df6e05fb3bea5683353233de3d49e1f34333a872fd1a421603360730620a28a96e7b6ded2f34074f3ef455a9cd748483522d88962824c057350ed347984441cbae34fff44b537def5a0a175a6238dbca14270a6ef0a468efee1bc27f62f3af422502152535e0eaa2f226ce12e3bd94b934db39a2c858a2ceadcae250ba0ad129574a40d9f3ebf300d9af740b53ad028451d83a59f2a8536636a7</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">你猜</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>人生路不长，别再等以后(转载)</title>
    <url>/2019/11/12/%E4%BA%BA%E7%94%9F%E8%B7%AF%E4%B8%8D%E9%95%BF%EF%BC%8C%E5%88%AB%E5%86%8D%E7%AD%89%E4%BB%A5%E5%90%8E-%E8%BD%AC%E8%BD%BD/</url>
    <content><![CDATA[<center>一辈子很短，短得来不及细算</center> 

<span id="more"></span>

<center></center****> 

<p>童年，不知不觉没了<br>青春，不知不觉没了<br>而那些无忧无虑的快乐<br>好像也消失不见了<br>一辈子三万天而已<br>没有你想得那么长<br>有什么心愿，快点实现<br>有什么目标，快点奋战<br>别等来等去<br>等来了年龄增长<br>等来了热情褪去<br>人生不是花，败了再开<br>身体不是叶，落了再生<br>我们每个人<br>都只有一次人生，只有一个身体<br>生病不能等，健康没了，人就完了<br>人生不能等，时间过了，人就终了<br>一辈子不长，别再等以后<br>想吃的东西，去吃<br>想做的事情，趁早<br>想要的感情，去追<br>想去的地方，快去<br>别一等再等<br>等牙没有了，想吃就难了<br>等人离开了，想爱就晚了<br>一辈子很短，这一生短暂<br>时间不等人，岁月不等你<br>趁我们都还活着<br>对父母，孝顺点，对爱人，珍惜点<br>对朋友，真心点，对自己，好一点</p>
<p>```</p>
<h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>初级素数判断</title>
    <url>/2019/11/10/%E5%88%9D%E7%BA%A7%E7%B4%A0%E6%95%B0%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<p>这篇只是让大家初步了解如何判断素数，是最基础的内容，之后会讲一些欧拉，埃氏等素数筛的方法</p>
<span id="more"></span>

<h6 id="第一次的想法"><a href="#第一次的想法" class="headerlink" title="第一次的想法:"></a>第一次的想法:</h6><p>==让它爆搜一遍不就好了== <del>爆搜大法好爆搜大法好</del></p>
<blockquote>
<p>具体实现就是让数n从2开始模,一直模到n-1,如果都不能被整除,那就是素数<strong>紧扣定义</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否是素数1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;please inpout a number.&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; m; ++i)</span><br><span class="line">        <span class="keyword">if</span> (m%i == <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; m &lt;&lt; <span class="string">&quot; isn&#x27;t a prime\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; m &lt;&lt; <span class="string">&quot; is a prime\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这么复杂,那来进行下简单优化:<br>如果一个数有因子的话，那么在它的平方根数以内就应该有，否则就没有因子。例如66的平方根在8与9之间，因为66不是素数，，则它一定有比8还小的因子，我们知道66的因子是2、3、6等<br><strong>那我们就可以这样写了</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="built_in">sqrt</span>(m); ++i)&#123;</span><br><span class="line">    <span class="keyword">if</span> (m%i == <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; m &lt;&lt; <span class="string">&quot; isn&#x27;t a prime\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>本次初级素数判断就先到这里</strong><br><strong>有没有感觉到循环挺浪费时间的呢</strong><br><strong>那去想想有什么方法能够进一步降低时间复杂度</strong></p>
]]></content>
      <tags>
        <tag>c++</tag>
        <tag>素数</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算小结</title>
    <url>/2019/12/25/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>位运算主要包括按位与(&amp;)、按位或(|)、按位异或(^)、取反(~)、左移(&lt;&lt;)、右移(&gt;&gt;)这几种，其中除了取反(~)以外，其他的都是二目运算符，即要求运算符左右两侧均有一个运算量</p>
<span id="more"></span>

<h3 id="位运算概览"><a href="#位运算概览" class="headerlink" title="位运算概览"></a>位运算概览</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
<th>运算规则</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;&lt;</td>
<td>左移</td>
<td>各二进位全部左移若干位，高位丢弃，低位补0</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移</td>
<td>各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移</td>
</tr>
<tr>
<td>|</td>
<td>按位或</td>
<td>两个位都为0时，结果才为0</td>
</tr>
<tr>
<td>&amp;</td>
<td>按位与</td>
<td>两个位都为1时，结果才为1</td>
</tr>
<tr>
<td>~</td>
<td>按位取反</td>
<td>0变1，1变0</td>
</tr>
<tr>
<td>^</td>
<td>按位异或</td>
<td>^    异或    两个位相同为0，相异为1</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>博客重建</title>
    <url>/2021/04/09/%E5%8D%9A%E5%AE%A2%E9%87%8D%E5%BB%BA/</url>
    <content><![CDATA[<p>博客声明</p>
<span id="more"></span>

<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>由于当时重新配置个人电脑，所以重装了系统，后来其它事情多了起来（其实主要就是懒），就没再维护这个博客，最近一段时间发生了很多事，所以产生了从头再来的想法，并且<code>最新内容</code>以及<code>个人生活</code>、<code>文笔</code>将优先从本站发布，其它平台将陆续更新，并且某些平台将暂停使用（<em>注：版式将暂时沿用原有主题，有空会考虑自建一个主题使用</em>）</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>将舍弃以前大部分文章，从新开始写，并且整理成为专栏，可通过查看tags的方式找到某一系列文章，并且考虑在日后加入开源项目池，而且秉持技术开源思想，希望能与大佬多多交流</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>如果有想法想与我交流，可通过GitHub站内信的形式，如果你也觉得我做的不错，希望能给我点亮一个star</p>
]]></content>
  </entry>
  <entry>
    <title>排序之归并排序</title>
    <url>/2019/11/26/%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>来说说归并排序是啥？归并排序就是排序呗。啥，啥排序？归并呗。 </p>
<h2 id="哔bibibi-瞎哔哔"><a href="#哔bibibi-瞎哔哔" class="headerlink" title=" 哔bibibi(瞎哔哔)"></a> <del>哔bibibi(瞎哔哔)</del></h2><span id="more"></span>

<p>好吧,归并排序，是创建在归并操作上的一种有效的排序算法，效率为O(nlogn)。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分</p>
<p>治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。速度仅次于快速排序，为稳定排序算法，一般用</p>
<p>于对总体无序，但是各子项相对有序的数列，归并排序的比较次数小于快速排序的比较次数，移动次数一般多于快速排序的移动次数。</p>
<p><strong>算法思想</strong></p>
<p>该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶</p>
<p>段则将分的阶段得到的各答案”修补”在一起，即分而治之)。既然归并排序采用的是分治法，并且依托于归并操作，那么其思想肯定是分</p>
<p>而治之。我们知道归并操作是将两个有序的数列合并到一个有序的序列，那么对于一个无序的长序列，可以把它分解为若干个有序的子</p>
<p>序列，然后依次进行归并。如果我们说每一个数字都是单独有序的序列，那么只要把原始长序列依次分解，直到每个子序列都只有一个</p>
<p>元素的时候，再依次把所有的序列进行归并，直到序列数为1</p>
<p><img src="https://ftp.bmp.ovh/imgs/2019/12/623396b9f4e3a0ab.jpg" class="lazyload" data-srcset="https://ftp.bmp.ovh/imgs/2019/12/623396b9f4e3a0ab.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="alt 单向链表"></p>
<p>综上可知：</p>
<p>归并排序其实要做两件事：</p>
<p>（1）“分解”——将序列每次折半划分。<br>（2）“合并”——将划分后的序列段两两合并后排序。</p>
<p><strong>算法步骤</strong></p>
<p>(1)申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</p>
<p>(2)设定两个指针，最初位置分别为两个已经排序序列的起始位置；</p>
<p>(3)比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</p>
<p>(4)重复步骤 3 直到某一指针达到序列尾；</p>
<p>(5)将另一序列剩下的所有元素直接复制到合并序列尾。</p>
<p><strong>话不多说，上代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring &gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//归并过程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> help[r-l+<span class="number">1</span>];<span class="comment">//辅助数组</span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> lIndex = l;</span><br><span class="line">	<span class="keyword">int</span> rIndex = mid+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(lIndex &lt;= mid &amp;&amp; rIndex &lt;= r)&#123;</span><br><span class="line">		help[i++] = arr[lIndex] &lt; arr[rIndex] ? arr[lIndex++]:arr[rIndex++];</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//左边和右边肯定有一边到头了，不可能同时，因为每次只移动一边</span></span><br><span class="line">	<span class="keyword">while</span>(lIndex &lt;= mid)&#123;</span><br><span class="line">		help[i++] = arr[lIndex++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(rIndex &lt;= r)&#123;</span><br><span class="line">		help[i++] = arr[rIndex++];</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//将排好序的辅助数组赋值给原始数组，不需要返回值</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; r-l+<span class="number">1</span>; i++)&#123;</span><br><span class="line">		arr[l+i] = help[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">msort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//左半部分归并排序</span></span><br><span class="line">	<span class="built_in">msort</span>(arr, l, mid);</span><br><span class="line">    <span class="comment">//右半部分归并排序</span></span><br><span class="line">	<span class="built_in">msort</span>(arr, mid+<span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">//左右部分归并</span></span><br><span class="line">	<span class="built_in">merge</span>(arr, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序整个数组</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">msort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果数组为空或只有一个元素，不需要排序</span></span><br><span class="line">	<span class="keyword">if</span>(arr == <span class="literal">NULL</span> || n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">msort</span>(arr,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arry[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        cin&gt;&gt;arry[i];</span><br><span class="line">    <span class="built_in">msort</span>(arry, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        cout&lt;&lt;arry[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>c++</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>排序之快速排序</title>
    <url>/2019/11/24/%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="快排及快速排序，是排序算法中比较快速常用的一种排序方式"><a href="#快排及快速排序，是排序算法中比较快速常用的一种排序方式" class="headerlink" title="快排及快速排序，是排序算法中比较快速常用的一种排序方式"></a>快排及快速排序，是排序算法中比较快速常用的一种排序方式</h3><span id="more"></span>

<h2 id="一-基本原理"><a href="#一-基本原理" class="headerlink" title="一 基本原理"></a>一 基本原理</h2><h5 id="快速排序的根本可以说就是通过分治法来实现，简单举一个例子来理解一下快速排序的过程。"><a href="#快速排序的根本可以说就是通过分治法来实现，简单举一个例子来理解一下快速排序的过程。" class="headerlink" title="快速排序的根本可以说就是通过分治法来实现，简单举一个例子来理解一下快速排序的过程。"></a>快速排序的根本可以说就是通过分治法来实现，简单举一个例子来理解一下快速排序的过程。</h5><p> 我们现在对（56，28，45，93，10，32，44，95，60，58）进行排序。首先我们定义三个量，i，j，flag。i是数组第一个值的下表即i=0。j是数组最后一个值的下表即j=9，flag就是数组的第一个值即flag=56，现在我们要做的就是讲这个数组中所有比flag小的数放到他的前面，把所有比flag大的数放到他的后面。</p>
<ul>
<li><p>第一步从j开始向左（前）找，找到第一个比flag小的数，是下标为6的数44，我们就将44与flag56进行交换从而使数组变成（44，28，45，93，10，32，56，95，60，58），此时的j=6</p>
</li>
<li><p>第二步从i开始向右（后）找，找到第一个比flag大的数，是下标为3的数93，我们就将93与flag56进行交换从而使数组变成（44，28，45，56，10，32，93，95，60，58），此时的i=3</p>
</li>
<li><p>第三步继续从j（此时j=6）开始向左找，找到比flag小的数，是下标为5的数32，我们将32与flag进行交换，得到数组（44，28，45，32，10，56，93，95，60，58），此时j=5</p>
</li>
<li><p>第四步从i（此时i=3）开始向右找，找到比flag大的数，直到i=j,我们发现在j之前已经找不到比flag更大的数，此时快速排序的第一轮就已经结束，这个时候在flag之前的数都是比他小的，在他之后都是比他大的，我们再将flag前后两片区域重新定义成新的无序的数组，分别对他们重复刚才的过程，直到分解到每个重新划分的区域内只有一个值，排序就算完成了。我们直接将过程贴在下面</p>
<pre><code>（44，28，45，32，10）（56）（93，95，60，58）

（10，28，45，32，44）（56）（58，95，60，93）

（10，28，44，32，45）（56）（58，93，60，95）

（10，28，32，44，45）（56）（58，60，93，95）

（10，28，32）（44）（45）（56）（58）（60）（93）（95）

（10）（28）（32）（44）（45）（56）（58）（60）（93）（95）</code></pre></li>
</ul>
<p>排序结束</p>
<h2 id="二-稳定性问题"><a href="#二-稳定性问题" class="headerlink" title="二 稳定性问题"></a>二 稳定性问题</h2><p>&emsp;&emsp;首先大家应该都知道快速排序是一个不稳定排序算法，那么到底什么才是排序的稳定性呢，我认为通俗的讲有两个相同的数A和B，在排序之前A在B的前面，而经过排序之后，B跑到了A的前面，对于这种情况的发生，我们管他叫做排序的不稳定性，而快速排序在对存在相同数进行排序时就有可能发生这种情况。</p>
<p>&emsp;&emsp;例如（5，3A，6，3B）对这个进行排序，排序之前相同的数3A与3B，A在B的前面，经过排序之后会变成（3B，3A，5，6），所以说快速排序是一个不稳定的排序</p>
<p>三 时间复杂度</p>
<p>== 简单的总结一下快速排序的时间复杂度问题 ==</p>
<ul>
<li><p>最优情况:每一次的flag刚好都可以平分整个数组，此时的时间复杂度为O(nlogn)</p>
</li>
<li><p>最坏情况:每一次的flag刚好都是最大或者最小的数，此时的时间复杂度为O(n2)</p>
</li>
<li><p>平均情况:经过推到平均情况为O(nlogn)</p>
</li>
</ul>
<h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*qsort 快速排序</span></span><br><span class="line"><span class="comment">*@auther wyt</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">200</span>];</span><br><span class="line"><span class="comment">//定义快排函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, mid, t;</span><br><span class="line">	i = l;</span><br><span class="line">	j = r;</span><br><span class="line">	mid = a[(l + r) / <span class="number">2</span>];</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (a[i] &lt; mid) i++;		<span class="comment">//寻找左边小于mid的数</span></span><br><span class="line">		<span class="keyword">while</span> (a[j] &gt; mid) j--;     <span class="comment">//寻找右边小于mid的数</span></span><br><span class="line">		<span class="keyword">if</span> (i &lt;= j) &#123;</span><br><span class="line">			t = a[i];		        <span class="comment">//进行数值交换</span></span><br><span class="line">			a[i] = a[j];</span><br><span class="line">			a[j] = t;</span><br><span class="line">			i++;			        <span class="comment">//继续寻找</span></span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (i &lt;= j);</span><br><span class="line">	<span class="keyword">if</span> (j &gt; l) <span class="built_in">qsort</span>(l, j);			<span class="comment">//继续快排左右子序列</span></span><br><span class="line">	<span class="keyword">if</span> (i &lt; r) <span class="built_in">qsort</span>(i, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">	<span class="built_in">qsort</span>(<span class="number">1</span>, n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><del>~ PS ~</del></p>
<ul>
<li><p>C++中有自带的快排库(<algorithm>)，用法：sort(*array+left , *array+right)</p>
</li>
<li><p>C中的库是在(&lt;stdlib.h&gt;)中<br>用法：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">qsort</span>(a, <span class="number">1000</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>), cmp);</span><br><span class="line"><span class="comment">//其中cmp函数应写为：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">int</span>*)a - *(<span class="keyword">int</span>*)b; <span class="comment">//由小到大排序</span></span><br><span class="line">    <span class="comment">//return *(int *)b - *(int *)a; 由大到小排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>c++</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>排序之选择排序</title>
    <url>/2019/11/13/%E6%8E%92%E5%BA%8F%E4%B9%8B%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<ul>
<li>简单选择排序是交换排序类型的一种，其排序思想为：每趟从待排序的记录中选出关键字最小的记录，顺序放在已排序的记录序列末尾，直到全部排序结束为止。</li>
<li>简单选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。</li>
</ul>
<span id="more"></span>

<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>重复第二步，直到所有元素均排序完毕。</li>
</ol>
<h3 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif" class="lazyload" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="简单选择排序"></p>
<h3 id="数据处理流程"><a href="#数据处理流程" class="headerlink" title="数据处理流程"></a>数据处理流程</h3><p><img src="https://images2015.cnblogs.com/blog/318837/201604/318837-20160422104021288-937621481.png" class="lazyload" data-srcset="https://images2015.cnblogs.com/blog/318837/201604/318837-20160422104021288-937621481.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="简单选择排序"></p>
<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><hr>
<p><img src="https://images.cnblogs.com/cnblogs_com/TongWY/1887991/o_201124155411%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202020-11-24%20235355.png" class="lazyload" data-srcset="https://images.cnblogs.com/cnblogs_com/TongWY/1887991/o_201124155411%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202020-11-24%20235355.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<hr>
<h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><ul>
<li>简单选择排序的比较次数与序列的初始排序无关。 假设待排序的序列有 N 个元素，则比较次数总是<strong>N (N - 1)/2</strong>。</li>
<li>而移动次数与序列的初始排序有关。当序列正序时，移动次数最少，为 0.</li>
<li>当序列反序时，移动次数最多，为3N(N-1)/2。</li>
<li>所以，综合以上，简单排序的时间复杂度为 <strong>O(N2)</strong>。 </li>
</ul>
<hr>
<h5 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h5><ul>
<li>简单选择排序需要占用 <strong>1</strong> 个临时空间，在交换数值时使用。</li>
</ul>
<h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择排序函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; len - <span class="number">1</span> ; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; len; j++)     <span class="comment">//查找未排序的元素</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[min])    <span class="comment">//寻找最小值</span></span><br><span class="line">                min = j;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[min];</span><br><span class="line">        arr[min]= arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>c++</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>排序入坑之冒泡</title>
    <url>/2019/11/11/%E6%8E%92%E5%BA%8F%E5%85%A5%E5%9D%91%E4%B9%8B%E5%86%92%E6%B3%A1/</url>
    <content><![CDATA[<h3 id="算法入坑第一步，冒泡排序。"><a href="#算法入坑第一步，冒泡排序。" class="headerlink" title="算法入坑第一步，冒泡排序。"></a>算法入坑第一步，冒泡排序。</h3><p>搜索算法是我们学习过程中必不可少的一步，其实理解以后，它也没有那么难…来先看个冒泡吧</p>
<span id="more"></span>
<h5 id="冒泡算法"><a href="#冒泡算法" class="headerlink" title="冒泡算法"></a>冒泡算法</h5><p><strong>如果遇到相等的值不进行交换，那这种排序方式是稳定的排序方式。</strong></p>
<p>原理：比较两个相邻的元素，将值大的元素交换到右边</p>
<p>思路：依次比较相邻的两个数，将比较小的数放在前面，比较大的数放在后面。</p>
<ul>
<li><p>第一次比较：首先比较第一和第二个数，将小数放在前面，将大数放在后面。</p>
</li>
<li><p>比较第2和第3个数，将小数 放在前面，大数放在后面。</p>
<p>  ……</p>
</li>
<li><p>如此继续，知道比较到最后的两个数，将小数放在前面，大数放在后面，重复步骤，直至全部排序完成</p>
</li>
<li><p>在上面一趟比较完成后，最后一个数一定是数组中最大的一个数，所以在比较第二趟的时候，最后一个数是不参加比较的。</p>
</li>
<li><p>在第二趟比较完成后，倒数第二个数也一定是数组中倒数第二大数，所以在第三趟的比较中，最后两个数是不参与比较的。</p>
</li>
<li><p>依次类推，每一趟比较次数减少依次</p>
</li>
</ul>
<p>举例：</p>
<p>　　　　(1)要排序数组:[10,1,35,61,89,36,55]<br>　　　　(2)第一趟排序：</p>
<p>　　　　　　第一次排序：10和1比较，10大于1，交换位置 　　 　  [1,10,35,61,89,36,55]</p>
<p>　　　　　　第二次排序：10和35比较，10小于35，不交换位置　　[1,10,35,61,89,36,55]</p>
<p>　　　　　　第三次排序：35和61比较，35小于61，不交换位置　　[1,10,35,61,89,36,55]</p>
<p>　　　　　　第四次排序：61和89比较，61小于89，不交换位置　　[1,10,35,61,89,36,55]</p>
<p>　　　　　　第五次排序：10和1比较，10大于1，交换位置 　　 　  [1,10,35,61,89,36,55]</p>
<p>　　　　　　第六次排序：89和55比较，89大于55，交换位置　　　[1,10,35,61,36,55,89]</p>
<p>　　　　　　第一趟总共进行了六次比较，排序结果：[1,10,35,61,36,55,89]</p>
<p>　　　　(3)第二趟排序：</p>
<p>　　　　　　第一次排序：1和10比较，1小于10，不交换位置　　[1,10,35,61,36,55,89]</p>
<p>　　　　　　第二次排序：10和35比较，10小于35，不交换位置    [1,10,35,61,36,55,89]</p>
<p>　　　　　　第三次排序：35和61比较，35小于61，不交换位置     [1,10,35,61,36,55,89]</p>
<p>　　　　　　第四次排序：61和36比较，61大于36，交换位置　　　[1,10,35,36,61,55,89]</p>
<p>　　　　　　第五次排序：61和55比较，61大于55，交换位置　　　[1,10,35,36,55,61,89]</p>
<p>　　　　　　第二趟总共进行了5次比较，排序结果：[1,10,35,36,55,61,89]</p>
<p>　　　　(4)第三趟排序：</p>
<p>　　　　　　第一次排序：1和10比较，1小于10，不交换位置　　[1,10,35,36,55,61,89]</p>
<p>　　　　　　第二次排序：10和35比较，10小于35，不交换位置    [1,10,35,36,55,61,89]</p>
<p>　　　　　　第三次排序：35和36比较，35小于36，不交换位置     [1,10,35,36,55,61,89]</p>
<p>　　　　　　第四次排序：36和61比较，36小于61，不交换位置　　　1,10,35,36,55,61,89</p>
<p>　　　　　　第三趟总共进行了4次比较，排序结果：1,10,35,36,55,61,89</p>
<p>　　　　　　到目前位置已经为有序的情形了。　　　　</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span>    <span class="comment">//下面是函数sort的程序 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,temp;    <span class="comment">//定义三个整型变量 </span></span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;n<span class="number">-1</span>;j++)    <span class="comment">//用一个嵌套循环来遍历一遍每一对相邻元素 （所以冒泡函数慢嘛，时间复杂度高）  </span></span><br><span class="line">    &#123;                           </span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>-j;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;a[i+<span class="number">1</span>])  <span class="comment">//从大到小排就把左边的&quot;&gt;&quot;改为&quot;&lt;&quot;</span></span><br><span class="line">            &#123;</span><br><span class="line">                temp=a[i];      <span class="comment">//a[i]与a[i+1](即a[i]后面那个) 交换</span></span><br><span class="line">                a[i]=a[i+<span class="number">1</span>];    <span class="comment">//基本的交换原理&quot;c=a;a=b;b=c&quot; </span></span><br><span class="line">                a[i+<span class="number">1</span>]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.算法分析：</p>
<p>　　　　(1)由此可见：N个数字要排序完成，总共进行N-1趟排序，每i趟的排序次数为(N-i)次，所以可以用双重循环语句，外层控制循环多少趟，内层控制每一趟的循环次数</p>
<p>　　　　(2)冒泡排序的优点：每进行一趟排序，就会少比较一次，因为每进行一趟排序都会找出一个较大值。如上例：第一趟比较之后，排在最后的一个数一定是最大的一个数，第二趟排序的时候，只需要比较除了最后一个数以外的其他的数，同样也能找出一个最大的数排在参与第二趟比较的数后面，第三趟比较的时候，只需要比较除了最后两个数以外的其他的数，以此类推……也就是说，没进行一趟比较，每一趟少比较一次，一定程度上减少了算法的量。<br>　　　　<br>　　　　(3)时间复杂度</p>
<p>　　　　1.如果我们的数据正序，只需要走一趟即可完成排序。所需的比较次数C和记录移动次数M均达到最小值，即：Cmin=n-1;Mmin=0;所以，冒泡排序最好的时间复杂度为O(n)。</p>
<p>　　　　2.如果很不幸我们的数据是反序的，则需要进行n-1趟排序。每趟排序要进行n-i次比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：</p>
<p>　　　　　　综上所述：冒泡排序总的平均时间复杂度为：O(n2) ,时间复杂度和数据状况无关。</p>
]]></content>
      <tags>
        <tag>c++</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>素数，他，他又来了</title>
    <url>/2019/11/10/%E7%B4%A0%E6%95%B0%EF%BC%8C%E4%BB%96%EF%BC%8C%E4%BB%96%E5%8F%88%E6%9D%A5%E4%BA%86/</url>
    <content><![CDATA[<p>是他，是他，就是他，我们的…咳咳，走错片场了。一大堆素数朝你涌来，感谢埃拉托斯特尼，感谢欧拉(其实一点也不╮(╯▽╰)╭)</p>
<span id="more"></span>

<p>上次实际上是对单个数进行判断是否为素数，但是如果我们有一大堆素数，还用上次的方法的话，那么，，，一定很有趣。好吧我就直接说了，一大堆数进行判断，一个一个的进行循环无疑是很浪费时间的，那么我们就可以构建一个素数表，只需要判断一堆数是否在素数表里就可以了。</p>
<p>有请第一位嘉宾——埃拉托斯特尼筛法(简称埃氏筛法)</p>
<h3 id="埃氏筛法"><a href="#埃氏筛法" class="headerlink" title="埃氏筛法"></a>埃氏筛法</h3><p>首先，我们将2到n范围内的所有整数写下来。其中最小的数字2是素数。将表中所有2的倍数都划去。表中剩余的最小数字是3，它不能被更小的数整除，所以是素数。再将表中所有3的倍数都划去。依此类推，如果表中剩余的最小数字是m时，m就是素数。然后将表中所有m的倍数都化去。像这样反复操作，就能依次枚举n以内的素数。</p>
<p>话不多说，上代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> u[MAXN];			<span class="comment">//定义一个筛子</span></span><br><span class="line"><span class="keyword">int</span> su[MAXN], num = <span class="number">0</span>;	<span class="comment">//定义一个素数表及表的长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;		<span class="comment">//埃氏筛法函数</span></span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; MAXN; i++)		<span class="comment">//进行数组初始化</span></span><br><span class="line">		u[i] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; MAXN; i++)			<span class="comment">//从2到MAXN进行循环</span></span><br><span class="line">		<span class="keyword">if</span> (u[i]) &#123;						<span class="comment">//一旦u[i]是素数，那么筛去它小于MAXN的所有倍数</span></span><br><span class="line">			<span class="keyword">for</span> (j = <span class="number">2</span>; i * j &lt; MAXN; j++)</span><br><span class="line">				u[i * j] = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; MAXN; i++)			<span class="comment">//将筛出的素数填入素数表中</span></span><br><span class="line">		<span class="keyword">if</span> (u[i])</span><br><span class="line">			su[++num] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面埃氏筛法中，大家有没有发现一个问题</p>
<p>最小的素数是2，那么2的整数倍都不是素数，删去4,6,8…余下的数里，最小的素数是3，删去6,9,12…最终未被删去的数就是素数。但，这样在效率上有一个问题：一个数会被删去多次。例如42会被2 3 7都删去一遍，其时间复杂度为O(NlogNlogN)，，，所以，，，</p>
<h3 id="有请欧拉上场"><a href="#有请欧拉上场" class="headerlink" title="有请欧拉上场"></a>有请欧拉上场</h3><p>对每个合数a×b，它会被每个质因数都筛去一遍，但我们只要用最小的质因数筛去就好了为此，我们需要记录下所产生的全部素数，上代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> u[MAXN];        <span class="comment">//筛子</span></span><br><span class="line"><span class="keyword">int</span> su[MAXN],num=<span class="number">0</span>;       <span class="comment">//创建素数表及表长</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eulerSieve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(u,<span class="literal">true</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(u));       <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;=MAXN; i++)&#123;         <span class="comment">//顺序分析区间表中的每个数</span></span><br><span class="line">        <span class="keyword">if</span>(u[i])</span><br><span class="line">            su[++num]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=num; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i*su[j]&gt;MAXN)        <span class="comment">//如果i与当前素数的乘积大于MAXN，则跳过</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            u[i*su[j]]=<span class="literal">false</span>;       <span class="comment">//素数的倍数必为非素数，筛去</span></span><br><span class="line">            <span class="keyword">if</span>(i%su[j]==<span class="number">0</span>)          <span class="comment">//如果su[j]是i的最小素数，则进行下一个i的判断</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心就是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(i%su[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>如果i能整除su[k]，说明su[k]是i的因子，所以su[k]也是i的任意倍数的因子。所以su[k]也是i×su[x] (x&gt;k)的因子。考虑到primelist单增，对i×su[x]，su[k]就是它的比su[x]更小的因子。故不用考虑其后的质因子了（i×su[x]会被su[k]作为因子在i更大时被筛掉）</p>
]]></content>
      <tags>
        <tag>c++</tag>
        <tag>素数</tag>
      </tags>
  </entry>
  <entry>
    <title>配置Clion开发STM32[优雅的开发]</title>
    <url>/2021/05/24/%E9%85%8D%E7%BD%AEClion%E5%BC%80%E5%8F%91STM32-%E4%BC%98%E9%9B%85%E7%9A%84%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p>快来试试用Clion替换掉古董的Keil的开发环境，康康优雅の开发</p>
<span id="more"></span>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>尽管对于STM32的开发而言，Keil已经是一个很好的工具了，作为一个老牌的嵌入式开发用IDE，功能也很完善，升级到5.XX版本之后界面看着也挺现代。但是，作为一个属于上一个时代的开发环境，写代码时会感觉到它的自动补全、智能提示等等功能非常弱，特别是在CubeMX工具大大改善了初始化配置的体验以后，这种不足就显得更加突出了。</p>
<p>  而Keil的缺点正是CLion的重要优点，CLion由JetBrains公司开发，是一个广受赞誉的IDE，自动补全、智能提示能力一流，活动模板等特性可以大大提升开发效率。</p>
<p>  当然，早期CLion是不能用于单片机开发的，不过，用户要求添加相关功能的呼声一直很高，也一直有人通过各种魔改来在CLion下进行单片机开发工作。终于，在2019.1版本中，CLion添加了对于CubeMX的支持（2020.1版本则更加完善），然后，辅以几个其他的工具，可以在CLion下完成STM开发中的全部工作。而且，相关配置可以在任意主流桌面平台上搭建。</p>
<p>  So，赶紧折腾起来，换上属于新时代的开发工具，进行优雅の开发</p>
<h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h1><h2 id="必备软件"><a href="#必备软件" class="headerlink" title="必备软件"></a>必备软件</h2><ul>
<li>CLion ——-主角</li>
<li>STM32CubeMX ST官方力推的自动化配置和代码生成工具</li>
<li>OpenOCD ——调试工具</li>
<li>gcc-arm-none-eabi ——–交叉编译工具链</li>
<li>MinGW ——–额，你可以认为这是一个大礼包</li>
<li>可能还包括你所使用的调试器的驱动，之前安装过就行</li>
</ul>
<h2 id="MinGW"><a href="#MinGW" class="headerlink" title="MinGW"></a>MinGW</h2><p>首先，从<a href="http://www.mingw-w64.org/doku.php">这里</a>下载MinGW（其实是MinGW-w64，兼容MinGW且更强大），然后解压到某个目录（以后不要改动）</p>
<p>然后，添加环境变量，具体到bin目录，比如<code>C:ToolChainming\w64\bin</code>这样，根据自己安装目录确定</p>
<p>打开命令行，输入<code>gcc -v</code>测试一下，没有提示不是可用的指令而是返回了一大堆信息就说明一切正常</p>
<blockquote>
<p>补充：安装过Dev-cpp之类的自带MinGW的软件的话这个安装环节可以省略</p>
</blockquote>
<h2 id="OpenOCD"><a href="#OpenOCD" class="headerlink" title="OpenOCD"></a>OpenOCD</h2><p>首先，在<a href="https://gnutoolchains.com/arm-eabi/openocd/">这里</a>下载并解压到某个目录（之后不要改动）</p>
<p>然后，添加环境变量，还是具体到bin目录</p>
<p>最后同样要测试一下，命令行输入<code>openocd -v</code>，回车，返回版本信息说明状态正常</p>
<h2 id="gcc-arm-none-eabi"><a href="#gcc-arm-none-eabi" class="headerlink" title="gcc-arm-none-eabi"></a>gcc-arm-none-eabi</h2><p>首先，在<a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads">这里</a>下载并解压到某个目录（之后不要改动）</p>
<p>然后，添加环境变量</p>
<p>开命令行用<code>arm-none-eabi-gcc -v</code>测试一下，返回版本信息说明正常</p>
<h2 id="STM32CubeMX"><a href="#STM32CubeMX" class="headerlink" title="STM32CubeMX"></a>STM32CubeMX</h2><p>CubeMX是基于Java开发的软件，所以需要先安装Java运行环境（JRE、Java Runtime Environment），根据自己系统和CPU选择版本，如intel+win10 64位应选择“jre-8u251-windows-x64.exe”</p>
<p>安装JRE以后，命令行下用<code>java -version</code>进行测试，返回版本信息则正常。</p>
<p>然后，我们来安装STM32CubeMX，从<a href="https://www.st.com/zh/development-tools/stm32cubemx.html">这里</a>下载即可，安装过程没什么特别的。</p>
<blockquote>
<p>补充：JRE必须是64位的，否则CubeMX会不正常</p>
</blockquote>
<h1 id="哎，不写了，就是玩，就玩"><a href="#哎，不写了，就是玩，就玩" class="headerlink" title="哎，不写了，就是玩，就玩"></a>哎，不写了，就是玩，就玩</h1>]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>LintCode巴什博弈</title>
    <url>/2021/05/28/LintCode%E5%B7%B4%E4%BB%80%E5%8D%9A%E5%BC%88/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.lintcode.com/problem/1300">题目</a>描述</h2><p>你正在和朋友玩一个游戏：桌子上有一堆石头，每一次你们都会从中拿出1到3个石头。拿走最后一个石头的人赢得游戏。游戏开始时，你是先手。</p>
<span id="more"></span>

<p>假设两个人都绝对理性，都会做出最优决策。给定石头的数量，判断你是否会赢得比赛。</p>
<p>举例：有四个石头，那么你永远不会赢得游戏。不管拿几个，最后一个石头一定会被你的朋友拿走</p>
<h2 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h2><h3 id="样例一："><a href="#样例一：" class="headerlink" title="样例一："></a>样例一：</h3><blockquote>
<p>输入：n = 4 </p>
<p>输出：False</p>
<p>解析：先手取走1,2或者3，对方都会取走最后一个</p>
</blockquote>
<h3 id="样例二："><a href="#样例二：" class="headerlink" title="样例二："></a>样例二：</h3><blockquote>
<p>输入：n = 5 </p>
<p>输出：True</p>
<p>解析：先手拿1个，必胜</p>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这道题的关键是寻找“必胜态”。</p>
<p>根据题设条件：</p>
<p>当n∈[1,3]时，先手必胜</p>
<p>当n == 4时，无论先手第一轮如何选取，下一轮都会转化为n∈[1,3]的情形，此时先手必负</p>
<p>当n∈[5,7]时，先手必胜，先手分别通过取走[1,3]颗石头，可将状态转化为n == 4时的情形，此时后手必负</p>
<p>当n == 8时，无论先手第一轮如何选取，下一轮都会转化为n∈[5,7]的情形，此时先手必负</p>
<p>……</p>
<p>以此类推，可以得出结论：</p>
<p>当n % 4 != 0时，先手必胜；否则先手必负</p>
<blockquote>
<p>这就有点动态规划的思想了，无论刚开始是多少，都可以一步一步转化为一个最小问题规模</p>
</blockquote>
<p>在你的对手最后一次拿的时候，石头要是4个， 这时无论他拿1、2、3个，你都有石头拿。要保证这一点，你需要保证每次你拿完时石头的个数是4的倍数。那就意味着一开始石头的数目不是4的倍数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param n: an integer</span></span><br><span class="line"><span class="comment">     * @return: whether you can win the game given the number of stones in the heap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canWinBash</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Write your code here</span></span><br><span class="line">        <span class="keyword">return</span> n%<span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>LintCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LintCode编辑距离</title>
    <url>/2021/05/29/LintCode%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.lintcode.com/problem/119">题目</a>描述</h2><p>给出两个单词<code>word1</code>和<code>word2</code>，计算出将<code>word1</code> 转换为<code>word2</code>的最少操作次数。 你可进行三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<blockquote>
<p>len(word1), len(word2) &lt;= 500</p>
</blockquote>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例一："><a href="#样例一：" class="headerlink" title="样例一："></a>样例一：</h3><p>输入：</p>
<blockquote>
<p>word1 = “horse”<br>word2 = “ros”</p>
</blockquote>
<p>输出：</p>
<blockquote>
<p>3</p>
</blockquote>
<p>解释：</p>
<blockquote>
<p>horse -&gt; rorse (替换 ‘h’ 为 ‘r’)<br> rorse -&gt; rose (删除 ‘r’)<br>rose -&gt; ros (删除 ‘e’)</p>
</blockquote>
<h3 id="样例二："><a href="#样例二：" class="headerlink" title="样例二："></a>样例二：</h3><p>输入：</p>
<blockquote>
<p>word1 = “intention”<br>word2 = “execution”</p>
</blockquote>
<p>输出：</p>
<blockquote>
<p>5</p>
</blockquote>
<p>解释：</p>
<blockquote>
<p>intention -&gt; inention (删除 ‘t’)<br>inention -&gt; enention (替换 ‘i’ 为 ‘e’)<br>enention -&gt; exention (替换 ‘n’ 为 ‘x’)<br>exention -&gt; exection (替换 ‘n’ 为 ‘c’)<br>exection -&gt; execution (插入 ‘u’)</p>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这道题乍一看，作为老暴力选手，那么就遍历遍历，疯狂遍历</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param word1: A string</span></span><br><span class="line"><span class="comment">     * @param word2: A string</span></span><br><span class="line"><span class="comment">     * @return: The minimum number of steps.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(string &amp;word1, string &amp;word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.<span class="built_in">size</span>(), n = word2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="built_in">max</span>(m, n)));</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>LintCode</tag>
      </tags>
  </entry>
  <entry>
    <title>动规的初级理解</title>
    <url>/2019/11/10/%E5%8A%A8%E8%A7%84%E7%9A%84%E5%88%9D%E7%BA%A7%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>动态规划是学习算法过程中的一道绊脚石，那么今天就让我们，走进动态规划的世界里，不要恐惧它，其实挺有意思的</p>
<span id="more"></span>

<h4 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h4><p>动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。</p>
<h4 id="二、基本思想与策略"><a href="#二、基本思想与策略" class="headerlink" title="二、基本思想与策略"></a>二、基本思想与策略</h4><p>基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。</p>
<p>由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。</p>
<p>与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。</p>
<h4 id="三、适用的情况"><a href="#三、适用的情况" class="headerlink" title="三、适用的情况"></a>三、适用的情况</h4><p>能采用动态规划求解的问题的一般要具有3个性质：</p>
<p>(1) 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。</p>
<p>(2) 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</p>
<p>（3）有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）</p>
<hr>
<hr>
<h4 id="四、求解的基本步骤"><a href="#四、求解的基本步骤" class="headerlink" title="四、求解的基本步骤"></a>四、求解的基本步骤</h4><p>动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。</p>
<p>初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态</p>
<p>图1 动态规划决策过程示意图</p>
<p>(1)划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。</p>
<p>(2)确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。</p>
<p>(3)确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。</p>
<p>(4)寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。</p>
<p>一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。</p>
<p>实际应用中可以按以下几个简化的步骤进行设计：</p>
<p>（1）分析最优解的性质，并刻画其结构特征。</p>
<p>（2）递归的定义最优解。</p>
<p>（3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值</p>
<p>（4）根据计算最优值时得到的信息，构造问题的最优解</p>
<h4 id="五、算法实现的说明"><a href="#五、算法实现的说明" class="headerlink" title="五、算法实现的说明"></a>五、算法实现的说明</h4><p>动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。</p>
<p>使用动态规划求解问题，最重要的就是确定动态规划三要素：</p>
<p>（1）问题的阶段 （2）每个阶段的状态</p>
<p>（3）从前一个阶段转化到后一个阶段之间的递推关系。</p>
<p>递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。</p>
<p>确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">f</span>(n,m)=max&#123;<span class="built_in">f</span>(n<span class="number">-1</span>,m), <span class="built_in">f</span>(n<span class="number">-1</span>,m-w[n])+<span class="built_in">P</span>(n,m)&#125;</span><br></pre></td></tr></table></figure>
<h3 id="六、动态规划算法基本框架"><a href="#六、动态规划算法基本框架" class="headerlink" title="六、动态规划算法基本框架"></a>六、动态规划算法基本框架</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=m; j=j+<span class="number">1</span>) <span class="comment">// 第一个阶段</span></span><br><span class="line">   xn[j] = 初始值;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span>(i=n<span class="number">-1</span>; i&gt;=<span class="number">1</span>; i=i<span class="number">-1</span>)<span class="comment">// 其他n-1个阶段</span></span><br><span class="line">   <span class="keyword">for</span>(j=<span class="number">1</span>; j&gt;=<span class="built_in">f</span>(i); j=j+<span class="number">1</span>)<span class="comment">//f(i)与i有关的表达式</span></span><br><span class="line">     xi[j]=j=max（或min）&#123;<span class="built_in">g</span>(xi<span class="number">-1</span>[j1:j2]), ......, <span class="built_in">g</span>(xi<span class="number">-1</span>[jk:jk+<span class="number">1</span>])&#125;;</span><br><span class="line"> </span><br><span class="line">t = <span class="built_in">g</span>(x1[j1:j2]); <span class="comment">// 由子问题的最优解求解整个问题的最优解的方案</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(x1[j1]);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;=n<span class="number">-1</span>; i=i+<span class="number">1</span>）</span><br><span class="line">&#123;  </span><br><span class="line">     t = t-xi<span class="number">-1</span>[ji];</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">for</span>(j=<span class="number">1</span>; j&gt;=<span class="built_in">f</span>(i); j=j+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>(t=xi[ji])</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
</search>
