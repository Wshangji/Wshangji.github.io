<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JVM、JRE和JDK</title>
    <url>/2021/04/11/JVM%E3%80%81JRE%E5%92%8CJDK/</url>
    <content><![CDATA[<p>计算机高级语言的类型主要有编译型和解释型两种，而Java 语言是两种类型的结合。<br>Java首先利用文本编辑器编写 Java源程序，源文件的后缀名为.java；再利用编译器（javac）将源程序编译成字节码文件，字节码文件的后缀名为.class； 最后利用虚拟机（解释器，java）解释执行。</p>
<span id="more"></span>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494836063440655.png" class="lazyload" data-srcset="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494836063440655.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Alt Java"></p>
<p>JVM(Java Virtual Machine)就是一个虚拟的用于执行bytecode字节码的”虚拟计算机”。他也定义了指令集、寄存器集、结构栈、垃圾收集堆、内存区域。JVM负责将Java字节码解释运行，边解释边运行，这样，速度就会受到一定的影响。</p>
<p>不同的操作系统有不同的虚拟机。Java 虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，随处运行”。 Java虚拟机是实现跨平台的核心机制。如图所示：<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494837984812122.png" class="lazyload" data-srcset="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494837984812122.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Alt JVM"></p>
<p>Java Runtime Environment (JRE) 包含：Java虚拟机、库函数、运行Java应用程序所必须的文件。</p>
<p>Java  Development Kit (JDK)包含：包含JRE，以及增加编译器和调试器等用于程序开发的文件。</p>
<p>JDK、JRE和JVM的关系如图所示。<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494837979897855.png" class="lazyload" data-srcset="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494837979897855.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Alt 关系图"></p>
<p>  ·如果只是要运行Java程序，只需要JRE就可以。JRE通常非常小，其中包含了JVM。</p>
<p>  ·如果要开发Java程序，就需要安装JDK。</p>
<p><strong>Java环境搭建</strong></p>
<p>下载JDK<br>    下载地址：<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">www.oracle.com/technetwork/java/javase/downloads/index.html</a></p>
<p>点击下载JDK，会出现下载列表界面。首先，点击”Accept License Agreement”，然后选择对应的版本，下载即可。</p>
<p>注意：<br>    32位操作系统只能安装32位JDK；<br>    64位操作系统可安装32位JDK，也可以安装64位JDK。</p>
<p>安装JDK</p>
<p>安装过程和普通软件安装没什么区别，过程中会让你选择JDK和JRE安装目录，采用默认即可。也就是说，通通点击“下一步”就能完成安装。<br>安装成功后我们再进入JDK的安装目录，可以看到如下的结构：<br>其中：</p>
<pre><code>bin目录是存储一些可执行的二进制文件；

lib存储相关jar包；

src.zip是JDK相关JAVA类的源代码。</code></pre><p><strong>环境变量Path的配置</strong><br>&emsp;&emsp;环境变量是在操作系统中一个具有特定名字的对象， 它包含了一个或者多个应用程序所将使用到的信息。</p>
<p>&emsp;&emsp;Path是一个常见的环境变量，它告诉操作系统，当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下寻找此程序外，还应到哪些目录下寻找。</p>
<p>设置Parh环境变量：</p>
<ol>
<li><p>右键计算机——&gt;属性——&gt;高级系统设置<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494838772220505.png" class="lazyload" data-srcset="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494838772220505.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Alt 1"></p>
</li>
<li><p>单击环境变量按钮<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494838780549127.png" class="lazyload" data-srcset="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494838780549127.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Alt 2"></p>
</li>
<li><p>单击新建按钮，新建JAVA_HOME变量（用于说明JDK的安装目录）<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494838787522279.png" class="lazyload" data-srcset="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494838787522279.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Alt 3"></p>
</li>
<li><p>修改系统环境变量Path，在最前面追加%JAVA_HOME%\bin  并以;和原路径分隔。再增加：“.;”。这是表示当前目录的意思<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494838936169679.png" class="lazyload" data-srcset="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494838936169679.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Alt 4"></p>
</li>
</ol>
<p>注意：</p>
<pre><code>此处一定是英文分号而不是中文分号！！！

classpath配置问题：如果使用JDK1.5以上就不需要配置这个环境变量！JRE会自动搜索当前路径下的类文件及相关jar文件</code></pre><hr>
<p>2021-04-11注：目前从Oracle下载的jdk安装程序，安装完成以后无需配置环境变量，安装过程中会自动配置完成</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>flybird</title>
    <url>/2019/11/11/flybird/</url>
    <content><![CDATA[<h2 id="一个简单的C-小游戏"><a href="#一个简单的C-小游戏" class="headerlink" title="一个简单的C++小游戏"></a>一个简单的C++小游戏</h2><span id="more"></span>

<hr>
<h3 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Lines = <span class="number">35</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Columns = <span class="number">120</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LeftLineColumn = <span class="number">20</span>;</span><br><span class="line">HANDLE hOut;</span><br><span class="line">DWORD dword;</span><br><span class="line"><span class="keyword">char</span> tmp[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> cur_time, start_time, last_time;</span><br><span class="line"><span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawBird</span><span class="params">(<span class="keyword">double</span> xx, <span class="keyword">double</span> yy)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = (<span class="keyword">int</span>)(xx + <span class="number">0.5</span>);</span><br><span class="line">  <span class="keyword">int</span> y = (<span class="keyword">int</span>)(yy + <span class="number">0.5</span>);</span><br><span class="line">  <span class="keyword">static</span> DWORD dword;</span><br><span class="line">  <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;v&quot;</span>, <span class="number">1</span>, (COORD)&#123;x, y - <span class="number">1</span>&#125;, &amp;dword);</span><br><span class="line">  <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;&gt;&gt;&gt;&quot;</span>, <span class="number">3</span>, (COORD)&#123;x - <span class="number">1</span>, y&#125;, &amp;dword);</span><br><span class="line">  <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;^&quot;</span>, <span class="number">1</span>, (COORD)&#123;x, y + <span class="number">1</span>&#125;, &amp;dword);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearBird</span><span class="params">(<span class="keyword">double</span> xx, <span class="keyword">double</span> yy)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = (<span class="keyword">int</span>)(xx + <span class="number">0.5</span>);</span><br><span class="line">  <span class="keyword">int</span> y = (<span class="keyword">int</span>)(yy + <span class="number">0.5</span>);</span><br><span class="line">  <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot; &quot;</span>, <span class="number">1</span>, (COORD)&#123;x, y - <span class="number">1</span>&#125;, &amp;dword);</span><br><span class="line">  <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;   &quot;</span>, <span class="number">3</span>, (COORD)&#123;x - <span class="number">1</span>, y&#125;, &amp;dword);</span><br><span class="line">  <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot; &quot;</span>, <span class="number">1</span>, (COORD)&#123;x, y + <span class="number">1</span>&#125;, &amp;dword);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Write at Middle/Left */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">WriteMiddle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> l = <span class="built_in">strlen</span>(str);</span><br><span class="line">  <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, str, l, (COORD)&#123;(Columns - l) / <span class="number">2</span>, y&#125;, &amp;dword);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">WriteLeft</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> l = <span class="built_in">strlen</span>(str);</span><br><span class="line">  <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, str, l, (COORD)&#123;<span class="number">1</span>, y&#125;, &amp;dword);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitLeftSide</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lines; ++i)</span><br><span class="line">    <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;|&quot;</span>, <span class="number">2</span>, (COORD)&#123;LeftLineColumn, i&#125;, &amp;dword);</span><br><span class="line">  <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">  ++p; <span class="built_in">WriteLeft</span>(<span class="string">&quot;Help:&quot;</span>, p);</span><br><span class="line">  ++p; <span class="built_in">WriteLeft</span>(<span class="string">&quot; Press &lt;Space&gt; to&quot;</span>, p);</span><br><span class="line">  ++p; <span class="built_in">WriteLeft</span>(<span class="string">&quot;make the bird fly.&quot;</span>, p);</span><br><span class="line">  ++p; <span class="built_in">WriteLeft</span>(<span class="string">&quot; Don&#x27;t fall to the&quot;</span>, p);</span><br><span class="line">  ++p; <span class="built_in">WriteLeft</span>(<span class="string">&quot;ground or hit pipes&quot;</span>, p);</span><br><span class="line">  ++p; <span class="comment">// Empty line</span></span><br><span class="line">  ++p; <span class="built_in">WriteLeft</span>(<span class="string">&quot;Time:&quot;</span>, p);</span><br><span class="line">  ++p; <span class="comment">// Time</span></span><br><span class="line">  ++p; <span class="built_in">WriteLeft</span>(<span class="string">&quot;Fps:&quot;</span>, p);</span><br><span class="line">  ++p; <span class="comment">// Fps</span></span><br><span class="line">  ++p; <span class="comment">// Empty line</span></span><br><span class="line">  ++p; <span class="built_in">WriteLeft</span>(<span class="string">&quot;Score:&quot;</span>, p);</span><br><span class="line">  ++p; <span class="comment">// Score</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawLeftSide</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">  ++p; <span class="comment">// WriteLeft(&quot;Help:&quot;, p);</span></span><br><span class="line">  ++p; <span class="comment">// WriteLeft(&quot; Press &lt;Space&gt; to&quot;, p);</span></span><br><span class="line">  ++p; <span class="comment">// WriteLeft(&quot;make the bird fly.&quot;, p);</span></span><br><span class="line">  ++p; <span class="comment">// WriteLeft(&quot; Don&#x27;t fall to the&quot;, p);</span></span><br><span class="line">  ++p; <span class="comment">// WriteLeft(&quot;ground or hit pipes&quot;, p);</span></span><br><span class="line">  ++p; <span class="comment">// Empty line</span></span><br><span class="line">  ++p; <span class="comment">// WriteLeft(&quot;Time:&quot;, p);</span></span><br><span class="line">  <span class="built_in">sprintf</span>(tmp, <span class="string">&quot; %5.2lfs&quot;</span>, (<span class="keyword">double</span>)(cur_time - start_time) / CLOCKS_PER_SEC);</span><br><span class="line">  ++p; <span class="built_in">WriteLeft</span>(tmp, p);</span><br><span class="line">  ++p; <span class="comment">// WriteLeft(&quot;Fps:&quot;, p);</span></span><br><span class="line">  <span class="built_in">sprintf</span>(tmp, <span class="string">&quot; %5.2lf&quot;</span>, CLOCKS_PER_SEC / (<span class="keyword">double</span>)(cur_time - last_time));</span><br><span class="line">  ++p; <span class="built_in">WriteLeft</span>(tmp, p);</span><br><span class="line">  ++p; <span class="comment">// Empty line</span></span><br><span class="line">  ++p; <span class="comment">// WriteLeft(&quot;Score:&quot;, p);</span></span><br><span class="line">  <span class="built_in">sprintf</span>(tmp, <span class="string">&quot; %3d&quot;</span>, score);</span><br><span class="line">  ++p; <span class="built_in">WriteLeft</span>(tmp, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pipe</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> H, D; <span class="comment">// A Pipe, [x, x + 1] * ([0, H] and [D, Lines))</span></span><br><span class="line">  <span class="keyword">double</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">RandRange</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">rand</span>() % (r - l + <span class="number">1</span>) + l; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Pipe <span class="title">RandomPipe</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> br = <span class="built_in">RandRange</span>(<span class="number">8</span>, <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">int</span> h = <span class="built_in">RandRange</span>(<span class="number">3</span>, Lines - br - <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> (Pipe)&#123;h, h + br, (<span class="keyword">double</span>)x&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">CheckPipe</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">double</span> y, <span class="keyword">const</span> Pipe &amp;p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> px = (<span class="keyword">int</span>)(p.x + <span class="number">0.5</span>);</span><br><span class="line">  <span class="keyword">int</span> dx = std::<span class="built_in">min</span>(std::<span class="built_in">abs</span>(x - px), std::<span class="built_in">abs</span>(x - px - <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">if</span> (dx &gt; <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (dx == <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> y &gt; p.H - <span class="number">0.5</span> &amp;&amp; y &lt; p.D + <span class="number">0.5</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (dx == <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> y &gt; p.H + <span class="number">0.5</span> &amp;&amp; y &lt; p.D - <span class="number">0.5</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> y &gt; p.H + <span class="number">1.5</span> &amp;&amp; y &lt; p.D - <span class="number">1.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearPipe</span><span class="params">(<span class="keyword">const</span> Pipe &amp;p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> px = (<span class="keyword">int</span>)(p.x + <span class="number">0.5</span>);</span><br><span class="line">  <span class="keyword">if</span> (px != LeftLineColumn &amp;&amp; px + <span class="number">1</span> &lt; Columns) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.H; ++i)</span><br><span class="line">      <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;  &quot;</span>, <span class="number">2</span>, (COORD)&#123;px, i&#125;, &amp;dword);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p.D + <span class="number">1</span>; i &lt; Lines; ++i)</span><br><span class="line">      <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;  &quot;</span>, <span class="number">2</span>, (COORD)&#123;px, i&#125;, &amp;dword);</span><br><span class="line">    <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;  &quot;</span>, <span class="number">2</span>, (COORD)&#123;px + <span class="number">1</span>, p.H&#125;, &amp;dword);</span><br><span class="line">    <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;  &quot;</span>, <span class="number">2</span>, (COORD)&#123;px + <span class="number">1</span>, p.D&#125;, &amp;dword);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> x = px == LeftLineColumn ? px + <span class="number">1</span> : px;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.H; ++i)</span><br><span class="line">      <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot; &quot;</span>, <span class="number">1</span>, (COORD)&#123;x, i&#125;, &amp;dword);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p.D + <span class="number">1</span>; i &lt; Lines; ++i)</span><br><span class="line">      <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot; &quot;</span>, <span class="number">1</span>, (COORD)&#123;x, i&#125;, &amp;dword);</span><br><span class="line">    <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot; &quot;</span>, <span class="number">1</span>, (COORD)&#123;x, p.H&#125;, &amp;dword);</span><br><span class="line">    <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot; &quot;</span>, <span class="number">1</span>, (COORD)&#123;x, p.D&#125;, &amp;dword);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawPipe</span><span class="params">(<span class="keyword">const</span> Pipe &amp;p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> px = (<span class="keyword">int</span>)(p.x + <span class="number">0.5</span>);</span><br><span class="line">  <span class="keyword">if</span> (px &lt; LeftLineColumn) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (px != LeftLineColumn &amp;&amp; px + <span class="number">1</span> &lt; Columns) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.H; ++i)</span><br><span class="line">      <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;||&quot;</span>, <span class="number">2</span>, (COORD)&#123;px, i&#125;, &amp;dword);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p.D + <span class="number">1</span>; i &lt; Lines; ++i)</span><br><span class="line">      <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;||&quot;</span>, <span class="number">2</span>, (COORD)&#123;px, i&#125;, &amp;dword);</span><br><span class="line">    <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;--&quot;</span>, <span class="number">2</span>, (COORD)&#123;px, p.H&#125;, &amp;dword);</span><br><span class="line">    <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;--&quot;</span>, <span class="number">2</span>, (COORD)&#123;px, p.D&#125;, &amp;dword);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> x = px == LeftLineColumn ? px + <span class="number">1</span> : px;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.H; ++i)</span><br><span class="line">      <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;|&quot;</span>, <span class="number">1</span>, (COORD)&#123;x, i&#125;, &amp;dword);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p.D + <span class="number">1</span>; i &lt; Lines; ++i)</span><br><span class="line">      <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;|&quot;</span>, <span class="number">1</span>, (COORD)&#123;x, i&#125;, &amp;dword);</span><br><span class="line">    <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;-&quot;</span>, <span class="number">1</span>, (COORD)&#123;x, p.H&#125;, &amp;dword);</span><br><span class="line">    <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;-&quot;</span>, <span class="number">1</span>, (COORD)&#123;x, p.D&#125;, &amp;dword);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">HideCursor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  CONSOLE_CURSOR_INFO cci;</span><br><span class="line">  <span class="built_in">GetConsoleCursorInfo</span>(hOut,&amp;cci);</span><br><span class="line">  cci.bVisible = FALSE;</span><br><span class="line">  <span class="built_in">SetConsoleCursorInfo</span>(hOut,&amp;cci);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">  <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;mode con lines=%d cols=%d&quot;</span>, Lines, Columns);</span><br><span class="line">  <span class="built_in">system</span>(tmp);</span><br><span class="line">  hOut = <span class="built_in">GetStdHandle</span>(STD_OUTPUT_HANDLE);</span><br><span class="line">  <span class="built_in">HideCursor</span>();</span><br><span class="line">  <span class="built_in">InitLeftSide</span>();</span><br><span class="line">  <span class="built_in">WriteMiddle</span>(<span class="string">&quot;Flappy bird (Simple)&quot;</span>, Lines / <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">WriteMiddle</span>(<span class="string">&quot;--By _wyt&quot;</span>, Lines / <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">WriteMiddle</span>(<span class="string">&quot;Press any key to start...&quot;</span>, Lines / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">  _getch();</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pipe pipes[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Init</span>();</span><br><span class="line">  <span class="built_in">InitLeftSide</span>();</span><br><span class="line">  last_time = start_time = <span class="built_in">clock</span>();</span><br><span class="line">  score = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> g = <span class="number">35</span>; <span class="comment">// Gravitational acceleration, grid / s^2</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> vx = <span class="number">12.0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> x = <span class="number">27.0</span>;</span><br><span class="line">  <span class="keyword">double</span> y = <span class="number">5.0</span>, vy = <span class="number">0.0</span>;</span><br><span class="line">  <span class="keyword">int</span> pipe_n = <span class="number">0</span>;</span><br><span class="line">  pipes[pipe_n++] = <span class="built_in">RandomPipe</span>(Columns - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">kbhit</span>()) &#123;</span><br><span class="line">      <span class="keyword">char</span> c = _getch();</span><br><span class="line">      <span class="keyword">if</span> (c == <span class="number">32</span>) vy = <span class="number">-15.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cur_time = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">double</span> time_break = (<span class="keyword">double</span>)(cur_time - last_time) / CLOCKS_PER_SEC;</span><br><span class="line">    <span class="built_in">ClearBird</span>(x, y);</span><br><span class="line">    y = std::<span class="built_in">min</span>(vy * time_break + y, <span class="number">33.0</span>);</span><br><span class="line">    vy += g * time_break;</span><br><span class="line">    <span class="keyword">if</span> (y &lt; <span class="number">1</span> - <span class="number">1e-6</span>) &#123; y = <span class="number">1</span>; vy = <span class="number">.0</span>; &#125;</span><br><span class="line">    <span class="built_in">DrawBird</span>(x, y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pipe_n; ++i) &#123;</span><br><span class="line">      <span class="keyword">double</span> px = pipes[i].x, px2 = pipes[i].x - vx * time_break;</span><br><span class="line">      <span class="keyword">if</span> ((<span class="keyword">int</span>)(px + <span class="number">0.5</span>) != (<span class="keyword">int</span>)(px2 + <span class="number">0.5</span>)) &#123;</span><br><span class="line">        <span class="built_in">ClearPipe</span>(pipes[i]);</span><br><span class="line">        pipes[i].x = px2;</span><br><span class="line">        <span class="built_in">DrawPipe</span>(pipes[i]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pipes[i].x = px2;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Columns - pipes[pipe_n - <span class="number">1</span>].x &gt; <span class="number">30</span>)</span><br><span class="line">      <span class="built_in">DrawPipe</span>(pipes[pipe_n++] = <span class="built_in">RandomPipe</span>(Columns - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> failed = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pipe_n; ++i) &#123;</span><br><span class="line">      failed = failed || !<span class="built_in">CheckPipe</span>((<span class="keyword">int</span>)(x + <span class="number">0.5</span>), y, pipes[i]);</span><br><span class="line">      <span class="keyword">if</span> ((<span class="keyword">int</span>)(pipes[i].x + <span class="number">0.5</span>) &gt;= LeftLineColumn)</span><br><span class="line">        pipes[j++] = pipes[i];</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        ++score;</span><br><span class="line">    &#125;</span><br><span class="line">    pipe_n = j;</span><br><span class="line">    <span class="built_in">DrawLeftSide</span>();</span><br><span class="line">    <span class="keyword">if</span> (y &gt;= <span class="number">33.0</span> - <span class="number">1e-6</span> || failed) &#123;</span><br><span class="line">      <span class="built_in">DrawBird</span>(x, y);</span><br><span class="line">      <span class="built_in">WriteMiddle</span>(<span class="string">&quot;-------------------------------&quot;</span>, Lines / <span class="number">2</span> - <span class="number">2</span>);</span><br><span class="line">      <span class="built_in">WriteMiddle</span>(<span class="string">&quot;|                             |&quot;</span>, Lines / <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">      <span class="built_in">WriteMiddle</span>(<span class="string">&quot;|                             |&quot;</span>, Lines / <span class="number">2</span>);</span><br><span class="line">      <span class="built_in">WriteMiddle</span>(<span class="string">&quot;|                             |&quot;</span>, Lines / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">      <span class="built_in">WriteMiddle</span>(<span class="string">&quot;|                             |&quot;</span>, Lines / <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line">      <span class="built_in">WriteMiddle</span>(<span class="string">&quot;-------------------------------&quot;</span>, Lines / <span class="number">2</span> + <span class="number">3</span>);</span><br><span class="line">      <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;Your score: %d!&quot;</span>, score);</span><br><span class="line">      <span class="built_in">WriteMiddle</span>(tmp, Lines / <span class="number">2</span>);</span><br><span class="line">      <span class="built_in">WriteMiddle</span>(<span class="string">&quot;Press any key to exit...&quot;</span>, Lines / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">      _getch();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    last_time = cur_time;</span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">40</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> _ **** 嘿嘿，慢慢玩 _</p>
]]></content>
      <categories>
        <category>趣味</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>c++&amp;vector</title>
    <url>/2019/12/03/c-vector/</url>
    <content><![CDATA[<p>在c++中，vector是一个十分有用的容器。</p>
<p>作用：它能够像容器一样存放各种类型的对象，简单地说，vector是一个能够存放任意类型的动态数组，能够增加和压缩数据。</p>
<p>vector在C++标准模板库中的部分内容，它是一个多功能的，能够操作多种数据结构和算法的模板类和函数库。</p>
<span id="more"></span>

<p><strong>特别注意：</strong></p>
<p>使用vector需要注意以下几点：</p>
<p>1.加入头文件<code>&lt;vector&gt;</code></p>
<p>2.如果你要表示的向量长度较长（需要为向量内部保存很多数），容易导致内存泄漏，而且效率会很低；</p>
<p>3.Vector作为函数的参数或者返回值时，需要注意它的写法：</p>
<p> ==double Distance(vector<int>&amp;a, vector<int>&amp;b) 其中的“&amp;”绝对不能少！！！==</p>
<h2 id="一维vector"><a href="#一维vector" class="headerlink" title=" 一维vector"></a><center> 一维vector</center></h2><p><strong>创建一维vector：</strong></p>
<pre><code>vector&lt;int&gt; nums;       //不指定长度
vector&lt;int&gt; nums(n);    //指定长度为n</code></pre><p><strong>添加元素</strong></p>
<pre><code>nums.push_back(1);      //直接从数组末端添加
nums[i]=1;              //直接赋值给第i个位置
nums.insert(nums.begin()+i,a);  //在第i+1个元素前插入a</code></pre><p><strong>删除元素</strong></p>
<pre><code>nums.resize(nums.size-i);    //直接将数组长度减少，某种意义上删掉了后面i个
nums.pop_back();             //删掉最后一个元素
nums.erase(nums.begin()+i);  //删掉第i+1个元素
nums.erase(nums.begin()+i,nums.end()+j);    //删除区间[i,j-1],区间从0开始
nums.clear();                //清空</code></pre><p><strong>其它</strong></p>
<p>获取长度：nums.size();</p>
<p>排序(O(nlogn))：sort(nums.begin(),nums.end());</p>
<p>翻转：reverse(nums.begin(),nums.end());</p>
<p>合并两个vector：合并nums1和nums2，并将合并的数组赋值给nums</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nums1</span><span class="params">(m)</span>,<span class="title">nums2</span><span class="params">(n)</span></span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">nums.<span class="built_in">resize</span>(m+n);</span><br><span class="line"><span class="built_in">merge</span>(nums1.<span class="built_in">begin</span>(),nums1.<span class="built_in">end</span>(),nums2.<span class="built_in">begin</span>(),nums2.<span class="built_in">end</span>(),nums);</span><br></pre></td></tr></table></figure>

<h2 id="二维vector"><a href="#二维vector" class="headerlink" title="二维vector"></a><center>二维vector</center></h2><p><strong>创建M*n二维vector</strong></p>
<pre><code>vector&lt; vector&lt;int&gt; &gt; nums(m,vector&lt;int&gt;(n));   //m*n的二维vector</code></pre><p>解释：</p>
<p>定义了一个vector容器，元素类型为vector<int>，初始化为包含m个vector<int>对象，每个对象都是一个新创立的vector<int>对象的拷贝，而这个新创立的vector<int>对象被初始化为包含n个0。</p>
<p>vector<int>(n)表示构造一个无名且含n个0的vector<int>对象。</p>
<p><strong>动态创建m*n的二维vector</strong></p>
<p>==方法一==</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector &lt;<span class="keyword">int</span>&gt; &gt; nums;<span class="number">3</span></span><br><span class="line"></span><br><span class="line">nums.<span class="built_in">resize</span>(m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) nums[i].<span class="built_in">resize</span>(n);</span><br></pre></td></tr></table></figure>

<p>==方法二==</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector &lt;<span class="keyword">int</span>&gt; &gt; nums;</span><br><span class="line">nums.<span class="built_in">resize</span>(m,vector&lt;<span class="keyword">int</span>&gt;(n));</span><br></pre></td></tr></table></figure>
<p><strong>初始化二维数组</strong></p>
<pre><code>vector&lt;vector &lt;int&gt; &gt; nums(m ,vector&lt;int&gt;(n,0));    //m*n的二维vector，所有元素为0</code></pre><p>获得二维数组的行数：nums.size(); </p>
<p>获得二维数组的列数：nums[0].size()；</p>
<p><strong>数组遍历</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m = nums.<span class="built_in">size</span>(),n = nums[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">        cout&lt;&lt;nums[i][j]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用vector还可以用结构体类型哟"><a href="#用vector还可以用结构体类型哟" class="headerlink" title="用vector还可以用结构体类型哟"></a><del>用vector还可以用结构体类型哟</del></h3>]]></content>
      <tags>
        <tag>c++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>love</title>
    <url>/2021/04/13/love/</url>
    <content><![CDATA[<p>My love for you exists in every bit of life,like this code</p>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(meetMe || !meetMe) &#123; <span class="comment">//你见，或者不见我</span></span><br><span class="line">   <span class="keyword">await</span> there(&#123;</span><br><span class="line">      <span class="attr">me</span>: &#123;        <span class="comment">//我就在那里</span></span><br><span class="line">         <span class="attr">sad</span>: <span class="literal">null</span>, <span class="comment">//不悲 不喜</span></span><br><span class="line">         <span class="attr">happy</span>: <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(meetMe || !meetMe) &#123;    <span class="comment">//你念，或者不念我</span></span><br><span class="line">   <span class="keyword">await</span> there(&#123;</span><br><span class="line">      <span class="attr">feeling</span>: &#123;    <span class="comment">//情就在那里</span></span><br><span class="line">         <span class="attr">left</span>: <span class="number">0</span>,   <span class="comment">//不来 不去</span></span><br><span class="line">         <span class="attr">right</span>: <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(loveMe || !loveMe) &#123;    <span class="comment">//你爱，或者不爱我</span></span><br><span class="line">   <span class="keyword">await</span> there(&#123;     <span class="comment">//爱就在那里</span></span><br><span class="line">      <span class="attr">love</span>: <span class="literal">Infinity</span> <span class="comment">//不增不减</span></span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(withMe || !withMe) &#123;    <span class="comment">//你跟，或者不跟我</span></span><br><span class="line">   <span class="keyword">const</span> tomorrow = &#123; <span class="comment">//我的手就在你手里</span></span><br><span class="line">      <span class="attr">we</span>: myHands &amp;&amp; yourHands</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">Object</span>.freeze(tomorrow)    <span class="comment">//不舍不弃</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!myArms.has(you)) &#123;    <span class="comment">//来我的怀里</span></span><br><span class="line">   OR             <span class="comment">//或者</span></span><br><span class="line">   yourHeart.push(me) <span class="comment">//让我住进你的心里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>爱</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>爱</tag>
      </tags>
  </entry>
  <entry>
    <title>三行情话</title>
    <url>/2021/04/10/%E4%B8%89%E8%A1%8C%E6%83%85%E8%AF%97/</url>
    <content><![CDATA[<p>螃蟹在剥我的壳，笔记本在写我</p>
<p>漫天的我落在枫叶上、雪花上</p>
<p>而你在想我      ————《武汉大学-三行情诗》</p>
<span id="more"></span>

<h4 id="有一种理解"><a href="#有一种理解" class="headerlink" title="有一种理解"></a>有一种理解</h4><p>也是最美好的一种解释，即全文主宾倒装</p>
<p>我在剥螃蟹的壳、写笔记本，枫叶、雪花落在我上，而我在…</p>
<h4 id="有一种理解-1"><a href="#有一种理解-1" class="headerlink" title="有一种理解"></a>有一种理解</h4><p>也是对情感的绝望，即全文否定</p>
<p>螃蟹不可能在剥我的壳，笔记本不可能在写我，我不可能落在枫叶上、雪花上，而你也不可能在想我</p>
<h4 id="有一种理解-2"><a href="#有一种理解-2" class="headerlink" title="有一种理解"></a>有一种理解</h4><p>也是一种自欺欺人</p>
<p>只有当在螃蟹在剥我的壳，笔记本写我，我落在枫叶上、雪花上的时候，你才会想我</p>
]]></content>
      <categories>
        <category>爱</category>
      </categories>
      <tags>
        <tag>生活,爱</tag>
      </tags>
  </entry>
  <entry>
    <title>世界上没那么多错过</title>
    <url>/2020/02/03/%E4%B8%96%E7%95%8C%E4%B8%8A%E6%B2%A1%E9%82%A3%E4%B9%88%E5%A4%9A%E9%94%99%E8%BF%87/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="f0883e4a2eb1aa1381b3ba18f0ff3a6c51e49fa31e82c87cb9cf7bd705157243">6de660ac7b4e1815a73b127ec3abb05f51924f2811536e1624e23d55841dcfc3b15b449442c5c9931bd4010101b285b6b9b8e00c5d4344e2d3d77d2995b1c79a830705f1c6dfaa178056ed6a45908020f375498dd1050e1269dde668b04939d41aa33660746b2dc957b8989f7d9cd9c069bebcba9ba98ed6c7b0d1bdbdd5b8e5f2642d08b81bccf7225d9cde4b89eadece8fc5458c9b628cc4f27097c519b0ab5976bf641ccecdbd380fe9793d772e4284e5259d13008906d713f0df100eb9ee439dc69758c863877cd3856afc46e7bbbec1bbf00c38b1dd252e973abee74deb9d0886049447f8980e3bb31d77639b1b92269a7a2441752826401112cb60ccbc370b9fd7620d0ab8db6a40cc6a45b3aeb0117086cae0cee2e2673a38b4780ec4cb935ea2d2bb25f54a1414b38905aa07315b5875aec77880c545c4f4317ce41873e8edcf5167a95589b72547ef266fb1770e7eec99bb5b092300bdb094d1020d6cc0542c81fc94813cfbc8736a41a4fd38bfdbac53947c30a3d22f1ec3f759b4418cc66c45dfb0fc155b100b3ace70b0adf8ce69b5ba70b7f8862c5e782cfa384fc31025e2fdd92a4296fc023420d1372372ae8f542c0d7355b308b7e2df755d0ebc23c08ac15d8b52ce64e547854dd6b136ef20204a037745647b5a102c2b6f4d7669ca79545ec8685c57fcdf805941610af5328c9e743c338c29f5f47f7be1acc7753e3b0b487e3d870d406575a4304010430744f4a6b4a393a73b74819447c18db3208ea308343d4f67125626618aac8c8e011ee9ca77a59fab83d3e8f01b4856deba7addceb238b2f87164e4bed64060ddabf148e089baa4a07f0447199e8362df71b101aa1863aa38958920175a4b80b772dc103d09eaaa0191e7a076941f111ed06b1cc107f542b1910b3f8818790f3b8ab14d78989a29c63ee434677b1280eb853a6ec1309ad34cedba19091b4bc36cd447b97c455f62a4d059b7a85d4d71935b76f36bcac3ae1015fea0c5571e39bdf51947d9b569da0841631594c6e22449c8d288977d2a5c75eea45e55396023e4d76dce3c26dce4698798637a0839e6fe3eaabf1dde8efa542c6c4aac682f7ca02f56d9d3d4477c6e78c908a8e61657d2d836c5f6b9a7901a8fb4636ebd3fb5ceae5522df6e05fb3bea5683353233de3d49e1f34333a872fd1a421603360730620a28a96e7b6ded2f34074f3ef455a9cd748483522d88962824c057350ed347984441cbae34fff44b537def5a0a175a6238dbca14270a6ef0a468efee1bc27f62f3af422502152535e0eaa2f226ce12e3bd94b934db39a2c858a2ceadcae250ba0ad129574a40d9f3ebf300d9af740b53ad028451d83a59f2a8536636a7</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">你猜</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>人生路不长，别再等以后(转载)</title>
    <url>/2019/11/12/%E4%BA%BA%E7%94%9F%E8%B7%AF%E4%B8%8D%E9%95%BF%EF%BC%8C%E5%88%AB%E5%86%8D%E7%AD%89%E4%BB%A5%E5%90%8E-%E8%BD%AC%E8%BD%BD/</url>
    <content><![CDATA[<center>一辈子很短，短得来不及细算</center> 

<span id="more"></span>

<center></center****> 

<p>童年，不知不觉没了<br>青春，不知不觉没了<br>而那些无忧无虑的快乐<br>好像也消失不见了<br>一辈子三万天而已<br>没有你想得那么长<br>有什么心愿，快点实现<br>有什么目标，快点奋战<br>别等来等去<br>等来了年龄增长<br>等来了热情褪去<br>人生不是花，败了再开<br>身体不是叶，落了再生<br>我们每个人<br>都只有一次人生，只有一个身体<br>生病不能等，健康没了，人就完了<br>人生不能等，时间过了，人就终了<br>一辈子不长，别再等以后<br>想吃的东西，去吃<br>想做的事情，趁早<br>想要的感情，去追<br>想去的地方，快去<br>别一等再等<br>等牙没有了，想吃就难了<br>等人离开了，想爱就晚了<br>一辈子很短，这一生短暂<br>时间不等人，岁月不等你<br>趁我们都还活着<br>对父母，孝顺点，对爱人，珍惜点<br>对朋友，真心点，对自己，好一点</p>
<p>```</p>
<h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>初级素数判断</title>
    <url>/2019/11/10/%E5%88%9D%E7%BA%A7%E7%B4%A0%E6%95%B0%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<p>这篇只是让大家初步了解如何判断素数，是最基础的内容，之后会讲一些欧拉，埃氏等素数筛的方法</p>
<span id="more"></span>

<h6 id="第一次的想法"><a href="#第一次的想法" class="headerlink" title="第一次的想法:"></a>第一次的想法:</h6><p>==让它爆搜一遍不就好了== <del>爆搜大法好爆搜大法好</del></p>
<blockquote>
<p>具体实现就是让数n从2开始模,一直模到n-1,如果都不能被整除,那就是素数<strong>紧扣定义</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否是素数1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;please inpout a number.&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; m; ++i)</span><br><span class="line">        <span class="keyword">if</span> (m%i == <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; m &lt;&lt; <span class="string">&quot; isn&#x27;t a prime\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; m &lt;&lt; <span class="string">&quot; is a prime\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这么复杂,那来进行下简单优化:<br>如果一个数有因子的话，那么在它的平方根数以内就应该有，否则就没有因子。例如66的平方根在8与9之间，因为66不是素数，，则它一定有比8还小的因子，我们知道66的因子是2、3、6等<br><strong>那我们就可以这样写了</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="built_in">sqrt</span>(m); ++i)&#123;</span><br><span class="line">    <span class="keyword">if</span> (m%i == <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; m &lt;&lt; <span class="string">&quot; isn&#x27;t a prime\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>本次初级素数判断就先到这里</strong><br><strong>有没有感觉到循环挺浪费时间的呢</strong><br><strong>那去想想有什么方法能够进一步降低时间复杂度</strong></p>
]]></content>
      <tags>
        <tag>c++</tag>
        <tag>素数</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算小结</title>
    <url>/2019/12/25/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>位运算主要包括按位与(&amp;)、按位或(|)、按位异或(^)、取反(~)、左移(&lt;&lt;)、右移(&gt;&gt;)这几种，其中除了取反(~)以外，其他的都是二目运算符，即要求运算符左右两侧均有一个运算量</p>
<span id="more"></span>

<h3 id="位运算概览"><a href="#位运算概览" class="headerlink" title="位运算概览"></a>位运算概览</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
<th>运算规则</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;&lt;</td>
<td>左移</td>
<td>各二进位全部左移若干位，高位丢弃，低位补0</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移</td>
<td>各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移</td>
</tr>
<tr>
<td>|</td>
<td>按位或</td>
<td>两个位都为0时，结果才为0</td>
</tr>
<tr>
<td>&amp;</td>
<td>按位与</td>
<td>两个位都为1时，结果才为1</td>
</tr>
<tr>
<td>~</td>
<td>按位取反</td>
<td>0变1，1变0</td>
</tr>
<tr>
<td>^</td>
<td>按位异或</td>
<td>^    异或    两个位相同为0，相异为1</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>博客重建</title>
    <url>/2021/04/09/%E5%8D%9A%E5%AE%A2%E9%87%8D%E5%BB%BA/</url>
    <content><![CDATA[<p>博客声明</p>
<span id="more"></span>

<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>由于当时重新配置个人电脑，所以重装了系统，后来其它事情多了起来（其实主要就是懒），就没再维护这个博客，最近一段时间发生了很多事，所以产生了从头再来的想法，并且<code>最新内容</code>以及<code>个人生活</code>、<code>文笔</code>将优先从本站发布，其它平台将陆续更新，并且某些平台将暂停使用（<em>注：版式将暂时沿用原有主题，有空会考虑自建一个主题使用</em>）</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>将舍弃以前大部分文章，从新开始写，并且整理成为专栏，可通过查看tags的方式找到某一系列文章，并且考虑在日后加入开源项目池，而且秉持技术开源思想，希望能与大佬多多交流</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>如果有想法想与我交流，可通过GitHub站内信的形式，如果你也觉得我做的不错，希望能给我点亮一个star</p>
]]></content>
  </entry>
  <entry>
    <title>排序之归并排序</title>
    <url>/2019/11/26/%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>来说说归并排序是啥？归并排序就是排序呗。啥，啥排序？归并呗。 </p>
<h2 id="哔bibibi-瞎哔哔"><a href="#哔bibibi-瞎哔哔" class="headerlink" title=" 哔bibibi(瞎哔哔)"></a> <del>哔bibibi(瞎哔哔)</del></h2><span id="more"></span>

<p>好吧,归并排序，是创建在归并操作上的一种有效的排序算法，效率为O(nlogn)。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分</p>
<p>治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。速度仅次于快速排序，为稳定排序算法，一般用</p>
<p>于对总体无序，但是各子项相对有序的数列，归并排序的比较次数小于快速排序的比较次数，移动次数一般多于快速排序的移动次数。</p>
<p><strong>算法思想</strong></p>
<p>该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶</p>
<p>段则将分的阶段得到的各答案”修补”在一起，即分而治之)。既然归并排序采用的是分治法，并且依托于归并操作，那么其思想肯定是分</p>
<p>而治之。我们知道归并操作是将两个有序的数列合并到一个有序的序列，那么对于一个无序的长序列，可以把它分解为若干个有序的子</p>
<p>序列，然后依次进行归并。如果我们说每一个数字都是单独有序的序列，那么只要把原始长序列依次分解，直到每个子序列都只有一个</p>
<p>元素的时候，再依次把所有的序列进行归并，直到序列数为1</p>
<p><img src="https://ftp.bmp.ovh/imgs/2019/12/623396b9f4e3a0ab.jpg" class="lazyload" data-srcset="https://ftp.bmp.ovh/imgs/2019/12/623396b9f4e3a0ab.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="alt 单向链表"></p>
<p>综上可知：</p>
<p>归并排序其实要做两件事：</p>
<p>（1）“分解”——将序列每次折半划分。<br>（2）“合并”——将划分后的序列段两两合并后排序。</p>
<p><strong>算法步骤</strong></p>
<p>(1)申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</p>
<p>(2)设定两个指针，最初位置分别为两个已经排序序列的起始位置；</p>
<p>(3)比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</p>
<p>(4)重复步骤 3 直到某一指针达到序列尾；</p>
<p>(5)将另一序列剩下的所有元素直接复制到合并序列尾。</p>
<p><strong>话不多说，上代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring &gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//归并过程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> help[r-l+<span class="number">1</span>];<span class="comment">//辅助数组</span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> lIndex = l;</span><br><span class="line">	<span class="keyword">int</span> rIndex = mid+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(lIndex &lt;= mid &amp;&amp; rIndex &lt;= r)&#123;</span><br><span class="line">		help[i++] = arr[lIndex] &lt; arr[rIndex] ? arr[lIndex++]:arr[rIndex++];</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//左边和右边肯定有一边到头了，不可能同时，因为每次只移动一边</span></span><br><span class="line">	<span class="keyword">while</span>(lIndex &lt;= mid)&#123;</span><br><span class="line">		help[i++] = arr[lIndex++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(rIndex &lt;= r)&#123;</span><br><span class="line">		help[i++] = arr[rIndex++];</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//将排好序的辅助数组赋值给原始数组，不需要返回值</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; r-l+<span class="number">1</span>; i++)&#123;</span><br><span class="line">		arr[l+i] = help[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">msort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//左半部分归并排序</span></span><br><span class="line">	<span class="built_in">msort</span>(arr, l, mid);</span><br><span class="line">    <span class="comment">//右半部分归并排序</span></span><br><span class="line">	<span class="built_in">msort</span>(arr, mid+<span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">//左右部分归并</span></span><br><span class="line">	<span class="built_in">merge</span>(arr, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序整个数组</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">msort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果数组为空或只有一个元素，不需要排序</span></span><br><span class="line">	<span class="keyword">if</span>(arr == <span class="literal">NULL</span> || n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">msort</span>(arr,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arry[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        cin&gt;&gt;arry[i];</span><br><span class="line">    <span class="built_in">msort</span>(arry, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        cout&lt;&lt;arry[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>c++</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>排序之快速排序</title>
    <url>/2019/11/24/%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="快排及快速排序，是排序算法中比较快速常用的一种排序方式"><a href="#快排及快速排序，是排序算法中比较快速常用的一种排序方式" class="headerlink" title="快排及快速排序，是排序算法中比较快速常用的一种排序方式"></a>快排及快速排序，是排序算法中比较快速常用的一种排序方式</h3><span id="more"></span>

<h2 id="一-基本原理"><a href="#一-基本原理" class="headerlink" title="一 基本原理"></a>一 基本原理</h2><h5 id="快速排序的根本可以说就是通过分治法来实现，简单举一个例子来理解一下快速排序的过程。"><a href="#快速排序的根本可以说就是通过分治法来实现，简单举一个例子来理解一下快速排序的过程。" class="headerlink" title="快速排序的根本可以说就是通过分治法来实现，简单举一个例子来理解一下快速排序的过程。"></a>快速排序的根本可以说就是通过分治法来实现，简单举一个例子来理解一下快速排序的过程。</h5><p> 我们现在对（56，28，45，93，10，32，44，95，60，58）进行排序。首先我们定义三个量，i，j，flag。i是数组第一个值的下表即i=0。j是数组最后一个值的下表即j=9，flag就是数组的第一个值即flag=56，现在我们要做的就是讲这个数组中所有比flag小的数放到他的前面，把所有比flag大的数放到他的后面。</p>
<ul>
<li><p>第一步从j开始向左（前）找，找到第一个比flag小的数，是下标为6的数44，我们就将44与flag56进行交换从而使数组变成（44，28，45，93，10，32，56，95，60，58），此时的j=6</p>
</li>
<li><p>第二步从i开始向右（后）找，找到第一个比flag大的数，是下标为3的数93，我们就将93与flag56进行交换从而使数组变成（44，28，45，56，10，32，93，95，60，58），此时的i=3</p>
</li>
<li><p>第三步继续从j（此时j=6）开始向左找，找到比flag小的数，是下标为5的数32，我们将32与flag进行交换，得到数组（44，28，45，32，10，56，93，95，60，58），此时j=5</p>
</li>
<li><p>第四步从i（此时i=3）开始向右找，找到比flag大的数，直到i=j,我们发现在j之前已经找不到比flag更大的数，此时快速排序的第一轮就已经结束，这个时候在flag之前的数都是比他小的，在他之后都是比他大的，我们再将flag前后两片区域重新定义成新的无序的数组，分别对他们重复刚才的过程，直到分解到每个重新划分的区域内只有一个值，排序就算完成了。我们直接将过程贴在下面</p>
<pre><code>（44，28，45，32，10）（56）（93，95，60，58）

（10，28，45，32，44）（56）（58，95，60，93）

（10，28，44，32，45）（56）（58，93，60，95）

（10，28，32，44，45）（56）（58，60，93，95）

（10，28，32）（44）（45）（56）（58）（60）（93）（95）

（10）（28）（32）（44）（45）（56）（58）（60）（93）（95）</code></pre></li>
</ul>
<p>排序结束</p>
<h2 id="二-稳定性问题"><a href="#二-稳定性问题" class="headerlink" title="二 稳定性问题"></a>二 稳定性问题</h2><p>&emsp;&emsp;首先大家应该都知道快速排序是一个不稳定排序算法，那么到底什么才是排序的稳定性呢，我认为通俗的讲有两个相同的数A和B，在排序之前A在B的前面，而经过排序之后，B跑到了A的前面，对于这种情况的发生，我们管他叫做排序的不稳定性，而快速排序在对存在相同数进行排序时就有可能发生这种情况。</p>
<p>&emsp;&emsp;例如（5，3A，6，3B）对这个进行排序，排序之前相同的数3A与3B，A在B的前面，经过排序之后会变成（3B，3A，5，6），所以说快速排序是一个不稳定的排序</p>
<p>三 时间复杂度</p>
<p>== 简单的总结一下快速排序的时间复杂度问题 ==</p>
<ul>
<li><p>最优情况:每一次的flag刚好都可以平分整个数组，此时的时间复杂度为O(nlogn)</p>
</li>
<li><p>最坏情况:每一次的flag刚好都是最大或者最小的数，此时的时间复杂度为O(n2)</p>
</li>
<li><p>平均情况:经过推到平均情况为O(nlogn)</p>
</li>
</ul>
<h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*qsort 快速排序</span></span><br><span class="line"><span class="comment">*@auther wyt</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">200</span>];</span><br><span class="line"><span class="comment">//定义快排函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, mid, t;</span><br><span class="line">	i = l;</span><br><span class="line">	j = r;</span><br><span class="line">	mid = a[(l + r) / <span class="number">2</span>];</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (a[i] &lt; mid) i++;		<span class="comment">//寻找左边小于mid的数</span></span><br><span class="line">		<span class="keyword">while</span> (a[j] &gt; mid) j--;     <span class="comment">//寻找右边小于mid的数</span></span><br><span class="line">		<span class="keyword">if</span> (i &lt;= j) &#123;</span><br><span class="line">			t = a[i];		        <span class="comment">//进行数值交换</span></span><br><span class="line">			a[i] = a[j];</span><br><span class="line">			a[j] = t;</span><br><span class="line">			i++;			        <span class="comment">//继续寻找</span></span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (i &lt;= j);</span><br><span class="line">	<span class="keyword">if</span> (j &gt; l) <span class="built_in">qsort</span>(l, j);			<span class="comment">//继续快排左右子序列</span></span><br><span class="line">	<span class="keyword">if</span> (i &lt; r) <span class="built_in">qsort</span>(i, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">	<span class="built_in">qsort</span>(<span class="number">1</span>, n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><del>~ PS ~</del></p>
<ul>
<li><p>C++中有自带的快排库(<algorithm>)，用法：sort(*array+left , *array+right)</p>
</li>
<li><p>C中的库是在(&lt;stdlib.h&gt;)中<br>用法：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">qsort</span>(a, <span class="number">1000</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>), cmp);</span><br><span class="line"><span class="comment">//其中cmp函数应写为：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">int</span>*)a - *(<span class="keyword">int</span>*)b; <span class="comment">//由小到大排序</span></span><br><span class="line">    <span class="comment">//return *(int *)b - *(int *)a; 由大到小排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>c++</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>排序之选择排序</title>
    <url>/2019/11/13/%E6%8E%92%E5%BA%8F%E4%B9%8B%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<ul>
<li>简单选择排序是交换排序类型的一种，其排序思想为：每趟从待排序的记录中选出关键字最小的记录，顺序放在已排序的记录序列末尾，直到全部排序结束为止。</li>
<li>简单选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。</li>
</ul>
<span id="more"></span>

<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>重复第二步，直到所有元素均排序完毕。</li>
</ol>
<h3 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif" class="lazyload" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="简单选择排序"></p>
<h3 id="数据处理流程"><a href="#数据处理流程" class="headerlink" title="数据处理流程"></a>数据处理流程</h3><p><img src="https://images2015.cnblogs.com/blog/318837/201604/318837-20160422104021288-937621481.png" class="lazyload" data-srcset="https://images2015.cnblogs.com/blog/318837/201604/318837-20160422104021288-937621481.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="简单选择排序"></p>
<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><hr>
<p><img src="https://images.cnblogs.com/cnblogs_com/TongWY/1887991/o_201124155411%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202020-11-24%20235355.png" class="lazyload" data-srcset="https://images.cnblogs.com/cnblogs_com/TongWY/1887991/o_201124155411%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202020-11-24%20235355.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<hr>
<h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><ul>
<li>简单选择排序的比较次数与序列的初始排序无关。 假设待排序的序列有 N 个元素，则比较次数总是<strong>N (N - 1)/2</strong>。</li>
<li>而移动次数与序列的初始排序有关。当序列正序时，移动次数最少，为 0.</li>
<li>当序列反序时，移动次数最多，为3N(N-1)/2。</li>
<li>所以，综合以上，简单排序的时间复杂度为 <strong>O(N2)</strong>。 </li>
</ul>
<hr>
<h5 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h5><ul>
<li>简单选择排序需要占用 <strong>1</strong> 个临时空间，在交换数值时使用。</li>
</ul>
<h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择排序函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; len - <span class="number">1</span> ; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; len; j++)     <span class="comment">//查找未排序的元素</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[min])    <span class="comment">//寻找最小值</span></span><br><span class="line">                min = j;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[min];</span><br><span class="line">        arr[min]= arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>c++</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>排序入坑之冒泡</title>
    <url>/2019/11/11/%E6%8E%92%E5%BA%8F%E5%85%A5%E5%9D%91%E4%B9%8B%E5%86%92%E6%B3%A1/</url>
    <content><![CDATA[<h3 id="算法入坑第一步，冒泡排序。"><a href="#算法入坑第一步，冒泡排序。" class="headerlink" title="算法入坑第一步，冒泡排序。"></a>算法入坑第一步，冒泡排序。</h3><p>搜索算法是我们学习过程中必不可少的一步，其实理解以后，它也没有那么难…来先看个冒泡吧</p>
<span id="more"></span>
<h5 id="冒泡算法"><a href="#冒泡算法" class="headerlink" title="冒泡算法"></a>冒泡算法</h5><p><strong>如果遇到相等的值不进行交换，那这种排序方式是稳定的排序方式。</strong></p>
<p>原理：比较两个相邻的元素，将值大的元素交换到右边</p>
<p>思路：依次比较相邻的两个数，将比较小的数放在前面，比较大的数放在后面。</p>
<ul>
<li><p>第一次比较：首先比较第一和第二个数，将小数放在前面，将大数放在后面。</p>
</li>
<li><p>比较第2和第3个数，将小数 放在前面，大数放在后面。</p>
<p>  ……</p>
</li>
<li><p>如此继续，知道比较到最后的两个数，将小数放在前面，大数放在后面，重复步骤，直至全部排序完成</p>
</li>
<li><p>在上面一趟比较完成后，最后一个数一定是数组中最大的一个数，所以在比较第二趟的时候，最后一个数是不参加比较的。</p>
</li>
<li><p>在第二趟比较完成后，倒数第二个数也一定是数组中倒数第二大数，所以在第三趟的比较中，最后两个数是不参与比较的。</p>
</li>
<li><p>依次类推，每一趟比较次数减少依次</p>
</li>
</ul>
<p>举例：</p>
<p>　　　　(1)要排序数组:[10,1,35,61,89,36,55]<br>　　　　(2)第一趟排序：</p>
<p>　　　　　　第一次排序：10和1比较，10大于1，交换位置 　　 　  [1,10,35,61,89,36,55]</p>
<p>　　　　　　第二次排序：10和35比较，10小于35，不交换位置　　[1,10,35,61,89,36,55]</p>
<p>　　　　　　第三次排序：35和61比较，35小于61，不交换位置　　[1,10,35,61,89,36,55]</p>
<p>　　　　　　第四次排序：61和89比较，61小于89，不交换位置　　[1,10,35,61,89,36,55]</p>
<p>　　　　　　第五次排序：10和1比较，10大于1，交换位置 　　 　  [1,10,35,61,89,36,55]</p>
<p>　　　　　　第六次排序：89和55比较，89大于55，交换位置　　　[1,10,35,61,36,55,89]</p>
<p>　　　　　　第一趟总共进行了六次比较，排序结果：[1,10,35,61,36,55,89]</p>
<p>　　　　(3)第二趟排序：</p>
<p>　　　　　　第一次排序：1和10比较，1小于10，不交换位置　　[1,10,35,61,36,55,89]</p>
<p>　　　　　　第二次排序：10和35比较，10小于35，不交换位置    [1,10,35,61,36,55,89]</p>
<p>　　　　　　第三次排序：35和61比较，35小于61，不交换位置     [1,10,35,61,36,55,89]</p>
<p>　　　　　　第四次排序：61和36比较，61大于36，交换位置　　　[1,10,35,36,61,55,89]</p>
<p>　　　　　　第五次排序：61和55比较，61大于55，交换位置　　　[1,10,35,36,55,61,89]</p>
<p>　　　　　　第二趟总共进行了5次比较，排序结果：[1,10,35,36,55,61,89]</p>
<p>　　　　(4)第三趟排序：</p>
<p>　　　　　　第一次排序：1和10比较，1小于10，不交换位置　　[1,10,35,36,55,61,89]</p>
<p>　　　　　　第二次排序：10和35比较，10小于35，不交换位置    [1,10,35,36,55,61,89]</p>
<p>　　　　　　第三次排序：35和36比较，35小于36，不交换位置     [1,10,35,36,55,61,89]</p>
<p>　　　　　　第四次排序：36和61比较，36小于61，不交换位置　　　1,10,35,36,55,61,89</p>
<p>　　　　　　第三趟总共进行了4次比较，排序结果：1,10,35,36,55,61,89</p>
<p>　　　　　　到目前位置已经为有序的情形了。　　　　</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span>    <span class="comment">//下面是函数sort的程序 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,temp;    <span class="comment">//定义三个整型变量 </span></span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;n<span class="number">-1</span>;j++)    <span class="comment">//用一个嵌套循环来遍历一遍每一对相邻元素 （所以冒泡函数慢嘛，时间复杂度高）  </span></span><br><span class="line">    &#123;                           </span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>-j;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;a[i+<span class="number">1</span>])  <span class="comment">//从大到小排就把左边的&quot;&gt;&quot;改为&quot;&lt;&quot;</span></span><br><span class="line">            &#123;</span><br><span class="line">                temp=a[i];      <span class="comment">//a[i]与a[i+1](即a[i]后面那个) 交换</span></span><br><span class="line">                a[i]=a[i+<span class="number">1</span>];    <span class="comment">//基本的交换原理&quot;c=a;a=b;b=c&quot; </span></span><br><span class="line">                a[i+<span class="number">1</span>]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.算法分析：</p>
<p>　　　　(1)由此可见：N个数字要排序完成，总共进行N-1趟排序，每i趟的排序次数为(N-i)次，所以可以用双重循环语句，外层控制循环多少趟，内层控制每一趟的循环次数</p>
<p>　　　　(2)冒泡排序的优点：每进行一趟排序，就会少比较一次，因为每进行一趟排序都会找出一个较大值。如上例：第一趟比较之后，排在最后的一个数一定是最大的一个数，第二趟排序的时候，只需要比较除了最后一个数以外的其他的数，同样也能找出一个最大的数排在参与第二趟比较的数后面，第三趟比较的时候，只需要比较除了最后两个数以外的其他的数，以此类推……也就是说，没进行一趟比较，每一趟少比较一次，一定程度上减少了算法的量。<br>　　　　<br>　　　　(3)时间复杂度</p>
<p>　　　　1.如果我们的数据正序，只需要走一趟即可完成排序。所需的比较次数C和记录移动次数M均达到最小值，即：Cmin=n-1;Mmin=0;所以，冒泡排序最好的时间复杂度为O(n)。</p>
<p>　　　　2.如果很不幸我们的数据是反序的，则需要进行n-1趟排序。每趟排序要进行n-i次比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：</p>
<p>　　　　　　综上所述：冒泡排序总的平均时间复杂度为：O(n2) ,时间复杂度和数据状况无关。</p>
]]></content>
      <tags>
        <tag>c++</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>素数，他，他又来了</title>
    <url>/2019/11/10/%E7%B4%A0%E6%95%B0%EF%BC%8C%E4%BB%96%EF%BC%8C%E4%BB%96%E5%8F%88%E6%9D%A5%E4%BA%86/</url>
    <content><![CDATA[<p>是他，是他，就是他，我们的…咳咳，走错片场了。一大堆素数朝你涌来，感谢埃拉托斯特尼，感谢欧拉(其实一点也不╮(╯▽╰)╭)</p>
<span id="more"></span>

<p>上次实际上是对单个数进行判断是否为素数，但是如果我们有一大堆素数，还用上次的方法的话，那么，，，一定很有趣。好吧我就直接说了，一大堆数进行判断，一个一个的进行循环无疑是很浪费时间的，那么我们就可以构建一个素数表，只需要判断一堆数是否在素数表里就可以了。</p>
<p>有请第一位嘉宾——埃拉托斯特尼筛法(简称埃氏筛法)</p>
<h3 id="埃氏筛法"><a href="#埃氏筛法" class="headerlink" title="埃氏筛法"></a>埃氏筛法</h3><p>首先，我们将2到n范围内的所有整数写下来。其中最小的数字2是素数。将表中所有2的倍数都划去。表中剩余的最小数字是3，它不能被更小的数整除，所以是素数。再将表中所有3的倍数都划去。依此类推，如果表中剩余的最小数字是m时，m就是素数。然后将表中所有m的倍数都化去。像这样反复操作，就能依次枚举n以内的素数。</p>
<p>话不多说，上代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> u[MAXN];			<span class="comment">//定义一个筛子</span></span><br><span class="line"><span class="keyword">int</span> su[MAXN], num = <span class="number">0</span>;	<span class="comment">//定义一个素数表及表的长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;		<span class="comment">//埃氏筛法函数</span></span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; MAXN; i++)		<span class="comment">//进行数组初始化</span></span><br><span class="line">		u[i] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; MAXN; i++)			<span class="comment">//从2到MAXN进行循环</span></span><br><span class="line">		<span class="keyword">if</span> (u[i]) &#123;						<span class="comment">//一旦u[i]是素数，那么筛去它小于MAXN的所有倍数</span></span><br><span class="line">			<span class="keyword">for</span> (j = <span class="number">2</span>; i * j &lt; MAXN; j++)</span><br><span class="line">				u[i * j] = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; MAXN; i++)			<span class="comment">//将筛出的素数填入素数表中</span></span><br><span class="line">		<span class="keyword">if</span> (u[i])</span><br><span class="line">			su[++num] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面埃氏筛法中，大家有没有发现一个问题</p>
<p>最小的素数是2，那么2的整数倍都不是素数，删去4,6,8…余下的数里，最小的素数是3，删去6,9,12…最终未被删去的数就是素数。但，这样在效率上有一个问题：一个数会被删去多次。例如42会被2 3 7都删去一遍，其时间复杂度为O(NlogNlogN)，，，所以，，，</p>
<h3 id="有请欧拉上场"><a href="#有请欧拉上场" class="headerlink" title="有请欧拉上场"></a>有请欧拉上场</h3><p>对每个合数a×b，它会被每个质因数都筛去一遍，但我们只要用最小的质因数筛去就好了为此，我们需要记录下所产生的全部素数，上代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> u[MAXN];        <span class="comment">//筛子</span></span><br><span class="line"><span class="keyword">int</span> su[MAXN],num=<span class="number">0</span>;       <span class="comment">//创建素数表及表长</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eulerSieve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(u,<span class="literal">true</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(u));       <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;=MAXN; i++)&#123;         <span class="comment">//顺序分析区间表中的每个数</span></span><br><span class="line">        <span class="keyword">if</span>(u[i])</span><br><span class="line">            su[++num]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=num; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i*su[j]&gt;MAXN)        <span class="comment">//如果i与当前素数的乘积大于MAXN，则跳过</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            u[i*su[j]]=<span class="literal">false</span>;       <span class="comment">//素数的倍数必为非素数，筛去</span></span><br><span class="line">            <span class="keyword">if</span>(i%su[j]==<span class="number">0</span>)          <span class="comment">//如果su[j]是i的最小素数，则进行下一个i的判断</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心就是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(i%su[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>如果i能整除su[k]，说明su[k]是i的因子，所以su[k]也是i的任意倍数的因子。所以su[k]也是i×su[x] (x&gt;k)的因子。考虑到primelist单增，对i×su[x]，su[k]就是它的比su[x]更小的因子。故不用考虑其后的质因子了（i×su[x]会被su[k]作为因子在i更大时被筛掉）</p>
]]></content>
      <tags>
        <tag>c++</tag>
        <tag>素数</tag>
      </tags>
  </entry>
  <entry>
    <title>配置Clion开发STM32[优雅的开发]</title>
    <url>/2021/05/24/%E9%85%8D%E7%BD%AEClion%E5%BC%80%E5%8F%91STM32-%E4%BC%98%E9%9B%85%E7%9A%84%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p>快来试试用Clion替换掉古董的Keil的开发环境，康康优雅の开发</p>
<span id="more"></span>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>尽管对于STM32的开发而言，Keil已经是一个很好的工具了，作为一个老牌的嵌入式开发用IDE，功能也很完善，升级到5.XX版本之后界面看着也挺现代。但是，作为一个属于上一个时代的开发环境，写代码时会感觉到它的自动补全、智能提示等等功能非常弱，特别是在CubeMX工具大大改善了初始化配置的体验以后，这种不足就显得更加突出了。</p>
<p>  而Keil的缺点正是CLion的重要优点，CLion由JetBrains公司开发，是一个广受赞誉的IDE，自动补全、智能提示能力一流，活动模板等特性可以大大提升开发效率。</p>
<p>  当然，早期CLion是不能用于单片机开发的，不过，用户要求添加相关功能的呼声一直很高，也一直有人通过各种魔改来在CLion下进行单片机开发工作。终于，在2019.1版本中，CLion添加了对于CubeMX的支持（2020.1版本则更加完善），然后，辅以几个其他的工具，可以在CLion下完成STM开发中的全部工作。而且，相关配置可以在任意主流桌面平台上搭建。</p>
<p>  So，赶紧折腾起来，换上属于新时代的开发工具，进行优雅の开发</p>
<h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h1><h2 id="必备软件"><a href="#必备软件" class="headerlink" title="必备软件"></a>必备软件</h2><ul>
<li>CLion ——-主角</li>
<li>STM32CubeMX ST官方力推的自动化配置和代码生成工具</li>
<li>OpenOCD ——调试工具</li>
<li>gcc-arm-none-eabi ——–交叉编译工具链</li>
<li>MinGW ——–额，你可以认为这是一个大礼包</li>
<li>可能还包括你所使用的调试器的驱动，之前安装过就行</li>
</ul>
<h2 id="MinGW"><a href="#MinGW" class="headerlink" title="MinGW"></a>MinGW</h2><p>首先，从<a href="http://www.mingw-w64.org/doku.php">这里</a>下载MinGW（其实是MinGW-w64，兼容MinGW且更强大），然后解压到某个目录（以后不要改动）</p>
<p>然后，添加环境变量，具体到bin目录，比如<code>C:ToolChainming\w64\bin</code>这样，根据自己安装目录确定</p>
<p>打开命令行，输入<code>gcc -v</code>测试一下，没有提示不是可用的指令而是返回了一大堆信息就说明一切正常</p>
<blockquote>
<p>补充：安装过Dev-cpp之类的自带MinGW的软件的话这个安装环节可以省略</p>
</blockquote>
<h2 id="OpenOCD"><a href="#OpenOCD" class="headerlink" title="OpenOCD"></a>OpenOCD</h2><p>首先，在<a href="https://gnutoolchains.com/arm-eabi/openocd/">这里</a>下载并解压到某个目录（之后不要改动）</p>
<p>然后，添加环境变量，还是具体到bin目录</p>
<p>最后同样要测试一下，命令行输入<code>openocd -v</code>，回车，返回版本信息说明状态正常</p>
<h2 id="gcc-arm-none-eabi"><a href="#gcc-arm-none-eabi" class="headerlink" title="gcc-arm-none-eabi"></a>gcc-arm-none-eabi</h2><p>首先，在<a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads">这里</a>下载并解压到某个目录（之后不要改动）</p>
<p>然后，添加环境变量</p>
<p>开命令行用<code>arm-none-eabi-gcc -v</code>测试一下，返回版本信息说明正常</p>
<h2 id="STM32CubeMX"><a href="#STM32CubeMX" class="headerlink" title="STM32CubeMX"></a>STM32CubeMX</h2><p>CubeMX是基于Java开发的软件，所以需要先安装Java运行环境（JRE、Java Runtime Environment），根据自己系统和CPU选择版本，如intel+win10 64位应选择“jre-8u251-windows-x64.exe”</p>
<p>安装JRE以后，命令行下用<code>java -version</code>进行测试，返回版本信息则正常。</p>
<p>然后，我们来安装STM32CubeMX，从<a href="https://www.st.com/zh/development-tools/stm32cubemx.html">这里</a>下载即可，安装过程没什么特别的。</p>
<blockquote>
<p>补充：JRE必须是64位的，否则CubeMX会不正常</p>
</blockquote>
<h1 id="哎，不写了，就是玩，就玩"><a href="#哎，不写了，就是玩，就玩" class="headerlink" title="哎，不写了，就是玩，就玩"></a>哎，不写了，就是玩，就玩</h1>]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>LintCode巴什博弈</title>
    <url>/2021/05/28/LintCode%E5%B7%B4%E4%BB%80%E5%8D%9A%E5%BC%88/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.lintcode.com/problem/1300">题目</a>描述</h2><p>你正在和朋友玩一个游戏：桌子上有一堆石头，每一次你们都会从中拿出1到3个石头。拿走最后一个石头的人赢得游戏。游戏开始时，你是先手。</p>
<span id="more"></span>

<p>假设两个人都绝对理性，都会做出最优决策。给定石头的数量，判断你是否会赢得比赛。</p>
<p>举例：有四个石头，那么你永远不会赢得游戏。不管拿几个，最后一个石头一定会被你的朋友拿走</p>
<h2 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h2><h3 id="样例一："><a href="#样例一：" class="headerlink" title="样例一："></a>样例一：</h3><blockquote>
<p>输入：n = 4 </p>
<p>输出：False</p>
<p>解析：先手取走1,2或者3，对方都会取走最后一个</p>
</blockquote>
<h3 id="样例二："><a href="#样例二：" class="headerlink" title="样例二："></a>样例二：</h3><blockquote>
<p>输入：n = 5 </p>
<p>输出：True</p>
<p>解析：先手拿1个，必胜</p>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这道题的关键是寻找“必胜态”。</p>
<p>根据题设条件：</p>
<p>当n∈[1,3]时，先手必胜</p>
<p>当n == 4时，无论先手第一轮如何选取，下一轮都会转化为n∈[1,3]的情形，此时先手必负</p>
<p>当n∈[5,7]时，先手必胜，先手分别通过取走[1,3]颗石头，可将状态转化为n == 4时的情形，此时后手必负</p>
<p>当n == 8时，无论先手第一轮如何选取，下一轮都会转化为n∈[5,7]的情形，此时先手必负</p>
<p>……</p>
<p>以此类推，可以得出结论：</p>
<p>当n % 4 != 0时，先手必胜；否则先手必负</p>
<blockquote>
<p>这就有点动态规划的思想了，无论刚开始是多少，都可以一步一步转化为一个最小问题规模</p>
</blockquote>
<p>在你的对手最后一次拿的时候，石头要是4个， 这时无论他拿1、2、3个，你都有石头拿。要保证这一点，你需要保证每次你拿完时石头的个数是4的倍数。那就意味着一开始石头的数目不是4的倍数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param n: an integer</span></span><br><span class="line"><span class="comment">     * @return: whether you can win the game given the number of stones in the heap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canWinBash</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Write your code here</span></span><br><span class="line">        <span class="keyword">return</span> n%<span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>LintCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LintCode编辑距离</title>
    <url>/2021/05/29/LintCode%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.lintcode.com/problem/119">题目</a>描述</h2><p>给出两个单词<code>word1</code>和<code>word2</code>，计算出将<code>word1</code> 转换为<code>word2</code>的最少操作次数。 你可进行三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<blockquote>
<p>len(word1), len(word2) &lt;= 500</p>
</blockquote>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例一："><a href="#样例一：" class="headerlink" title="样例一："></a>样例一：</h3><p>输入：</p>
<blockquote>
<p>word1 = “horse”<br>word2 = “ros”</p>
</blockquote>
<p>输出：</p>
<blockquote>
<p>3</p>
</blockquote>
<p>解释：</p>
<blockquote>
<p>horse -&gt; rorse (替换 ‘h’ 为 ‘r’)<br> rorse -&gt; rose (删除 ‘r’)<br>rose -&gt; ros (删除 ‘e’)</p>
</blockquote>
<h3 id="样例二："><a href="#样例二：" class="headerlink" title="样例二："></a>样例二：</h3><p>输入：</p>
<blockquote>
<p>word1 = “intention”<br>word2 = “execution”</p>
</blockquote>
<p>输出：</p>
<blockquote>
<p>5</p>
</blockquote>
<p>解释：</p>
<blockquote>
<p>intention -&gt; inention (删除 ‘t’)<br>inention -&gt; enention (替换 ‘i’ 为 ‘e’)<br>enention -&gt; exention (替换 ‘n’ 为 ‘x’)<br>exention -&gt; exection (替换 ‘n’ 为 ‘c’)<br>exection -&gt; execution (插入 ‘u’)</p>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这道题乍一看，作为老暴力选手，那么就遍历遍历，疯狂遍历</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param word1: A string</span></span><br><span class="line"><span class="comment">     * @param word2: A string</span></span><br><span class="line"><span class="comment">     * @return: The minimum number of steps.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(string &amp;word1, string &amp;word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.<span class="built_in">size</span>(), n = word2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="built_in">max</span>(m, n)));</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LintCode</category>
      </categories>
      <tags>
        <tag>LintCode</tag>
      </tags>
  </entry>
  <entry>
    <title>动规的初级理解</title>
    <url>/2019/11/10/%E5%8A%A8%E8%A7%84%E7%9A%84%E5%88%9D%E7%BA%A7%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>动态规划是学习算法过程中的一道绊脚石，那么今天就让我们，走进动态规划的世界里，不要恐惧它，其实挺有意思的</p>
<span id="more"></span>

<h4 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h4><p>动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。</p>
<h4 id="二、基本思想与策略"><a href="#二、基本思想与策略" class="headerlink" title="二、基本思想与策略"></a>二、基本思想与策略</h4><p>基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。</p>
<p>由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。</p>
<p>与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。</p>
<h4 id="三、适用的情况"><a href="#三、适用的情况" class="headerlink" title="三、适用的情况"></a>三、适用的情况</h4><p>能采用动态规划求解的问题的一般要具有3个性质：</p>
<p>(1) 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。</p>
<p>(2) 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</p>
<p>（3）有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）</p>
<hr>
<hr>
<h4 id="四、求解的基本步骤"><a href="#四、求解的基本步骤" class="headerlink" title="四、求解的基本步骤"></a>四、求解的基本步骤</h4><p>动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。</p>
<p>初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态</p>
<p>图1 动态规划决策过程示意图</p>
<p>(1)划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。</p>
<p>(2)确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。</p>
<p>(3)确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。</p>
<p>(4)寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。</p>
<p>一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。</p>
<p>实际应用中可以按以下几个简化的步骤进行设计：</p>
<p>（1）分析最优解的性质，并刻画其结构特征。</p>
<p>（2）递归的定义最优解。</p>
<p>（3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值</p>
<p>（4）根据计算最优值时得到的信息，构造问题的最优解</p>
<h4 id="五、算法实现的说明"><a href="#五、算法实现的说明" class="headerlink" title="五、算法实现的说明"></a>五、算法实现的说明</h4><p>动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。</p>
<p>使用动态规划求解问题，最重要的就是确定动态规划三要素：</p>
<p>（1）问题的阶段 （2）每个阶段的状态</p>
<p>（3）从前一个阶段转化到后一个阶段之间的递推关系。</p>
<p>递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。</p>
<p>确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">f</span>(n,m)=max&#123;<span class="built_in">f</span>(n<span class="number">-1</span>,m), <span class="built_in">f</span>(n<span class="number">-1</span>,m-w[n])+<span class="built_in">P</span>(n,m)&#125;</span><br></pre></td></tr></table></figure>
<h3 id="六、动态规划算法基本框架"><a href="#六、动态规划算法基本框架" class="headerlink" title="六、动态规划算法基本框架"></a>六、动态规划算法基本框架</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=m; j=j+<span class="number">1</span>) <span class="comment">// 第一个阶段</span></span><br><span class="line">   xn[j] = 初始值;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span>(i=n<span class="number">-1</span>; i&gt;=<span class="number">1</span>; i=i<span class="number">-1</span>)<span class="comment">// 其他n-1个阶段</span></span><br><span class="line">   <span class="keyword">for</span>(j=<span class="number">1</span>; j&gt;=<span class="built_in">f</span>(i); j=j+<span class="number">1</span>)<span class="comment">//f(i)与i有关的表达式</span></span><br><span class="line">     xi[j]=j=max（或min）&#123;<span class="built_in">g</span>(xi<span class="number">-1</span>[j1:j2]), ......, <span class="built_in">g</span>(xi<span class="number">-1</span>[jk:jk+<span class="number">1</span>])&#125;;</span><br><span class="line"> </span><br><span class="line">t = <span class="built_in">g</span>(x1[j1:j2]); <span class="comment">// 由子问题的最优解求解整个问题的最优解的方案</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(x1[j1]);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;=n<span class="number">-1</span>; i=i+<span class="number">1</span>）</span><br><span class="line">&#123;  </span><br><span class="line">     t = t-xi<span class="number">-1</span>[ji];</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">for</span>(j=<span class="number">1</span>; j&gt;=<span class="built_in">f</span>(i); j=j+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>(t=xi[ji])</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Java上转型与下转型</title>
    <url>/2021/06/06/Java%E4%B8%8A%E8%BD%AC%E5%9E%8B%E4%B8%8E%E4%B8%8B%E8%BD%AC%E5%9E%8B/</url>
    <content><![CDATA[<p>Java 语言允许某个类型的引用变量引用子类的实例，而且可以对这个引用变量进行类型转换。Java 中引用类型之间的类型转换（<code>前提是两个类是父子关系</code>）主要有两种，分别是<code>向上转型</code>（<code>upcasting</code>）和<code>向下转型</code>（<code>downcasting</code>）</p>
<span id="more"></span>

<h2 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h2><p><strong>父类引用指向子类对象为向上转型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fatherClass obj = <span class="keyword">new</span> sonClass();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中，fatherClass 是父类名称或接口名称，obj 是创建的对象，sonClass 是子类名称</p>
</blockquote>
<p>向上转型就是把子类对象直接赋给父类引用，不用强制转换。使用向上转型<code>可以调用父类类型中的所有成员，不能调用子类类型中特有成员</code>，最终运行效果看子类的具体实现</p>
<h2 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h2><p>与向上转型相反，<strong>子类对象指向父类引用为向下转型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sonClass obj = (sonClass)fatherClass;   <span class="comment">//需要强制转换</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中，fatherClass 是父类名称，obj 是创建的对象，sonClass 是子类名称</p>
</blockquote>
<p>向下转型可以调用子类类型中所有的成员，不过需要注意的是如果父类引用对象指向的是子类对象，那么在向下转型的过程中是安全的，也就是编译是不会出错误。但是如果父类引用对象是父类本身，那么在向下转型的过程中是不安全的，编译不会出错，但是运行时会出现Java 强制类型转换异常，一般使用 instanceof 运算符来避免出此类错误</p>
<p>比如cat→animal，那么你就应该由对象animal→cat，假如还有一个animal的子类叫dog，你如果由animal→dog那么就是错误转型，就像我给了你1美金，你给回我的是1RMB那么就不是还原了</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AllAnimal a=<span class="keyword">new</span> Fish();</span><br><span class="line">a.speak();	 </span><br><span class="line"><span class="comment">//强制向下转型</span></span><br><span class="line">Fish a1=(Fish)a;</span><br><span class="line">a1.canDo();</span><br></pre></td></tr></table></figure>

<p><strong>所以，向下转型可以实现父类引用可以使用子类的新增方法</strong></p>
<hr>
<blockquote>
<p>注：<strong>无论向上向下转型，编译看左边，运行看右边</strong><br>意思就是：编译时候左边的对象有没有该方法（不严谨），运行时候看new的对象是谁，就调用谁的方法</p>
</blockquote>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Math类与Random类常用方法</title>
    <url>/2020/02/29/Math%E7%B1%BB%E4%B8%8ERandom%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><em>Java提供的常用类中，Math类为常用的数学计算方法，Random类为常用的随机生成方法</em></p>
<span id="more"></span>

<h2 id="Math类方法"><a href="#Math类方法" class="headerlink" title="Math类方法"></a>Math类方法</h2><p>abs 绝对值</p>
<p>acos,asin,atan,cos,sin,tan 三角函数</p>
<p>sqrt 平方根</p>
<p>pow(double a, double b) a的b次幂</p>
<p>max(double a, double b) 取大值</p>
<p>min(double a, double b) 取小值</p>
<p>ceil(double a) 大于a的最小整数</p>
<p>floor(double a) 小于a的最大整数</p>
<p>random() 返回 0.0 到 1.0 的随机数</p>
<p>long round(double a) double型的数据a转换为long型(四舍五入)</p>
<p>toDegrees(double angrad) 弧度-&gt;角度</p>
<p>toRadians(double angdeg) 角度-&gt;弧度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMath</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//取整相关操作</span></span><br><span class="line">        System.out.println(Math.ceil(<span class="number">3.2</span>));</span><br><span class="line">        System.out.println(Math.floor(<span class="number">3.2</span>));</span><br><span class="line">        System.out.println(Math.round(<span class="number">3.2</span>));</span><br><span class="line">        System.out.println(Math.round(<span class="number">3.8</span>));</span><br><span class="line">        <span class="comment">//绝对值、开方、a的b次幂等操作</span></span><br><span class="line">        System.out.println(Math.abs(-<span class="number">45</span>));</span><br><span class="line">        System.out.println(Math.sqrt(<span class="number">64</span>));</span><br><span class="line">        System.out.println(Math.pow(<span class="number">5</span>, <span class="number">2</span>));</span><br><span class="line">        System.out.println(Math.pow(<span class="number">2</span>, <span class="number">5</span>));</span><br><span class="line">        <span class="comment">//Math类中常用的常量</span></span><br><span class="line">        System.out.println(Math.PI);</span><br><span class="line">        System.out.println(Math.E);</span><br><span class="line">        <span class="comment">//随机数</span></span><br><span class="line">        System.out.println(Math.random());<span class="comment">// [0,1)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Random方法"><a href="#Random方法" class="headerlink" title="Random方法"></a>Random方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRandom</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">//随机生成[0,1)之间的double类型的数据</span></span><br><span class="line">        System.out.println(rand.nextDouble());</span><br><span class="line">        <span class="comment">//随机生成int类型允许范围之内的整型数据</span></span><br><span class="line">        System.out.println(rand.nextInt());</span><br><span class="line">        <span class="comment">//随机生成[0,1)之间的float类型的数据</span></span><br><span class="line">        System.out.println(rand.nextFloat());</span><br><span class="line">        <span class="comment">//随机生成false或者true</span></span><br><span class="line">        System.out.println(rand.nextBoolean());</span><br><span class="line">        <span class="comment">//随机生成[0,10)之间的int类型的数据</span></span><br><span class="line">        System.out.print(rand.nextInt(<span class="number">10</span>));</span><br><span class="line">        <span class="comment">//随机生成[20,30)之间的int类型的数据</span></span><br><span class="line">        System.out.print(<span class="number">20</span> + rand.nextInt(<span class="number">10</span>));</span><br><span class="line">        <span class="comment">//随机生成[20,30)之间的int类型的数据（此种方法计算较为复杂）</span></span><br><span class="line">        System.out.print(<span class="number">20</span> + (<span class="keyword">int</span>) (rand.nextDouble() * <span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++之文件操作</title>
    <url>/2019/12/26/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>C语言中对于文件的操作是通过指针来完成的，要注意，文件指针不是指向一段内存空间的，它实际上指向的是描述这个文件相关信息的一个文件结构体</p>
<span id="more"></span>
<h3 id="声明文件变量"><a href="#声明文件变量" class="headerlink" title="声明文件变量"></a>声明文件变量</h3><pre><code>FILE *file;</code></pre><p>声明了一个名为file的文件指针<br>定义好一个文件指针变量后就需要初始化这个文件指针变量或者说是打开文件</p>
<h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>打开文件通过fopen函数完成，比如：</p>
<pre><code>file = fopen(&quot;1.text&quot;,&quot;r+&quot;);</code></pre><p>fopen函数中有两个传入参数，第一个参数是文件的名称，比如“1.txt”，要注意，如果这个文件没有和你的程序处于同一目录下，需要写入全部路径，例如   “c:\1\1.txt”；第二个参数为打开文件的方式，他可以从下面几个方式中打开 </p>
<p>正常返回：<code>被打开文件的文件指针</code><br>异常返回：<code>NULL</code></p>
<center> 文件的打开方式 </center>

<table>
<thead>
<tr>
<th>打开方式</th>
<th>含义</th>
<th>指定文件不存在时</th>
<th>指定文件存在时</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>只读方式打开文本文件</td>
<td>出错</td>
<td>正常打开</td>
</tr>
<tr>
<td>w</td>
<td>只写方式打开文本文件</td>
<td>建立新文件</td>
<td>文件原有内容丢失</td>
</tr>
<tr>
<td>a</td>
<td>追加方式打开文本文件</td>
<td>建立新文件</td>
<td>在原有内容末尾追加</td>
</tr>
<tr>
<td>r+</td>
<td>读/写方式打开文本文件</td>
<td>出错</td>
<td>正常打开</td>
</tr>
<tr>
<td>w+</td>
<td>读/写方式创建新的文本文件</td>
<td>建立新文件</td>
<td>文件原有内容丢失</td>
</tr>
<tr>
<td>a+</td>
<td>读/追加方式建立新的文本文件</td>
<td>建立新文件</td>
<td>在原有内容末尾追加</td>
</tr>
<tr>
<td>rb</td>
<td>只读方式打开二进制文件</td>
<td>出错</td>
<td>正常打开</td>
</tr>
<tr>
<td>wb</td>
<td>只写方式打开二进制文件</td>
<td>建立新文件</td>
<td>文件原有内容丢失</td>
</tr>
<tr>
<td>ab</td>
<td>追加方式打开二进制文件</td>
<td>建立新文件</td>
<td>在原有内容末尾添加</td>
</tr>
<tr>
<td>rb+</td>
<td>读/写方式打开二进制文件</td>
<td>出错</td>
<td>正常打开</td>
</tr>
<tr>
<td>wb+</td>
<td>读/写方式创建新的二进制文件</td>
<td>建立新文件</td>
<td>文件原有内容丢失</td>
</tr>
<tr>
<td>ab+</td>
<td>读/追加方式创建新的二进制文件</td>
<td>建立新文件</td>
<td>在原有内容末尾追加</td>
</tr>
</tbody></table>
<h3 id="文件关闭"><a href="#文件关闭" class="headerlink" title="文件关闭"></a>文件关闭</h3><pre><code>fclose(FILE *fp);</code></pre><p>关闭已经打开的一个名为fp的FILE文件指针</p>
<p>正常返回：<code>0</code><br>异常返回：<code>EOF</code></p>
<h3 id="文件的顺序读写函数"><a href="#文件的顺序读写函数" class="headerlink" title="文件的顺序读写函数"></a>文件的顺序读写函数</h3><table>
<thead>
<tr>
<th>功能</th>
<th>函数名</th>
<th>适用于</th>
</tr>
</thead>
<tbody><tr>
<td>字符输入函数</td>
<td>fgetc</td>
<td>所有输入流</td>
</tr>
<tr>
<td>字符输出函数</td>
<td>fputc</td>
<td>所有输出流</td>
</tr>
<tr>
<td>文本行输出函数</td>
<td>fputs</td>
<td>所有输出流</td>
</tr>
<tr>
<td>格式化输入函数</td>
<td>fscanf</td>
<td>所有输入流</td>
</tr>
<tr>
<td>格式化输出函数</td>
<td>fprintf</td>
<td>所有输出流</td>
</tr>
<tr>
<td>二进制输入</td>
<td>fread</td>
<td>文件</td>
</tr>
<tr>
<td>二进制输出</td>
<td>fwrite</td>
<td>文件</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/2019/12/20/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p><code>十个二分九个错</code>,二分虽然它的思想比较容易理解，但写出一个没有bug的二分，着实有些难受</p>
<span id="more"></span>
<h3 id="什么是二分"><a href="#什么是二分" class="headerlink" title="什么是二分"></a>什么是二分</h3><p>二分查找针对的是一个有序的数据集合，每次通过跟区间中间的元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间缩小为0</p>
<h4 id="二分查找的思路如下"><a href="#二分查找的思路如下" class="headerlink" title="二分查找的思路如下"></a>二分查找的思路如下</h4><p>（1）首先，从数组的中间元素开始搜索，如果该元素正好是目标元素，则搜索过程结束，否则执行下一步。</p>
<p>（2）如果目标元素大于/小于中间元素，则在数组大于/小于中间元素的那一半区域查找，然后重复步骤上述操作的操作。</p>
<p>（3）如果某一步数组为空，则表示找不到目标元素。</p>
<p>二分法查找的时间复杂度O(logn),且不需要额外的空间</p>
<h4 id="二分图解"><a href="#二分图解" class="headerlink" title="二分图解"></a>二分图解</h4><p><img src="http://www.cppblog.com/images/cppblog_com/guogangj/ds_binarysearch.png" class="lazyload" data-srcset="http://www.cppblog.com/images/cppblog_com/guogangj/ds_binarysearch.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Image 二分查找"></p>
<h3 id="传统二分"><a href="#传统二分" class="headerlink" title="传统二分"></a>传统二分</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (nums[len - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 等于的情况最简单，我们应该放在第 1 个分支进行判断</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                <span class="comment">// 题目要我们返回大于或者等于目标值的第 1 个数的索引</span></span><br><span class="line">                <span class="comment">// 此时 mid 一定不是所求的左边界，</span></span><br><span class="line">                <span class="comment">// 此时左边界更新为 mid + 1</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 既然不会等于，此时 nums[mid] &gt; target</span></span><br><span class="line">                <span class="comment">// mid 也一定不是所求的右边界</span></span><br><span class="line">                <span class="comment">// 此时右边界更新为 mid - 1</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意：一定得返回左边界 left，</span></span><br><span class="line">        <span class="comment">// 理由是对于 [1,3,5,6]，target = 2，返回大于等于 target 的第 1 个数的索引，此时应该返回 1</span></span><br><span class="line">        <span class="comment">// 在上面的 while (left &lt;= right) 退出循环以后，right &lt; left，right = 0 ，left = 1</span></span><br><span class="line">        <span class="comment">// 根据题意应该返回 left，</span></span><br><span class="line">        <span class="comment">// 如果题目要求你返回小于等于 target 的所有数里最大的那个索引值，应该返回 right</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p><strong>取中位数索引的代码有问题</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span> ;</span><br></pre></td></tr></table></figure>
<p>这也不能说不对，但是如果当<code>left</code>和<code>right</code>都非常大的时候，那么<code>left+right</code>就很有可能会超过int类型能表示的最大范围，及整型溢出，这样就会缩小数据的处理范围，可以写成这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span> ;</span><br></pre></td></tr></table></figure>
<p>事实上，<code>int mid = left + (right - left) / 2</code>在<code>right</code>很大、<code>left</code>是负数且很小的时候，<code>right - left</code>也有可能超过int类型能表示的最范围，只不过一般情况下<code>left</code>和<code>right</code>表示的是数组索引值<code>left</code>是非负数，因此<code>right - left</code>溢出的可能性很小<br>所以使用“左边界索引 + 右边界索引”，然后“无符号右移 1 位”是推荐的写法，计算机的处理速度也会更快</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span> ;</span><br></pre></td></tr></table></figure>

<p><strong>返回条件的问题</strong></p>
<p>循环可以进行的条件写成<code>while (left &lt;= right)</code>时，在退出循环的时候，需要考虑返回<code>left</code>还是<code>right</code>，稍不注意，就容易出错<br>或许，我们可以回避这个问题^_^</p>
<h3 id="改良二分"><a href="#改良二分" class="headerlink" title="改良二分"></a>改良二分</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>首先我们把循环条件改为<code>while(left &lt; right)</code>,那么在退出循环的时候，一定有<code>left=right</code>成立，所以我们返回<code>left</code>或<code>right</code>都可以了<br>或许你可能会有一个疑问，退出循环的时候还有一个值没有判断啊(退出循环时left或right的索引值)<br>木有关系滴，那就退出循环来看，经过分析，甚至都不用看就能确定他是目标值<br>更深层次的思想是“夹逼法”或者可以说是“排除法”</p>
<p>其实，二分排除的过程中就是将区间不断“夹逼”的过程，在这过程中，不断排除一半的区间，从而加快查找速度</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>中位数先写 int mid = (left + right) &gt;&gt;&gt; 1 ; 根据循环里分支的编写情况，再做调整<br>理解这一点，首先要知道：当数组的元素个数是偶数的时候，中位数有左中位数和右中位数之分。</p>
<p>当数组的元素个数是偶数的时候：<br>使用 int mid = left + (right - left) / 2 ; 得到左中位数的索引；</p>
<p>使用 int mid = left + (right - left + 1) / 2 ; 得到右中位数的索引。</p>
<p>当数组的元素个数是奇数的时候，以上二者都能选到最中间的那个中位数。<br>其次，</p>
<p>int mid = left + (right - left) / 2 ; 等价于 int mid = (left + right) &gt;&gt;&gt; 1；</p>
<p>int mid = left + (right - left + 1) / 2 ; 等价于 int mid = (left + right + 1) &gt;&gt;&gt; 1 。</p>
<p>记忆方法：</p>
<p>(right - left) 不加 1 选左中位数，加 1 选右中位数。</p>
<p>那么，什么时候使用左中位数，什么时候使用右中位数呢？选中位数的依据是为了避免死循环，得根据分支的逻辑来选择中位数，而分支逻辑的编写也有技巧，下面具体说。</p>
<p>先写逻辑上容易想到的分支逻辑，这个分支逻辑通常是排除中位数的逻辑；</p>
<pre><code>如果分支的逻辑，在选择左边界的时候，不能排除中位数，那么中位数就选“右中位数”，只有这样区间才会收缩，否则进入死循环；
同理，如果分支的逻辑，在选择右边界的时候，不能排除中位数，那么中位数就选“左中位数”，只有这样区间才会收缩，否则进入死循环。</code></pre><p>举个栗子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="keyword">while</span> left &lt; right:</span><br><span class="line">      <span class="comment">//先写左中位数，看看你的分支会不会让你代码出现死循环，从而调整</span></span><br><span class="line">    mid = left + (right - left) <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">if</span> (check(mid)):</span><br><span class="line">        <span class="comment">//选择右边界的时候，可以排除中位数</span></span><br><span class="line">        right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">//选择左边界的时候，不能排除中位数</span></span><br><span class="line">        left = mid</span><br></pre></td></tr></table></figure>
<p>在区间中的元素只剩下2个时候，例如：left = 3，right = 4。<br>此时左中位数就是左边界，如果你的逻辑执行到 left = mid 这个分支，且你选择的中位数是左中位数，此时左边界就不会得到更新，区间就不会再收缩（理解这句话是关键），从而进入死循环；<br>为了避免出现死循环，你需要选择中位数是右中位数，当逻辑执行到 left = mid 这个分支的时候，因为你选择了右中位数，让逻辑可以转而执行到 right = mid - 1 让区间收缩，最终成为1个数，退出while循环。</p>
<p><em>如果出现了死循环，那么就打印输出左右边界、中位数的值和目标值、分支逻辑等必要的信息，进而进行分析</em></p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title>内部类</title>
    <url>/2020/02/24/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="内部类的概念"><a href="#内部类的概念" class="headerlink" title="内部类的概念"></a>内部类的概念</h2><p>一般情况，我们把类定义成独立的单元。有些情况下，我们把一个类放在另一个类的内部定义，称为内部类(innerclasses)。</p>
<span id="more"></span>
<p>内部类可以使用public、default、protected 、private以及static修饰。而外部顶级类(我们以前接触的类)只能使用public和default修饰。</p>
<p><strong>注意</strong></p>
<p>内部类只是一个编译时概念，一旦我们编译成功，就会成为完全不同的两个类。编译完成后会出现两个类的字节码文件。所以内部类是相对独立的一种存在，其成员变量/方法名可以和外部类的相同</p>
<h4 id="内部类的作用"><a href="#内部类的作用" class="headerlink" title="内部类的作用"></a>内部类的作用</h4><ol>
<li><p>内部类提供了更好的封装，只能让外部类直接访问，不允许同一个包中的其它类直接访问。</p>
</li>
<li><p>内部类可以直接访问外部类的私有属性，内部类被当成其外部类的成员。但外部类不能访问内部类的内部属性。</p>
</li>
<li><p>接口只是解决了多重继承的部分问题，而内部类使得多重继承的解决方案变得更加完善。</p>
</li>
</ol>
<h4 id="内部类的使用场景"><a href="#内部类的使用场景" class="headerlink" title="内部类的使用场景"></a>内部类的使用场景</h4><ol>
<li>由于内部类提供了更好的封装特性，并且可以很方便的访问外部类的属性。所以，在只为外部类提供服务的情况下可以优先考虑内部类</li>
<li>内部类的使用可以间接的实现多继承，每个内部类都能独立的继承一个类或者实现某些接口，所以无论外部类是否已经继承了某个类或者实现了某些接口，对于内部类没有任何影响</li>
</ol>
<h2 id="内部类的分类"><a href="#内部类的分类" class="headerlink" title="内部类的分类"></a>内部类的分类</h2><p>在Java中内部类主要分为成员内部类(非静态内部类、静态内部类)、匿名内部类、局部内部类。<br>.成员内部类(可以使用private、default、protected、public任意进行修饰。 类文件：外部类$内部类.class)</p>
<h4 id="非静态内部类-外部类里使用非静态内部类和平时使用其他类没什么不同"><a href="#非静态内部类-外部类里使用非静态内部类和平时使用其他类没什么不同" class="headerlink" title="非静态内部类(外部类里使用非静态内部类和平时使用其他类没什么不同)"></a>非静态内部类(外部类里使用非静态内部类和平时使用其他类没什么不同)</h4><p> i. 非静态内部类必须寄存在一个外部类对象里。因此，如果有一个非静态内部类对象那么一定存在对应的外部类对象。非静态内部类对象单独属于外部类的某个对象。</p>
<p>ii. 非静态内部类可以直接访问外部类的成员，但是外部类不能直接访问非静态内部类成员。</p>
<p>iii. 非静态内部类不能有静态方法、静态属性和静态初始化块。</p>
<p>iv. 外部类的静态方法、静态代码块不能访问非静态内部类，包括不能使用非静态内部类定义变量、创建实例。</p>
<p>v. 成员变量访问特点：</p>
<ol>
<li><p>内部类里方法的局部变量：变量名。</p>
</li>
<li><p>内部类属性：this.变量名。</p>
</li>
<li><p>外部类属性：外部类名.this.变量名。</p>
</li>
</ol>
<h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> age = <span class="number">30</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;内部类方法里的局部变量age:&quot;</span> + age);<span class="comment">// 30</span></span><br><span class="line">            System.out.println(<span class="string">&quot;内部类的成员变量age:&quot;</span> + <span class="keyword">this</span>.age);<span class="comment">// 20</span></span><br><span class="line">            System.out.println(<span class="string">&quot;外部类的成员变量age:&quot;</span> + Outer.<span class="keyword">this</span>.age);<span class="comment">// 10</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>内部类访问</strong></p>
<ul>
<li>外部类中访问内部类：<code>new Inner()</code></li>
<li>外部类以外的地方访问非静态内部类： <code>Outer.Inner varname = new Outer().new Inner()。</code></li>
</ul>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><h5 id="使用要点"><a href="#使用要点" class="headerlink" title="使用要点"></a>使用要点</h5><ol>
<li><p>当一个静态内部类对象存在，并不一定存在对应的外部类对象。 因此，静态内部类的实例方法不能直接访问外部类的实例方法。</p>
</li>
<li><p>静态内部类看做外部类的一个静态成员。 因此，外部类的方法中可以通过：“静态内部类.名字”的方式访问静态内部类的静态成员，通过 new 静态内部类()访问静态内部类的实例。</p>
</li>
</ol>
<h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="comment">//相当于外部类的一个静态成员</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStaticInnerClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过 new 外部类名.内部类名() 来创建内部类对象</span></span><br><span class="line">        Outer.Inner inner =<span class="keyword">new</span> Outer.Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>适合那种只需要使用一次的类。比如：键盘监听操作等</p>
<h5 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span>  父类构造器(实参类表) \实现接口 () &#123;</span><br><span class="line">           <span class="comment">//匿名内部类类体！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ul>
<li>匿名内部类没有访问修饰符</li>
<li>匿名内部类没有构造方法</li>
</ul>
<h5 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.addWindowListener(<span class="keyword">new</span> WindowAdapter()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosing</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"><span class="keyword">this</span>.addKeyListener(<span class="keyword">new</span> KeyAdapter()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">keyPressed</span><span class="params">(KeyEvent e)</span> </span>&#123;</span><br><span class="line">            myTank.keyPressed(e);</span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">keyReleased</span><span class="params">(KeyEvent e)</span> </span>&#123;</span><br><span class="line">            myTank.keyReleased(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>还有一种内部类，它是定义在方法内部的，作用域只限于本方法，称为局部内部类。</p>
<p>局部内部类的的使用主要是用来解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，所以就产生了局部内部类。局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法中被使用，出了该方法就会失效。</p>
<p>局部内部类在实际开发中应用很少</p>
<h5 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//作用域仅限于该方法</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Inner().fun();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Test2().show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表之单向链表</title>
    <url>/2019/12/05/%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>链表是物理存储结构上非连续，非顺序的存储结构，但是在逻辑上它是通过链表指针指向而实现的顺序结构</p>
<span id="more"></span>
<p><strong>链表与数组的区别</strong></p>
<p>· 数组是静态分布内存，链表是动态分布内存<br>· 数组在内存中是连续的，链表是不连续的<br>· 数组利用下表定位，查找的时间复杂度是O(1),链表通过遍历定位元素，查找的复杂度是O(n)<br>· 数组的插入和移除都需要移动其它元素，时间复杂度是O(n)，；链表的插入或删除不需要移动其它元素，时间复杂度是O(1)</p>
<p><strong>数组的优点</strong></p>
<p>· 随机访问性比较强<br>· 查找速度快</p>
<p><strong>数组的缺点</strong></p>
<p>· 插入和删除的效率低，需要移动其它元素<br>· 会造成内存的浪费，因为内存是连续的，所以在申请数组的时候就必须规定内存的大小，如果长度不合适就会照成内存的浪费<br>· 内存空间的要求高，创建一个数组，必须要有足够的连续内存空间<br>· 数组的大小是固定的，在创建数组的时候就已经规定好，不能够动态拓展</p>
<p><strong>链表的优点</strong></p>
<p>· 插入和删除的效率高，只需要改变指针的指向就可以进行插入和删除<br>· 内存利用效率高，不会浪费内存，可以使用内存中细小的不连续空间，只有在有需要的时候才去创建空间，大小不固定，拓展很灵活</p>
<p><strong>链表的缺点</strong></p>
<p>· 查找效率低，因为链表是从第一个节点向后遍历查找</p>
<p><strong>图表演示</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20181108094742801.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lobF9qeHk=,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20181108094742801.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lobF9qeHk=,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="alt 单向链表"></p>
<p><strong>结构体构建单向链表</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体定义链表节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Listnode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;       <span class="comment">//数据域</span></span><br><span class="line">    ListNode *next; <span class="comment">//后继指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>尾插法构建单向链表</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//尾插法构建单向链表</span></span><br><span class="line"><span class="function">struct Listnode* <span class="title">Creat_Listnode</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Listnode</span> *<span class="title">head</span>,*<span class="title">p</span>,*<span class="title">q</span>;</span></span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) &amp;&amp; x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        p = (struct Listnode *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct Listnode));</span><br><span class="line">        p-&gt;data = x;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            q-&gt;next = p;</span><br><span class="line">        q = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取链表长度</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取链表长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length_Listnode</span><span class="params">(struct Listnode *head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Listnode</span> *<span class="title">t</span>;</span></span><br><span class="line">    t = head;</span><br><span class="line">    <span class="keyword">while</span>(t != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        len++;</span><br><span class="line">        t = t-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>链表排序</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链表排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort_Listnode</span><span class="params">(struct Listnode *head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">Length_Listnode</span>(head);</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Listnode</span> *<span class="title">p</span> =</span> head;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;len<span class="number">-1</span>; i++)&#123;         <span class="comment">//冒泡排序的思想</span></span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len-i<span class="number">-1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;data &gt; p-&gt;next-&gt;data)&#123;</span><br><span class="line">                tmp = p-&gt;data;</span><br><span class="line">                p-&gt;data = p-&gt;next-&gt;data;</span><br><span class="line">                p-&gt;next-&gt;data = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>链表插入节点</strong></p>
<p>·主要头节点与尾节点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//顺序插入节点</span></span><br><span class="line"><span class="function">struct Listnode* <span class="title">Insert_Listnode</span><span class="params">(struct Listnode *head, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Listnode</span> *<span class="title">t</span>,*<span class="title">p</span>;</span></span><br><span class="line">    t = head;</span><br><span class="line">    p = (struct Listnode*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct Listnode));</span><br><span class="line">    <span class="keyword">if</span>(x &lt; head-&gt;data)&#123;         <span class="comment">//插入头节点</span></span><br><span class="line">        p-&gt;data = head-&gt;data;</span><br><span class="line">        p-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;data = x;</span><br><span class="line">        head-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;                   <span class="comment">//非头节点插入</span></span><br><span class="line">        <span class="keyword">while</span>(t!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;next==<span class="literal">NULL</span> || t-&gt;next-&gt;data &gt;x)&#123;</span><br><span class="line">                p-&gt;data=x;</span><br><span class="line">                p-&gt;next=t-&gt;next;        <span class="comment">//新增指针的后继指针指向当前后继指针指向的结点</span></span><br><span class="line">                t-&gt;next=p;              <span class="comment">//当前指针的后继指针指向当前指针</span></span><br><span class="line">                <span class="keyword">break</span>;                  <span class="comment">//注意是否要跳出，跳出只删除符合的第一个数吗，不跳则删除所有符合的数</span></span><br><span class="line">            &#125;</span><br><span class="line">            t=t-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>链表删除</strong></p>
<p>·同样是要注意头和尾滴</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除链表节点</span></span><br><span class="line"><span class="function">struct Listnode* <span class="title">Delete_Listnode</span><span class="params">(struct Listnode *head, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Listnode</span> *<span class="title">t</span>,*<span class="title">p</span>;</span></span><br><span class="line">    t=head;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;data == x)&#123;       <span class="comment">//头节点删除</span></span><br><span class="line">        p = head-&gt;next;</span><br><span class="line">        head-&gt;data = head-&gt;next-&gt;data;</span><br><span class="line">        head-&gt;next = head-&gt;next-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);                <span class="comment">//free()释放内存空间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;                       <span class="comment">//非头节点删除</span></span><br><span class="line">        <span class="keyword">while</span>(t != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;next-&gt;data == x)&#123;</span><br><span class="line">                p = t-&gt;next;</span><br><span class="line">                t-&gt;next = p-&gt;next;</span><br><span class="line">               <span class="built_in">free</span>(p);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            t = t-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>链表打印</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打印链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print_Listnode</span><span class="params">(struct Listnode *head)</span></span>&#123;</span><br><span class="line">    Listnode *t;</span><br><span class="line">    t = head;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">NULL</span>)       <span class="comment">//判断链表为空</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;!链表为空!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;               <span class="comment">//顺序打印链表</span></span><br><span class="line">        <span class="keyword">while</span>(t != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t-&gt;data);</span><br><span class="line">            t = t-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<hr>
<p>以上就是涉及到链表的所有操作，包括创建、排序、插入、删除、打印等，了解链表的思想，主要是要注意表头，表中和表位，以及地址的指向。emmmm,其实c++，Java应该是用面向对象的写法来写。什么，你没有对象，new一个就好了 //滑稽</p>
<p>完整的代码我就不贴了，略略略(主要是比较长，我都要哭了)</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
