<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JVM、JRE和JDK</title>
    <url>/2021/04/11/JVM%E3%80%81JRE%E5%92%8CJDK/</url>
    <content><![CDATA[<p>计算机高级语言的类型主要有编译型和解释型两种，而Java 语言是两种类型的结合。<br>Java首先利用文本编辑器编写 Java源程序，源文件的后缀名为.java；再利用编译器（javac）将源程序编译成字节码文件，字节码文件的后缀名为.class； 最后利用虚拟机（解释器，java）解释执行。</p>
<span id="more"></span>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494836063440655.png" class="lazyload" data-srcset="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494836063440655.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Alt Java"></p>
<p>JVM(Java Virtual Machine)就是一个虚拟的用于执行bytecode字节码的”虚拟计算机”。他也定义了指令集、寄存器集、结构栈、垃圾收集堆、内存区域。JVM负责将Java字节码解释运行，边解释边运行，这样，速度就会受到一定的影响。</p>
<p>不同的操作系统有不同的虚拟机。Java 虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，随处运行”。 Java虚拟机是实现跨平台的核心机制。如图所示：<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494837984812122.png" class="lazyload" data-srcset="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494837984812122.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Alt JVM"></p>
<p>Java Runtime Environment (JRE) 包含：Java虚拟机、库函数、运行Java应用程序所必须的文件。</p>
<p>Java  Development Kit (JDK)包含：包含JRE，以及增加编译器和调试器等用于程序开发的文件。</p>
<p>JDK、JRE和JVM的关系如图所示。<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494837979897855.png" class="lazyload" data-srcset="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494837979897855.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Alt 关系图"></p>
<p>  ·如果只是要运行Java程序，只需要JRE就可以。JRE通常非常小，其中包含了JVM。</p>
<p>  ·如果要开发Java程序，就需要安装JDK。</p>
<p><strong>Java环境搭建</strong></p>
<p>下载JDK<br>    下载地址：<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">www.oracle.com/technetwork/java/javase/downloads/index.html</a></p>
<p>点击下载JDK，会出现下载列表界面。首先，点击”Accept License Agreement”，然后选择对应的版本，下载即可。</p>
<p>注意：<br>    32位操作系统只能安装32位JDK；<br>    64位操作系统可安装32位JDK，也可以安装64位JDK。</p>
<p>安装JDK</p>
<p>安装过程和普通软件安装没什么区别，过程中会让你选择JDK和JRE安装目录，采用默认即可。也就是说，通通点击“下一步”就能完成安装。<br>安装成功后我们再进入JDK的安装目录，可以看到如下的结构：<br>其中：</p>
<pre><code>bin目录是存储一些可执行的二进制文件；

lib存储相关jar包；

src.zip是JDK相关JAVA类的源代码。</code></pre><p><strong>环境变量Path的配置</strong><br>&emsp;&emsp;环境变量是在操作系统中一个具有特定名字的对象， 它包含了一个或者多个应用程序所将使用到的信息。</p>
<p>&emsp;&emsp;Path是一个常见的环境变量，它告诉操作系统，当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下寻找此程序外，还应到哪些目录下寻找。</p>
<p>设置Parh环境变量：</p>
<ol>
<li><p>右键计算机——&gt;属性——&gt;高级系统设置<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494838772220505.png" class="lazyload" data-srcset="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494838772220505.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Alt 1"></p>
</li>
<li><p>单击环境变量按钮<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494838780549127.png" class="lazyload" data-srcset="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494838780549127.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Alt 2"></p>
</li>
<li><p>单击新建按钮，新建JAVA_HOME变量（用于说明JDK的安装目录）<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494838787522279.png" class="lazyload" data-srcset="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494838787522279.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Alt 3"></p>
</li>
<li><p>修改系统环境变量Path，在最前面追加%JAVA_HOME%\bin  并以;和原路径分隔。再增加：“.;”。这是表示当前目录的意思<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494838936169679.png" class="lazyload" data-srcset="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494838936169679.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Alt 4"></p>
</li>
</ol>
<p>注意：</p>
<pre><code>此处一定是英文分号而不是中文分号！！！

classpath配置问题：如果使用JDK1.5以上就不需要配置这个环境变量！JRE会自动搜索当前路径下的类文件及相关jar文件</code></pre><hr>
<p>2021-04-11注：目前从Oracle下载的jdk安装程序，安装完成以后无需配置环境变量，安装过程中会自动配置完成</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>flybird</title>
    <url>/2019/11/11/flybird/</url>
    <content><![CDATA[<h2 id="一个简单的C-小游戏"><a href="#一个简单的C-小游戏" class="headerlink" title="一个简单的C++小游戏"></a>一个简单的C++小游戏</h2><span id="more"></span>

<hr>
<h3 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Lines = <span class="number">35</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Columns = <span class="number">120</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LeftLineColumn = <span class="number">20</span>;</span><br><span class="line">HANDLE hOut;</span><br><span class="line">DWORD dword;</span><br><span class="line"><span class="keyword">char</span> tmp[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> cur_time, start_time, last_time;</span><br><span class="line"><span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawBird</span><span class="params">(<span class="keyword">double</span> xx, <span class="keyword">double</span> yy)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = (<span class="keyword">int</span>)(xx + <span class="number">0.5</span>);</span><br><span class="line">  <span class="keyword">int</span> y = (<span class="keyword">int</span>)(yy + <span class="number">0.5</span>);</span><br><span class="line">  <span class="keyword">static</span> DWORD dword;</span><br><span class="line">  <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;v&quot;</span>, <span class="number">1</span>, (COORD)&#123;x, y - <span class="number">1</span>&#125;, &amp;dword);</span><br><span class="line">  <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;&gt;&gt;&gt;&quot;</span>, <span class="number">3</span>, (COORD)&#123;x - <span class="number">1</span>, y&#125;, &amp;dword);</span><br><span class="line">  <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;^&quot;</span>, <span class="number">1</span>, (COORD)&#123;x, y + <span class="number">1</span>&#125;, &amp;dword);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearBird</span><span class="params">(<span class="keyword">double</span> xx, <span class="keyword">double</span> yy)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = (<span class="keyword">int</span>)(xx + <span class="number">0.5</span>);</span><br><span class="line">  <span class="keyword">int</span> y = (<span class="keyword">int</span>)(yy + <span class="number">0.5</span>);</span><br><span class="line">  <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot; &quot;</span>, <span class="number">1</span>, (COORD)&#123;x, y - <span class="number">1</span>&#125;, &amp;dword);</span><br><span class="line">  <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;   &quot;</span>, <span class="number">3</span>, (COORD)&#123;x - <span class="number">1</span>, y&#125;, &amp;dword);</span><br><span class="line">  <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot; &quot;</span>, <span class="number">1</span>, (COORD)&#123;x, y + <span class="number">1</span>&#125;, &amp;dword);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Write at Middle/Left */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">WriteMiddle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> l = <span class="built_in">strlen</span>(str);</span><br><span class="line">  <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, str, l, (COORD)&#123;(Columns - l) / <span class="number">2</span>, y&#125;, &amp;dword);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">WriteLeft</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> l = <span class="built_in">strlen</span>(str);</span><br><span class="line">  <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, str, l, (COORD)&#123;<span class="number">1</span>, y&#125;, &amp;dword);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitLeftSide</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lines; ++i)</span><br><span class="line">    <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;|&quot;</span>, <span class="number">2</span>, (COORD)&#123;LeftLineColumn, i&#125;, &amp;dword);</span><br><span class="line">  <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">  ++p; <span class="built_in">WriteLeft</span>(<span class="string">&quot;Help:&quot;</span>, p);</span><br><span class="line">  ++p; <span class="built_in">WriteLeft</span>(<span class="string">&quot; Press &lt;Space&gt; to&quot;</span>, p);</span><br><span class="line">  ++p; <span class="built_in">WriteLeft</span>(<span class="string">&quot;make the bird fly.&quot;</span>, p);</span><br><span class="line">  ++p; <span class="built_in">WriteLeft</span>(<span class="string">&quot; Don&#x27;t fall to the&quot;</span>, p);</span><br><span class="line">  ++p; <span class="built_in">WriteLeft</span>(<span class="string">&quot;ground or hit pipes&quot;</span>, p);</span><br><span class="line">  ++p; <span class="comment">// Empty line</span></span><br><span class="line">  ++p; <span class="built_in">WriteLeft</span>(<span class="string">&quot;Time:&quot;</span>, p);</span><br><span class="line">  ++p; <span class="comment">// Time</span></span><br><span class="line">  ++p; <span class="built_in">WriteLeft</span>(<span class="string">&quot;Fps:&quot;</span>, p);</span><br><span class="line">  ++p; <span class="comment">// Fps</span></span><br><span class="line">  ++p; <span class="comment">// Empty line</span></span><br><span class="line">  ++p; <span class="built_in">WriteLeft</span>(<span class="string">&quot;Score:&quot;</span>, p);</span><br><span class="line">  ++p; <span class="comment">// Score</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawLeftSide</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">  ++p; <span class="comment">// WriteLeft(&quot;Help:&quot;, p);</span></span><br><span class="line">  ++p; <span class="comment">// WriteLeft(&quot; Press &lt;Space&gt; to&quot;, p);</span></span><br><span class="line">  ++p; <span class="comment">// WriteLeft(&quot;make the bird fly.&quot;, p);</span></span><br><span class="line">  ++p; <span class="comment">// WriteLeft(&quot; Don&#x27;t fall to the&quot;, p);</span></span><br><span class="line">  ++p; <span class="comment">// WriteLeft(&quot;ground or hit pipes&quot;, p);</span></span><br><span class="line">  ++p; <span class="comment">// Empty line</span></span><br><span class="line">  ++p; <span class="comment">// WriteLeft(&quot;Time:&quot;, p);</span></span><br><span class="line">  <span class="built_in">sprintf</span>(tmp, <span class="string">&quot; %5.2lfs&quot;</span>, (<span class="keyword">double</span>)(cur_time - start_time) / CLOCKS_PER_SEC);</span><br><span class="line">  ++p; <span class="built_in">WriteLeft</span>(tmp, p);</span><br><span class="line">  ++p; <span class="comment">// WriteLeft(&quot;Fps:&quot;, p);</span></span><br><span class="line">  <span class="built_in">sprintf</span>(tmp, <span class="string">&quot; %5.2lf&quot;</span>, CLOCKS_PER_SEC / (<span class="keyword">double</span>)(cur_time - last_time));</span><br><span class="line">  ++p; <span class="built_in">WriteLeft</span>(tmp, p);</span><br><span class="line">  ++p; <span class="comment">// Empty line</span></span><br><span class="line">  ++p; <span class="comment">// WriteLeft(&quot;Score:&quot;, p);</span></span><br><span class="line">  <span class="built_in">sprintf</span>(tmp, <span class="string">&quot; %3d&quot;</span>, score);</span><br><span class="line">  ++p; <span class="built_in">WriteLeft</span>(tmp, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pipe</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> H, D; <span class="comment">// A Pipe, [x, x + 1] * ([0, H] and [D, Lines))</span></span><br><span class="line">  <span class="keyword">double</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">RandRange</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">rand</span>() % (r - l + <span class="number">1</span>) + l; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Pipe <span class="title">RandomPipe</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> br = <span class="built_in">RandRange</span>(<span class="number">8</span>, <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">int</span> h = <span class="built_in">RandRange</span>(<span class="number">3</span>, Lines - br - <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> (Pipe)&#123;h, h + br, (<span class="keyword">double</span>)x&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">CheckPipe</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">double</span> y, <span class="keyword">const</span> Pipe &amp;p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> px = (<span class="keyword">int</span>)(p.x + <span class="number">0.5</span>);</span><br><span class="line">  <span class="keyword">int</span> dx = std::<span class="built_in">min</span>(std::<span class="built_in">abs</span>(x - px), std::<span class="built_in">abs</span>(x - px - <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">if</span> (dx &gt; <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (dx == <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> y &gt; p.H - <span class="number">0.5</span> &amp;&amp; y &lt; p.D + <span class="number">0.5</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (dx == <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> y &gt; p.H + <span class="number">0.5</span> &amp;&amp; y &lt; p.D - <span class="number">0.5</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> y &gt; p.H + <span class="number">1.5</span> &amp;&amp; y &lt; p.D - <span class="number">1.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearPipe</span><span class="params">(<span class="keyword">const</span> Pipe &amp;p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> px = (<span class="keyword">int</span>)(p.x + <span class="number">0.5</span>);</span><br><span class="line">  <span class="keyword">if</span> (px != LeftLineColumn &amp;&amp; px + <span class="number">1</span> &lt; Columns) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.H; ++i)</span><br><span class="line">      <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;  &quot;</span>, <span class="number">2</span>, (COORD)&#123;px, i&#125;, &amp;dword);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p.D + <span class="number">1</span>; i &lt; Lines; ++i)</span><br><span class="line">      <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;  &quot;</span>, <span class="number">2</span>, (COORD)&#123;px, i&#125;, &amp;dword);</span><br><span class="line">    <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;  &quot;</span>, <span class="number">2</span>, (COORD)&#123;px + <span class="number">1</span>, p.H&#125;, &amp;dword);</span><br><span class="line">    <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;  &quot;</span>, <span class="number">2</span>, (COORD)&#123;px + <span class="number">1</span>, p.D&#125;, &amp;dword);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> x = px == LeftLineColumn ? px + <span class="number">1</span> : px;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.H; ++i)</span><br><span class="line">      <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot; &quot;</span>, <span class="number">1</span>, (COORD)&#123;x, i&#125;, &amp;dword);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p.D + <span class="number">1</span>; i &lt; Lines; ++i)</span><br><span class="line">      <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot; &quot;</span>, <span class="number">1</span>, (COORD)&#123;x, i&#125;, &amp;dword);</span><br><span class="line">    <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot; &quot;</span>, <span class="number">1</span>, (COORD)&#123;x, p.H&#125;, &amp;dword);</span><br><span class="line">    <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot; &quot;</span>, <span class="number">1</span>, (COORD)&#123;x, p.D&#125;, &amp;dword);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawPipe</span><span class="params">(<span class="keyword">const</span> Pipe &amp;p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> px = (<span class="keyword">int</span>)(p.x + <span class="number">0.5</span>);</span><br><span class="line">  <span class="keyword">if</span> (px &lt; LeftLineColumn) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (px != LeftLineColumn &amp;&amp; px + <span class="number">1</span> &lt; Columns) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.H; ++i)</span><br><span class="line">      <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;||&quot;</span>, <span class="number">2</span>, (COORD)&#123;px, i&#125;, &amp;dword);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p.D + <span class="number">1</span>; i &lt; Lines; ++i)</span><br><span class="line">      <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;||&quot;</span>, <span class="number">2</span>, (COORD)&#123;px, i&#125;, &amp;dword);</span><br><span class="line">    <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;--&quot;</span>, <span class="number">2</span>, (COORD)&#123;px, p.H&#125;, &amp;dword);</span><br><span class="line">    <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;--&quot;</span>, <span class="number">2</span>, (COORD)&#123;px, p.D&#125;, &amp;dword);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> x = px == LeftLineColumn ? px + <span class="number">1</span> : px;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.H; ++i)</span><br><span class="line">      <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;|&quot;</span>, <span class="number">1</span>, (COORD)&#123;x, i&#125;, &amp;dword);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p.D + <span class="number">1</span>; i &lt; Lines; ++i)</span><br><span class="line">      <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;|&quot;</span>, <span class="number">1</span>, (COORD)&#123;x, i&#125;, &amp;dword);</span><br><span class="line">    <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;-&quot;</span>, <span class="number">1</span>, (COORD)&#123;x, p.H&#125;, &amp;dword);</span><br><span class="line">    <span class="built_in">WriteConsoleOutputCharacter</span>(hOut, <span class="string">&quot;-&quot;</span>, <span class="number">1</span>, (COORD)&#123;x, p.D&#125;, &amp;dword);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">HideCursor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  CONSOLE_CURSOR_INFO cci;</span><br><span class="line">  <span class="built_in">GetConsoleCursorInfo</span>(hOut,&amp;cci);</span><br><span class="line">  cci.bVisible = FALSE;</span><br><span class="line">  <span class="built_in">SetConsoleCursorInfo</span>(hOut,&amp;cci);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">  <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;mode con lines=%d cols=%d&quot;</span>, Lines, Columns);</span><br><span class="line">  <span class="built_in">system</span>(tmp);</span><br><span class="line">  hOut = <span class="built_in">GetStdHandle</span>(STD_OUTPUT_HANDLE);</span><br><span class="line">  <span class="built_in">HideCursor</span>();</span><br><span class="line">  <span class="built_in">InitLeftSide</span>();</span><br><span class="line">  <span class="built_in">WriteMiddle</span>(<span class="string">&quot;Flappy bird (Simple)&quot;</span>, Lines / <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">WriteMiddle</span>(<span class="string">&quot;--By _wyt&quot;</span>, Lines / <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">WriteMiddle</span>(<span class="string">&quot;Press any key to start...&quot;</span>, Lines / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">  _getch();</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pipe pipes[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Init</span>();</span><br><span class="line">  <span class="built_in">InitLeftSide</span>();</span><br><span class="line">  last_time = start_time = <span class="built_in">clock</span>();</span><br><span class="line">  score = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> g = <span class="number">35</span>; <span class="comment">// Gravitational acceleration, grid / s^2</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> vx = <span class="number">12.0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> x = <span class="number">27.0</span>;</span><br><span class="line">  <span class="keyword">double</span> y = <span class="number">5.0</span>, vy = <span class="number">0.0</span>;</span><br><span class="line">  <span class="keyword">int</span> pipe_n = <span class="number">0</span>;</span><br><span class="line">  pipes[pipe_n++] = <span class="built_in">RandomPipe</span>(Columns - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">kbhit</span>()) &#123;</span><br><span class="line">      <span class="keyword">char</span> c = _getch();</span><br><span class="line">      <span class="keyword">if</span> (c == <span class="number">32</span>) vy = <span class="number">-15.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cur_time = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">double</span> time_break = (<span class="keyword">double</span>)(cur_time - last_time) / CLOCKS_PER_SEC;</span><br><span class="line">    <span class="built_in">ClearBird</span>(x, y);</span><br><span class="line">    y = std::<span class="built_in">min</span>(vy * time_break + y, <span class="number">33.0</span>);</span><br><span class="line">    vy += g * time_break;</span><br><span class="line">    <span class="keyword">if</span> (y &lt; <span class="number">1</span> - <span class="number">1e-6</span>) &#123; y = <span class="number">1</span>; vy = <span class="number">.0</span>; &#125;</span><br><span class="line">    <span class="built_in">DrawBird</span>(x, y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pipe_n; ++i) &#123;</span><br><span class="line">      <span class="keyword">double</span> px = pipes[i].x, px2 = pipes[i].x - vx * time_break;</span><br><span class="line">      <span class="keyword">if</span> ((<span class="keyword">int</span>)(px + <span class="number">0.5</span>) != (<span class="keyword">int</span>)(px2 + <span class="number">0.5</span>)) &#123;</span><br><span class="line">        <span class="built_in">ClearPipe</span>(pipes[i]);</span><br><span class="line">        pipes[i].x = px2;</span><br><span class="line">        <span class="built_in">DrawPipe</span>(pipes[i]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pipes[i].x = px2;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Columns - pipes[pipe_n - <span class="number">1</span>].x &gt; <span class="number">30</span>)</span><br><span class="line">      <span class="built_in">DrawPipe</span>(pipes[pipe_n++] = <span class="built_in">RandomPipe</span>(Columns - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> failed = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pipe_n; ++i) &#123;</span><br><span class="line">      failed = failed || !<span class="built_in">CheckPipe</span>((<span class="keyword">int</span>)(x + <span class="number">0.5</span>), y, pipes[i]);</span><br><span class="line">      <span class="keyword">if</span> ((<span class="keyword">int</span>)(pipes[i].x + <span class="number">0.5</span>) &gt;= LeftLineColumn)</span><br><span class="line">        pipes[j++] = pipes[i];</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        ++score;</span><br><span class="line">    &#125;</span><br><span class="line">    pipe_n = j;</span><br><span class="line">    <span class="built_in">DrawLeftSide</span>();</span><br><span class="line">    <span class="keyword">if</span> (y &gt;= <span class="number">33.0</span> - <span class="number">1e-6</span> || failed) &#123;</span><br><span class="line">      <span class="built_in">DrawBird</span>(x, y);</span><br><span class="line">      <span class="built_in">WriteMiddle</span>(<span class="string">&quot;-------------------------------&quot;</span>, Lines / <span class="number">2</span> - <span class="number">2</span>);</span><br><span class="line">      <span class="built_in">WriteMiddle</span>(<span class="string">&quot;|                             |&quot;</span>, Lines / <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">      <span class="built_in">WriteMiddle</span>(<span class="string">&quot;|                             |&quot;</span>, Lines / <span class="number">2</span>);</span><br><span class="line">      <span class="built_in">WriteMiddle</span>(<span class="string">&quot;|                             |&quot;</span>, Lines / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">      <span class="built_in">WriteMiddle</span>(<span class="string">&quot;|                             |&quot;</span>, Lines / <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line">      <span class="built_in">WriteMiddle</span>(<span class="string">&quot;-------------------------------&quot;</span>, Lines / <span class="number">2</span> + <span class="number">3</span>);</span><br><span class="line">      <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;Your score: %d!&quot;</span>, score);</span><br><span class="line">      <span class="built_in">WriteMiddle</span>(tmp, Lines / <span class="number">2</span>);</span><br><span class="line">      <span class="built_in">WriteMiddle</span>(<span class="string">&quot;Press any key to exit...&quot;</span>, Lines / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">      _getch();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    last_time = cur_time;</span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">40</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> _ **** 嘿嘿，慢慢玩 _</p>
]]></content>
      <tags>
        <tag>随笔</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>c++&amp;vector</title>
    <url>/2019/12/03/c-vector/</url>
    <content><![CDATA[<p>在c++中，vector是一个十分有用的容器。</p>
<p>作用：它能够像容器一样存放各种类型的对象，简单地说，vector是一个能够存放任意类型的动态数组，能够增加和压缩数据。</p>
<p>vector在C++标准模板库中的部分内容，它是一个多功能的，能够操作多种数据结构和算法的模板类和函数库。</p>
<span id="more"></span>

<p><strong>特别注意：</strong></p>
<p>使用vector需要注意以下几点：</p>
<p>1.加入头文件<code>&lt;vector&gt;</code></p>
<p>2.如果你要表示的向量长度较长（需要为向量内部保存很多数），容易导致内存泄漏，而且效率会很低；</p>
<p>3.Vector作为函数的参数或者返回值时，需要注意它的写法：</p>
<p> ==double Distance(vector<int>&amp;a, vector<int>&amp;b) 其中的“&amp;”绝对不能少！！！==</p>
<h2 id="一维vector"><a href="#一维vector" class="headerlink" title=" 一维vector"></a><center> 一维vector</center></h2><p><strong>创建一维vector：</strong></p>
<pre><code>vector&lt;int&gt; nums;       //不指定长度
vector&lt;int&gt; nums(n);    //指定长度为n</code></pre><p><strong>添加元素</strong></p>
<pre><code>nums.push_back(1);      //直接从数组末端添加
nums[i]=1;              //直接赋值给第i个位置
nums.insert(nums.begin()+i,a);  //在第i+1个元素前插入a</code></pre><p><strong>删除元素</strong></p>
<pre><code>nums.resize(nums.size-i);    //直接将数组长度减少，某种意义上删掉了后面i个
nums.pop_back();             //删掉最后一个元素
nums.erase(nums.begin()+i);  //删掉第i+1个元素
nums.erase(nums.begin()+i,nums.end()+j);    //删除区间[i,j-1],区间从0开始
nums.clear();                //清空</code></pre><p><strong>其它</strong></p>
<p>获取长度：nums.size();</p>
<p>排序(O(nlogn))：sort(nums.begin(),nums.end());</p>
<p>翻转：reverse(nums.begin(),nums.end());</p>
<p>合并两个vector：合并nums1和nums2，并将合并的数组赋值给nums</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nums1</span><span class="params">(m)</span>,<span class="title">nums2</span><span class="params">(n)</span></span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">nums.<span class="built_in">resize</span>(m+n);</span><br><span class="line"><span class="built_in">merge</span>(nums1.<span class="built_in">begin</span>(),nums1.<span class="built_in">end</span>(),nums2.<span class="built_in">begin</span>(),nums2.<span class="built_in">end</span>(),nums);</span><br></pre></td></tr></table></figure>

<h2 id="二维vector"><a href="#二维vector" class="headerlink" title="二维vector"></a><center>二维vector</center></h2><p><strong>创建M*n二维vector</strong></p>
<pre><code>vector&lt; vector&lt;int&gt; &gt; nums(m,vector&lt;int&gt;(n));   //m*n的二维vector</code></pre><p>解释：</p>
<p>定义了一个vector容器，元素类型为vector<int>，初始化为包含m个vector<int>对象，每个对象都是一个新创立的vector<int>对象的拷贝，而这个新创立的vector<int>对象被初始化为包含n个0。</p>
<p>vector<int>(n)表示构造一个无名且含n个0的vector<int>对象。</p>
<p><strong>动态创建m*n的二维vector</strong></p>
<p>==方法一==</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector &lt;<span class="keyword">int</span>&gt; &gt; nums;<span class="number">3</span></span><br><span class="line"></span><br><span class="line">nums.<span class="built_in">resize</span>(m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) nums[i].<span class="built_in">resize</span>(n);</span><br></pre></td></tr></table></figure>

<p>==方法二==</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector &lt;<span class="keyword">int</span>&gt; &gt; nums;</span><br><span class="line">nums.<span class="built_in">resize</span>(m,vector&lt;<span class="keyword">int</span>&gt;(n));</span><br></pre></td></tr></table></figure>
<p><strong>初始化二维数组</strong></p>
<pre><code>vector&lt;vector &lt;int&gt; &gt; nums(m ,vector&lt;int&gt;(n,0));    //m*n的二维vector，所有元素为0</code></pre><p>获得二维数组的行数：nums.size(); </p>
<p>获得二维数组的列数：nums[0].size()；</p>
<p><strong>数组遍历</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m = nums.<span class="built_in">size</span>(),n = nums[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">        cout&lt;&lt;nums[i][j]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用vector还可以用结构体类型哟"><a href="#用vector还可以用结构体类型哟" class="headerlink" title="用vector还可以用结构体类型哟"></a><del>用vector还可以用结构体类型哟</del></h3>]]></content>
      <tags>
        <tag>c++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>love</title>
    <url>/2021/04/13/love/</url>
    <content><![CDATA[<p>My love for you exists in every bit of life,like this code</p>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(meetMe || !meetMe) &#123; <span class="comment">//你见，或者不见我</span></span><br><span class="line">   <span class="keyword">await</span> there(&#123;</span><br><span class="line">      <span class="attr">me</span>: &#123;        <span class="comment">//我就在那里</span></span><br><span class="line">         <span class="attr">sad</span>: <span class="literal">null</span>, <span class="comment">//不悲 不喜</span></span><br><span class="line">         <span class="attr">happy</span>: <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(meetMe || !meetMe) &#123;    <span class="comment">//你念，或者不念我</span></span><br><span class="line">   <span class="keyword">await</span> there(&#123;</span><br><span class="line">      <span class="attr">feeling</span>: &#123;    <span class="comment">//情就在那里</span></span><br><span class="line">         <span class="attr">left</span>: <span class="number">0</span>,   <span class="comment">//不来 不去</span></span><br><span class="line">         <span class="attr">right</span>: <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(loveMe || !loveMe) &#123;    <span class="comment">//你爱，或者不爱我</span></span><br><span class="line">   <span class="keyword">await</span> there(&#123;     <span class="comment">//爱就在那里</span></span><br><span class="line">      <span class="attr">love</span>: <span class="literal">Infinity</span> <span class="comment">//不增不减</span></span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(withMe || !withMe) &#123;    <span class="comment">//你跟，或者不跟我</span></span><br><span class="line">   <span class="keyword">const</span> tomorrow = &#123; <span class="comment">//我的手就在你手里</span></span><br><span class="line">      <span class="attr">we</span>: myHands &amp;&amp; yourHands</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">Object</span>.freeze(tomorrow)    <span class="comment">//不舍不弃</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!myArms.has(you)) &#123;    <span class="comment">//来我的怀里</span></span><br><span class="line">   OR             <span class="comment">//或者</span></span><br><span class="line">   yourHeart.push(me) <span class="comment">//让我住进你的心里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>生活</tag>
        <tag>爱</tag>
      </tags>
  </entry>
  <entry>
    <title>三行情话</title>
    <url>/2021/04/10/%E4%B8%89%E8%A1%8C%E6%83%85%E8%AF%97/</url>
    <content><![CDATA[<p>螃蟹在剥我的壳，笔记本在写我</p>
<p>漫天的我落在枫叶上、雪花上</p>
<p>而你在想我      ————《武汉大学-三行情诗》</p>
<span id="more"></span>

<h4 id="有一种理解"><a href="#有一种理解" class="headerlink" title="有一种理解"></a>有一种理解</h4><p>也是最美好的一种解释，即全文主宾倒装</p>
<p>我在剥螃蟹的壳、写笔记本，枫叶、雪花落在我上，而我在…</p>
<h4 id="有一种理解-1"><a href="#有一种理解-1" class="headerlink" title="有一种理解"></a>有一种理解</h4><p>也是对情感的绝望，即全文否定</p>
<p>螃蟹不可能在剥我的壳，笔记本不可能在写我，我不可能落在枫叶上、雪花上，而你也不可能在想我</p>
<h4 id="有一种理解-2"><a href="#有一种理解-2" class="headerlink" title="有一种理解"></a>有一种理解</h4><p>也是一种自欺欺人</p>
<p>只有当在螃蟹在剥我的壳，笔记本写我，我落在枫叶上、雪花上的时候，你才会想我</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>世界上没那么多错过</title>
    <url>/2020/02/03/%E4%B8%96%E7%95%8C%E4%B8%8A%E6%B2%A1%E9%82%A3%E4%B9%88%E5%A4%9A%E9%94%99%E8%BF%87/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="f0883e4a2eb1aa1381b3ba18f0ff3a6c51e49fa31e82c87cb9cf7bd705157243">6de660ac7b4e1815a73b127ec3abb05f51924f2811536e1624e23d55841dcfc3b15b449442c5c9931bd4010101b285b6b9b8e00c5d4344e2d3d77d2995b1c79a830705f1c6dfaa178056ed6a45908020f375498dd1050e1269dde668b04939d41aa33660746b2dc957b8989f7d9cd9c069bebcba9ba98ed6c7b0d1bdbdd5b8e5f2642d08b81bccf7225d9cde4b89eadece8fc5458c9b628cc4f27097c519b0ab5976bf641ccecdbd380fe9793d772e4284e5259d13008906d713f0df100eb9ee439dc69758c863877cd3856afc46e7bbbec1bbf00c38b1dd252e973abee74deb9d0886049447f8980e3bb31d77639b1b92269a7a2441752826401112cb60ccbc370b9fd7620d0ab8db6a40cc6a45b3aeb0117086cae0cee2e2673a38b4780ec4cb935ea2d2bb25f54a1414b38905aa07315b5875aec77880c545c4f4317ce41873e8edcf5167a95589b72547ef266fb1770e7eec99bb5b092300bdb094d1020d6cc0542c81fc94813cfbc8736a41a4fd38bfdbac53947c30a3d22f1ec3f759b4418cc66c45dfb0fc155b100b3ace70b0adf8ce69b5ba70b7f8862c5e782cfa384fc31025e2fdd92a4296fc023420d1372372ae8f542c0d7355b308b7e2df755d0ebc23c08ac15d8b52ce64e547854dd6b136ef20204a037745647b5a102c2b6f4d7669ca79545ec8685c57fcdf805941610af5328c9e743c338c29f5f47f7be1acc7753e3b0b487e3d870d406575a4304010430744f4a6b4a393a73b74819447c18db3208ea308343d4f67125626618aac8c8e011ee9ca77a59fab83d3e8f01b4856deba7addceb238b2f87164e4bed64060ddabf148e089baa4a07f0447199e8362df71b101aa1863aa38958920175a4b80b772dc103d09eaaa0191e7a076941f111ed06b1cc107f542b1910b3f8818790f3b8ab14d78989a29c63ee434677b1280eb853a6ec1309ad34cedba19091b4bc36cd447b97c455f62a4d059b7a85d4d71935b76f36bcac3ae1015fea0c5571e39bdf51947d9b569da0841631594c6e22449c8d288977d2a5c75eea45e55396023e4d76dce3c26dce4698798637a0839e6fe3eaabf1dde8efa542c6c4aac682f7ca02f56d9d3d4477c6e78c908a8e61657d2d836c5f6b9a7901a8fb4636ebd3fb5ceae5522df6e05fb3bea5683353233de3d49e1f34333a872fd1a421603360730620a28a96e7b6ded2f34074f3ef455a9cd748483522d88962824c057350ed347984441cbae34fff44b537def5a0a175a6238dbca14270a6ef0a468efee1bc27f62f3af422502152535e0eaa2f226ce12e3bd94b934db39a2c858a2ceadcae250ba0ad129574a40d9f3ebf300d9af740b53ad028451d83a59f2a8536636a7</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">你猜</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>人生路不长，别再等以后(转载)</title>
    <url>/2019/11/12/%E4%BA%BA%E7%94%9F%E8%B7%AF%E4%B8%8D%E9%95%BF%EF%BC%8C%E5%88%AB%E5%86%8D%E7%AD%89%E4%BB%A5%E5%90%8E-%E8%BD%AC%E8%BD%BD/</url>
    <content><![CDATA[<center>一辈子很短，短得来不及细算</center> 

<span id="more"></span>

<center></center****> 

<p>童年，不知不觉没了<br>青春，不知不觉没了<br>而那些无忧无虑的快乐<br>好像也消失不见了<br>一辈子三万天而已<br>没有你想得那么长<br>有什么心愿，快点实现<br>有什么目标，快点奋战<br>别等来等去<br>等来了年龄增长<br>等来了热情褪去<br>人生不是花，败了再开<br>身体不是叶，落了再生<br>我们每个人<br>都只有一次人生，只有一个身体<br>生病不能等，健康没了，人就完了<br>人生不能等，时间过了，人就终了<br>一辈子不长，别再等以后<br>想吃的东西，去吃<br>想做的事情，趁早<br>想要的感情，去追<br>想去的地方，快去<br>别一等再等<br>等牙没有了，想吃就难了<br>等人离开了，想爱就晚了<br>一辈子很短，这一生短暂<br>时间不等人，岁月不等你<br>趁我们都还活着<br>对父母，孝顺点，对爱人，珍惜点<br>对朋友，真心点，对自己，好一点</p>
<p>```</p>
<h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算小结</title>
    <url>/2019/12/25/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>位运算主要包括按位与(&amp;)、按位或(|)、按位异或(^)、取反(~)、左移(&lt;&lt;)、右移(&gt;&gt;)这几种，其中除了取反(~)以外，其他的都是二目运算符，即要求运算符左右两侧均有一个运算量</p>
<span id="more"></span>

<h3 id="位运算概览"><a href="#位运算概览" class="headerlink" title="位运算概览"></a>位运算概览</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
<th>运算规则</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;&lt;</td>
<td>左移</td>
<td>各二进位全部左移若干位，高位丢弃，低位补0</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移</td>
<td>各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移</td>
</tr>
<tr>
<td>|</td>
<td>按位或</td>
<td>两个位都为0时，结果才为0</td>
</tr>
<tr>
<td>&amp;</td>
<td>按位与</td>
<td>两个位都为1时，结果才为1</td>
</tr>
<tr>
<td>~</td>
<td>按位取反</td>
<td>0变1，1变0</td>
</tr>
<tr>
<td>^</td>
<td>按位异或</td>
<td>^    异或    两个位相同为0，相异为1</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>初级素数判断</title>
    <url>/2019/11/10/%E5%88%9D%E7%BA%A7%E7%B4%A0%E6%95%B0%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<p>这篇只是让大家初步了解如何判断素数，是最基础的内容，之后会讲一些欧拉，埃氏等素数筛的方法</p>
<span id="more"></span>

<h6 id="第一次的想法"><a href="#第一次的想法" class="headerlink" title="第一次的想法:"></a>第一次的想法:</h6><p>==让它爆搜一遍不就好了== <del>爆搜大法好爆搜大法好</del></p>
<blockquote>
<p>具体实现就是让数n从2开始模,一直模到n-1,如果都不能被整除,那就是素数<strong>紧扣定义</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否是素数1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;please inpout a number.&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; m; ++i)</span><br><span class="line">        <span class="keyword">if</span> (m%i == <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; m &lt;&lt; <span class="string">&quot; isn&#x27;t a prime\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; m &lt;&lt; <span class="string">&quot; is a prime\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这么复杂,那来进行下简单优化:<br>如果一个数有因子的话，那么在它的平方根数以内就应该有，否则就没有因子。例如66的平方根在8与9之间，因为66不是素数，，则它一定有比8还小的因子，我们知道66的因子是2、3、6等<br><strong>那我们就可以这样写了</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="built_in">sqrt</span>(m); ++i)&#123;</span><br><span class="line">    <span class="keyword">if</span> (m%i == <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; m &lt;&lt; <span class="string">&quot; isn&#x27;t a prime\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>本次初级素数判断就先到这里</strong><br><strong>有没有感觉到循环挺浪费时间的呢</strong><br><strong>那去想想有什么方法能够进一步降低时间复杂度</strong></p>
]]></content>
      <tags>
        <tag>c++</tag>
        <tag>素数</tag>
      </tags>
  </entry>
  <entry>
    <title>博客重建</title>
    <url>/2021/04/09/%E5%8D%9A%E5%AE%A2%E9%87%8D%E5%BB%BA/</url>
    <content><![CDATA[<p>博客声明</p>
<span id="more"></span>

<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>由于当时重新配置个人电脑，所以重装了系统，后来其它事情多了起来（其实主要就是懒），就没再维护这个博客，最近一段时间发生了很多事，所以产生了从头再来的想法，并且<code>最新内容</code>以及<code>个人生活</code>、<code>文笔</code>将优先从本站发布，其它平台将陆续更新，并且某些平台将暂停使用（<em>注：版式将暂时沿用原有主题，有空会考虑自建一个主题使用</em>）</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>将舍弃以前大部分文章，从新开始写，并且整理成为专栏，可通过查看tags的方式找到某一系列文章，并且考虑在日后加入开源项目池，而且秉持技术开源思想，希望能与大佬多多交流</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>如果有想法想与我交流，可通过GitHub站内信的形式，如果你也觉得我做的不错，希望能给我点亮一个star</p>
]]></content>
  </entry>
  <entry>
    <title>排序之归并排序</title>
    <url>/2019/11/26/%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>来说说归并排序是啥？归并排序就是排序呗。啥，啥排序？归并呗。 </p>
<h2 id="哔bibibi-瞎哔哔"><a href="#哔bibibi-瞎哔哔" class="headerlink" title=" 哔bibibi(瞎哔哔)"></a> <del>哔bibibi(瞎哔哔)</del></h2><span id="more"></span>

<p>好吧,归并排序，是创建在归并操作上的一种有效的排序算法，效率为O(nlogn)。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分</p>
<p>治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。速度仅次于快速排序，为稳定排序算法，一般用</p>
<p>于对总体无序，但是各子项相对有序的数列，归并排序的比较次数小于快速排序的比较次数，移动次数一般多于快速排序的移动次数。</p>
<p><strong>算法思想</strong></p>
<p>该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶</p>
<p>段则将分的阶段得到的各答案”修补”在一起，即分而治之)。既然归并排序采用的是分治法，并且依托于归并操作，那么其思想肯定是分</p>
<p>而治之。我们知道归并操作是将两个有序的数列合并到一个有序的序列，那么对于一个无序的长序列，可以把它分解为若干个有序的子</p>
<p>序列，然后依次进行归并。如果我们说每一个数字都是单独有序的序列，那么只要把原始长序列依次分解，直到每个子序列都只有一个</p>
<p>元素的时候，再依次把所有的序列进行归并，直到序列数为1</p>
<p><img src="https://ftp.bmp.ovh/imgs/2019/12/623396b9f4e3a0ab.jpg" class="lazyload" data-srcset="https://ftp.bmp.ovh/imgs/2019/12/623396b9f4e3a0ab.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="alt 单向链表"></p>
<p>综上可知：</p>
<p>归并排序其实要做两件事：</p>
<p>（1）“分解”——将序列每次折半划分。<br>（2）“合并”——将划分后的序列段两两合并后排序。</p>
<p><strong>算法步骤</strong></p>
<p>(1)申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</p>
<p>(2)设定两个指针，最初位置分别为两个已经排序序列的起始位置；</p>
<p>(3)比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</p>
<p>(4)重复步骤 3 直到某一指针达到序列尾；</p>
<p>(5)将另一序列剩下的所有元素直接复制到合并序列尾。</p>
<p><strong>话不多说，上代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring &gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//归并过程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> help[r-l+<span class="number">1</span>];<span class="comment">//辅助数组</span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> lIndex = l;</span><br><span class="line">	<span class="keyword">int</span> rIndex = mid+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(lIndex &lt;= mid &amp;&amp; rIndex &lt;= r)&#123;</span><br><span class="line">		help[i++] = arr[lIndex] &lt; arr[rIndex] ? arr[lIndex++]:arr[rIndex++];</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//左边和右边肯定有一边到头了，不可能同时，因为每次只移动一边</span></span><br><span class="line">	<span class="keyword">while</span>(lIndex &lt;= mid)&#123;</span><br><span class="line">		help[i++] = arr[lIndex++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(rIndex &lt;= r)&#123;</span><br><span class="line">		help[i++] = arr[rIndex++];</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//将排好序的辅助数组赋值给原始数组，不需要返回值</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; r-l+<span class="number">1</span>; i++)&#123;</span><br><span class="line">		arr[l+i] = help[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">msort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//左半部分归并排序</span></span><br><span class="line">	<span class="built_in">msort</span>(arr, l, mid);</span><br><span class="line">    <span class="comment">//右半部分归并排序</span></span><br><span class="line">	<span class="built_in">msort</span>(arr, mid+<span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">//左右部分归并</span></span><br><span class="line">	<span class="built_in">merge</span>(arr, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序整个数组</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">msort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果数组为空或只有一个元素，不需要排序</span></span><br><span class="line">	<span class="keyword">if</span>(arr == <span class="literal">NULL</span> || n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">msort</span>(arr,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arry[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        cin&gt;&gt;arry[i];</span><br><span class="line">    <span class="built_in">msort</span>(arry, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        cout&lt;&lt;arry[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>c++</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>排序之快速排序</title>
    <url>/2019/11/24/%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="快排及快速排序，是排序算法中比较快速常用的一种排序方式"><a href="#快排及快速排序，是排序算法中比较快速常用的一种排序方式" class="headerlink" title="快排及快速排序，是排序算法中比较快速常用的一种排序方式"></a>快排及快速排序，是排序算法中比较快速常用的一种排序方式</h3><span id="more"></span>

<h2 id="一-基本原理"><a href="#一-基本原理" class="headerlink" title="一 基本原理"></a>一 基本原理</h2><h5 id="快速排序的根本可以说就是通过分治法来实现，简单举一个例子来理解一下快速排序的过程。"><a href="#快速排序的根本可以说就是通过分治法来实现，简单举一个例子来理解一下快速排序的过程。" class="headerlink" title="快速排序的根本可以说就是通过分治法来实现，简单举一个例子来理解一下快速排序的过程。"></a>快速排序的根本可以说就是通过分治法来实现，简单举一个例子来理解一下快速排序的过程。</h5><p> 我们现在对（56，28，45，93，10，32，44，95，60，58）进行排序。首先我们定义三个量，i，j，flag。i是数组第一个值的下表即i=0。j是数组最后一个值的下表即j=9，flag就是数组的第一个值即flag=56，现在我们要做的就是讲这个数组中所有比flag小的数放到他的前面，把所有比flag大的数放到他的后面。</p>
<ul>
<li><p>第一步从j开始向左（前）找，找到第一个比flag小的数，是下标为6的数44，我们就将44与flag56进行交换从而使数组变成（44，28，45，93，10，32，56，95，60，58），此时的j=6</p>
</li>
<li><p>第二步从i开始向右（后）找，找到第一个比flag大的数，是下标为3的数93，我们就将93与flag56进行交换从而使数组变成（44，28，45，56，10，32，93，95，60，58），此时的i=3</p>
</li>
<li><p>第三步继续从j（此时j=6）开始向左找，找到比flag小的数，是下标为5的数32，我们将32与flag进行交换，得到数组（44，28，45，32，10，56，93，95，60，58），此时j=5</p>
</li>
<li><p>第四步从i（此时i=3）开始向右找，找到比flag大的数，直到i=j,我们发现在j之前已经找不到比flag更大的数，此时快速排序的第一轮就已经结束，这个时候在flag之前的数都是比他小的，在他之后都是比他大的，我们再将flag前后两片区域重新定义成新的无序的数组，分别对他们重复刚才的过程，直到分解到每个重新划分的区域内只有一个值，排序就算完成了。我们直接将过程贴在下面</p>
<pre><code>（44，28，45，32，10）（56）（93，95，60，58）

（10，28，45，32，44）（56）（58，95，60，93）

（10，28，44，32，45）（56）（58，93，60，95）

（10，28，32，44，45）（56）（58，60，93，95）

（10，28，32）（44）（45）（56）（58）（60）（93）（95）

（10）（28）（32）（44）（45）（56）（58）（60）（93）（95）</code></pre></li>
</ul>
<p>排序结束</p>
<h2 id="二-稳定性问题"><a href="#二-稳定性问题" class="headerlink" title="二 稳定性问题"></a>二 稳定性问题</h2><p>&emsp;&emsp;首先大家应该都知道快速排序是一个不稳定排序算法，那么到底什么才是排序的稳定性呢，我认为通俗的讲有两个相同的数A和B，在排序之前A在B的前面，而经过排序之后，B跑到了A的前面，对于这种情况的发生，我们管他叫做排序的不稳定性，而快速排序在对存在相同数进行排序时就有可能发生这种情况。</p>
<p>&emsp;&emsp;例如（5，3A，6，3B）对这个进行排序，排序之前相同的数3A与3B，A在B的前面，经过排序之后会变成（3B，3A，5，6），所以说快速排序是一个不稳定的排序</p>
<p>三 时间复杂度</p>
<p>== 简单的总结一下快速排序的时间复杂度问题 ==</p>
<ul>
<li><p>最优情况:每一次的flag刚好都可以平分整个数组，此时的时间复杂度为O(nlogn)</p>
</li>
<li><p>最坏情况:每一次的flag刚好都是最大或者最小的数，此时的时间复杂度为O(n2)</p>
</li>
<li><p>平均情况:经过推到平均情况为O(nlogn)</p>
</li>
</ul>
<h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*qsort 快速排序</span></span><br><span class="line"><span class="comment">*@auther wyt</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">200</span>];</span><br><span class="line"><span class="comment">//定义快排函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, mid, t;</span><br><span class="line">	i = l;</span><br><span class="line">	j = r;</span><br><span class="line">	mid = a[(l + r) / <span class="number">2</span>];</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (a[i] &lt; mid) i++;		<span class="comment">//寻找左边小于mid的数</span></span><br><span class="line">		<span class="keyword">while</span> (a[j] &gt; mid) j--;     <span class="comment">//寻找右边小于mid的数</span></span><br><span class="line">		<span class="keyword">if</span> (i &lt;= j) &#123;</span><br><span class="line">			t = a[i];		        <span class="comment">//进行数值交换</span></span><br><span class="line">			a[i] = a[j];</span><br><span class="line">			a[j] = t;</span><br><span class="line">			i++;			        <span class="comment">//继续寻找</span></span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (i &lt;= j);</span><br><span class="line">	<span class="keyword">if</span> (j &gt; l) <span class="built_in">qsort</span>(l, j);			<span class="comment">//继续快排左右子序列</span></span><br><span class="line">	<span class="keyword">if</span> (i &lt; r) <span class="built_in">qsort</span>(i, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">	<span class="built_in">qsort</span>(<span class="number">1</span>, n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><del>~ PS ~</del></p>
<ul>
<li><p>C++中有自带的快排库(<algorithm>)，用法：sort(*array+left , *array+right)</p>
</li>
<li><p>C中的库是在(&lt;stdlib.h&gt;)中<br>用法：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">qsort</span>(a, <span class="number">1000</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>), cmp);</span><br><span class="line"><span class="comment">//其中cmp函数应写为：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">int</span>*)a - *(<span class="keyword">int</span>*)b; <span class="comment">//由小到大排序</span></span><br><span class="line">    <span class="comment">//return *(int *)b - *(int *)a; 由大到小排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>c++</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>排序入坑之冒泡</title>
    <url>/2019/11/11/%E6%8E%92%E5%BA%8F%E5%85%A5%E5%9D%91%E4%B9%8B%E5%86%92%E6%B3%A1/</url>
    <content><![CDATA[<h3 id="算法入坑第一步，冒泡排序。"><a href="#算法入坑第一步，冒泡排序。" class="headerlink" title="算法入坑第一步，冒泡排序。"></a>算法入坑第一步，冒泡排序。</h3><p>搜索算法是我们学习过程中必不可少的一步，其实理解以后，它也没有那么难…来先看个冒泡吧</p>
<span id="more"></span>
<h5 id="冒泡算法"><a href="#冒泡算法" class="headerlink" title="冒泡算法"></a>冒泡算法</h5><p><strong>如果遇到相等的值不进行交换，那这种排序方式是稳定的排序方式。</strong></p>
<p>原理：比较两个相邻的元素，将值大的元素交换到右边</p>
<p>思路：依次比较相邻的两个数，将比较小的数放在前面，比较大的数放在后面。</p>
<ul>
<li><p>第一次比较：首先比较第一和第二个数，将小数放在前面，将大数放在后面。</p>
</li>
<li><p>比较第2和第3个数，将小数 放在前面，大数放在后面。</p>
<p>  ……</p>
</li>
<li><p>如此继续，知道比较到最后的两个数，将小数放在前面，大数放在后面，重复步骤，直至全部排序完成</p>
</li>
<li><p>在上面一趟比较完成后，最后一个数一定是数组中最大的一个数，所以在比较第二趟的时候，最后一个数是不参加比较的。</p>
</li>
<li><p>在第二趟比较完成后，倒数第二个数也一定是数组中倒数第二大数，所以在第三趟的比较中，最后两个数是不参与比较的。</p>
</li>
<li><p>依次类推，每一趟比较次数减少依次</p>
</li>
</ul>
<p>举例：</p>
<p>　　　　(1)要排序数组:[10,1,35,61,89,36,55]<br>　　　　(2)第一趟排序：</p>
<p>　　　　　　第一次排序：10和1比较，10大于1，交换位置 　　 　  [1,10,35,61,89,36,55]</p>
<p>　　　　　　第二次排序：10和35比较，10小于35，不交换位置　　[1,10,35,61,89,36,55]</p>
<p>　　　　　　第三次排序：35和61比较，35小于61，不交换位置　　[1,10,35,61,89,36,55]</p>
<p>　　　　　　第四次排序：61和89比较，61小于89，不交换位置　　[1,10,35,61,89,36,55]</p>
<p>　　　　　　第五次排序：10和1比较，10大于1，交换位置 　　 　  [1,10,35,61,89,36,55]</p>
<p>　　　　　　第六次排序：89和55比较，89大于55，交换位置　　　[1,10,35,61,36,55,89]</p>
<p>　　　　　　第一趟总共进行了六次比较，排序结果：[1,10,35,61,36,55,89]</p>
<p>　　　　(3)第二趟排序：</p>
<p>　　　　　　第一次排序：1和10比较，1小于10，不交换位置　　[1,10,35,61,36,55,89]</p>
<p>　　　　　　第二次排序：10和35比较，10小于35，不交换位置    [1,10,35,61,36,55,89]</p>
<p>　　　　　　第三次排序：35和61比较，35小于61，不交换位置     [1,10,35,61,36,55,89]</p>
<p>　　　　　　第四次排序：61和36比较，61大于36，交换位置　　　[1,10,35,36,61,55,89]</p>
<p>　　　　　　第五次排序：61和55比较，61大于55，交换位置　　　[1,10,35,36,55,61,89]</p>
<p>　　　　　　第二趟总共进行了5次比较，排序结果：[1,10,35,36,55,61,89]</p>
<p>　　　　(4)第三趟排序：</p>
<p>　　　　　　第一次排序：1和10比较，1小于10，不交换位置　　[1,10,35,36,55,61,89]</p>
<p>　　　　　　第二次排序：10和35比较，10小于35，不交换位置    [1,10,35,36,55,61,89]</p>
<p>　　　　　　第三次排序：35和36比较，35小于36，不交换位置     [1,10,35,36,55,61,89]</p>
<p>　　　　　　第四次排序：36和61比较，36小于61，不交换位置　　　1,10,35,36,55,61,89</p>
<p>　　　　　　第三趟总共进行了4次比较，排序结果：1,10,35,36,55,61,89</p>
<p>　　　　　　到目前位置已经为有序的情形了。　　　　</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span>    <span class="comment">//下面是函数sort的程序 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,temp;    <span class="comment">//定义三个整型变量 </span></span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;n<span class="number">-1</span>;j++)    <span class="comment">//用一个嵌套循环来遍历一遍每一对相邻元素 （所以冒泡函数慢嘛，时间复杂度高）  </span></span><br><span class="line">    &#123;                           </span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>-j;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;a[i+<span class="number">1</span>])  <span class="comment">//从大到小排就把左边的&quot;&gt;&quot;改为&quot;&lt;&quot;</span></span><br><span class="line">            &#123;</span><br><span class="line">                temp=a[i];      <span class="comment">//a[i]与a[i+1](即a[i]后面那个) 交换</span></span><br><span class="line">                a[i]=a[i+<span class="number">1</span>];    <span class="comment">//基本的交换原理&quot;c=a;a=b;b=c&quot; </span></span><br><span class="line">                a[i+<span class="number">1</span>]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.算法分析：</p>
<p>　　　　(1)由此可见：N个数字要排序完成，总共进行N-1趟排序，每i趟的排序次数为(N-i)次，所以可以用双重循环语句，外层控制循环多少趟，内层控制每一趟的循环次数</p>
<p>　　　　(2)冒泡排序的优点：每进行一趟排序，就会少比较一次，因为每进行一趟排序都会找出一个较大值。如上例：第一趟比较之后，排在最后的一个数一定是最大的一个数，第二趟排序的时候，只需要比较除了最后一个数以外的其他的数，同样也能找出一个最大的数排在参与第二趟比较的数后面，第三趟比较的时候，只需要比较除了最后两个数以外的其他的数，以此类推……也就是说，没进行一趟比较，每一趟少比较一次，一定程度上减少了算法的量。<br>　　　　<br>　　　　(3)时间复杂度</p>
<p>　　　　1.如果我们的数据正序，只需要走一趟即可完成排序。所需的比较次数C和记录移动次数M均达到最小值，即：Cmin=n-1;Mmin=0;所以，冒泡排序最好的时间复杂度为O(n)。</p>
<p>　　　　2.如果很不幸我们的数据是反序的，则需要进行n-1趟排序。每趟排序要进行n-i次比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：</p>
<p>　　　　　　综上所述：冒泡排序总的平均时间复杂度为：O(n2) ,时间复杂度和数据状况无关。</p>
]]></content>
      <tags>
        <tag>c++</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>排序之选择排序</title>
    <url>/2019/11/13/%E6%8E%92%E5%BA%8F%E4%B9%8B%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<ul>
<li>简单选择排序是交换排序类型的一种，其排序思想为：每趟从待排序的记录中选出关键字最小的记录，顺序放在已排序的记录序列末尾，直到全部排序结束为止。</li>
<li>简单选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。</li>
</ul>
<span id="more"></span>

<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>重复第二步，直到所有元素均排序完毕。</li>
</ol>
<h3 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif" class="lazyload" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="简单选择排序"></p>
<h3 id="数据处理流程"><a href="#数据处理流程" class="headerlink" title="数据处理流程"></a>数据处理流程</h3><p><img src="https://images2015.cnblogs.com/blog/318837/201604/318837-20160422104021288-937621481.png" class="lazyload" data-srcset="https://images2015.cnblogs.com/blog/318837/201604/318837-20160422104021288-937621481.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="简单选择排序"></p>
<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><hr>
<p><img src="https://images.cnblogs.com/cnblogs_com/TongWY/1887991/o_201124155411%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202020-11-24%20235355.png" class="lazyload" data-srcset="https://images.cnblogs.com/cnblogs_com/TongWY/1887991/o_201124155411%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202020-11-24%20235355.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<hr>
<h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><ul>
<li>简单选择排序的比较次数与序列的初始排序无关。 假设待排序的序列有 N 个元素，则比较次数总是<strong>N (N - 1)/2</strong>。</li>
<li>而移动次数与序列的初始排序有关。当序列正序时，移动次数最少，为 0.</li>
<li>当序列反序时，移动次数最多，为3N(N-1)/2。</li>
<li>所以，综合以上，简单排序的时间复杂度为 <strong>O(N2)</strong>。 </li>
</ul>
<hr>
<h5 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h5><ul>
<li>简单选择排序需要占用 <strong>1</strong> 个临时空间，在交换数值时使用。</li>
</ul>
<h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择排序函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; len - <span class="number">1</span> ; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; len; j++)     <span class="comment">//查找未排序的元素</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[min])    <span class="comment">//寻找最小值</span></span><br><span class="line">                min = j;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[min];</span><br><span class="line">        arr[min]= arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>c++</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>素数，他，他又来了</title>
    <url>/2019/11/10/%E7%B4%A0%E6%95%B0%EF%BC%8C%E4%BB%96%EF%BC%8C%E4%BB%96%E5%8F%88%E6%9D%A5%E4%BA%86/</url>
    <content><![CDATA[<p>是他，是他，就是他，我们的…咳咳，走错片场了。一大堆素数朝你涌来，感谢埃拉托斯特尼，感谢欧拉(其实一点也不╮(╯▽╰)╭)</p>
<span id="more"></span>

<p>上次实际上是对单个数进行判断是否为素数，但是如果我们有一大堆素数，还用上次的方法的话，那么，，，一定很有趣。好吧我就直接说了，一大堆数进行判断，一个一个的进行循环无疑是很浪费时间的，那么我们就可以构建一个素数表，只需要判断一堆数是否在素数表里就可以了。</p>
<p>有请第一位嘉宾——埃拉托斯特尼筛法(简称埃氏筛法)</p>
<h3 id="埃氏筛法"><a href="#埃氏筛法" class="headerlink" title="埃氏筛法"></a>埃氏筛法</h3><p>首先，我们将2到n范围内的所有整数写下来。其中最小的数字2是素数。将表中所有2的倍数都划去。表中剩余的最小数字是3，它不能被更小的数整除，所以是素数。再将表中所有3的倍数都划去。依此类推，如果表中剩余的最小数字是m时，m就是素数。然后将表中所有m的倍数都化去。像这样反复操作，就能依次枚举n以内的素数。</p>
<p>话不多说，上代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> u[MAXN];			<span class="comment">//定义一个筛子</span></span><br><span class="line"><span class="keyword">int</span> su[MAXN], num = <span class="number">0</span>;	<span class="comment">//定义一个素数表及表的长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;		<span class="comment">//埃氏筛法函数</span></span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; MAXN; i++)		<span class="comment">//进行数组初始化</span></span><br><span class="line">		u[i] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; MAXN; i++)			<span class="comment">//从2到MAXN进行循环</span></span><br><span class="line">		<span class="keyword">if</span> (u[i]) &#123;						<span class="comment">//一旦u[i]是素数，那么筛去它小于MAXN的所有倍数</span></span><br><span class="line">			<span class="keyword">for</span> (j = <span class="number">2</span>; i * j &lt; MAXN; j++)</span><br><span class="line">				u[i * j] = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; MAXN; i++)			<span class="comment">//将筛出的素数填入素数表中</span></span><br><span class="line">		<span class="keyword">if</span> (u[i])</span><br><span class="line">			su[++num] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面埃氏筛法中，大家有没有发现一个问题</p>
<p>最小的素数是2，那么2的整数倍都不是素数，删去4,6,8…余下的数里，最小的素数是3，删去6,9,12…最终未被删去的数就是素数。但，这样在效率上有一个问题：一个数会被删去多次。例如42会被2 3 7都删去一遍，其时间复杂度为O(NlogNlogN)，，，所以，，，</p>
<h3 id="有请欧拉上场"><a href="#有请欧拉上场" class="headerlink" title="有请欧拉上场"></a>有请欧拉上场</h3><p>对每个合数a×b，它会被每个质因数都筛去一遍，但我们只要用最小的质因数筛去就好了为此，我们需要记录下所产生的全部素数，上代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> u[MAXN];        <span class="comment">//筛子</span></span><br><span class="line"><span class="keyword">int</span> su[MAXN],num=<span class="number">0</span>;       <span class="comment">//创建素数表及表长</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eulerSieve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(u,<span class="literal">true</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(u));       <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;=MAXN; i++)&#123;         <span class="comment">//顺序分析区间表中的每个数</span></span><br><span class="line">        <span class="keyword">if</span>(u[i])</span><br><span class="line">            su[++num]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=num; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i*su[j]&gt;MAXN)        <span class="comment">//如果i与当前素数的乘积大于MAXN，则跳过</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            u[i*su[j]]=<span class="literal">false</span>;       <span class="comment">//素数的倍数必为非素数，筛去</span></span><br><span class="line">            <span class="keyword">if</span>(i%su[j]==<span class="number">0</span>)          <span class="comment">//如果su[j]是i的最小素数，则进行下一个i的判断</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心就是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(i%su[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>如果i能整除su[k]，说明su[k]是i的因子，所以su[k]也是i的任意倍数的因子。所以su[k]也是i×su[x] (x&gt;k)的因子。考虑到primelist单增，对i×su[x]，su[k]就是它的比su[x]更小的因子。故不用考虑其后的质因子了（i×su[x]会被su[k]作为因子在i更大时被筛掉）</p>
]]></content>
      <tags>
        <tag>c++</tag>
        <tag>素数</tag>
      </tags>
  </entry>
</search>
