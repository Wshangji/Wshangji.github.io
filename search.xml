<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>面向对象(2)</title>
    <url>/2020/03/22/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-2/</url>
    <content><![CDATA[<p><strong>对于一个类来说，一般有三种常见的成员：属性field、构造器constructor、方法method。这三种成员都可以定义零个或多个</strong></p>
<a id="more"></a>

<h3 id="属性-field，或者叫成员变量"><a href="#属性-field，或者叫成员变量" class="headerlink" title="属性(field，或者叫成员变量)"></a>属性(field，或者叫成员变量)</h3><p>属性用于定义该类或该类对象包含的数据或者说静态特征。属性作用范围是整个类体。</p>
<p>在定义成员变量时可以对其初始化，如果不对其初始化，Java使用默认的值对其初始化。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>方法用于定义该类或该类实例的行为特征和功能实现。方法是类和对象行为特征的抽象。方法很类似于面向过程中的函数。面向过程中，函数是最基本单位，整个程序由一个个函数调用组成。面向对象中，整个程序的基本单位是类，方法是从属于类和对象的</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>构造器也叫构造方法(constructor)，用于对象的初始化。构造器是一个创建对象时被自动调用的特殊方法，目的是对象的初始化。构造器的名称应与类的名称一致。Java通过new关键字来调用构造器，从而返回该类的实例，是一种特殊的方法。</p>
<p><strong>要点：</strong></p>
<ul>
<li>通过new关键字调用!!</li>
<li>构造器虽然有返回值，但是不能定义返回值类型(返回值的类型肯定是本类)，不能在构造器里使用return返回某个值。</li>
<li>如果我们没有定义构造器，则编译器会自动定义一个无参的构造函数。如果已定义则编译器不会自动添加!</li>
<li>构造器的方法名必须和类名一致!</li>
<li>构造器也和其它方法一致，可以重载</li>
</ul>
<h3 id="参数传值机制"><a href="#参数传值机制" class="headerlink" title="参数传值机制"></a>参数传值机制</h3><p>Java中，方法中所有参数都是“值传递”，也就是“传递的是值的副本”。 也就是说，我们得到的是“原参数的复印件，而不是原件”。因此，复印件改变不会影响原件。</p>
<p><strong>- 基本数据类型参数的传值</strong></p>
<p>传递的是值的副本。 副本改变不会影响原件。</p>
<p><strong>· 引用类型参数的传值</strong></p>
<p>传递的是值的副本。但是引用类型指的是“对象的地址”。因此，副本和原参数都指向了同一个“地址”，改变“副本指向地址对象的值，也意味着原参数指向对象的值也发生了改变”</p>
<h3 id="包-package"><a href="#包-package" class="headerlink" title="包(package)"></a>包(package)</h3><p>包机制是Java中管理类的重要手段。 开发中，我们会遇到大量同名的类，通过包我们很容易对解决类重名的问题，也可以实现对类的有效管理。 包对于类，相当于文件夹对于文件的作用。</p>
<p>我们通过package实现对类的管理，package的使用有两个要点：</p>
<ol>
<li>通常是类的第一句非注释性语句。</li>
<li>包名：域名倒着写即可，再加上模块名，便于内部管理类。</li>
</ol>
<p><strong>注意</strong></p>
<ol>
<li><p>写项目时都要加包，不要使用默认包。</p>
</li>
<li><p><code>com.gao</code>和<code>com.gao.car</code>，这两个包没有包含关系，是两个完全独立的包。只是逻辑上看起来后者是前者的一部分。</p>
</li>
</ol>
<h3 id="导入类-import"><a href="#导入类-import" class="headerlink" title="导入类(import)"></a>导入类(import)</h3><p>如果我们要使用其他包的类，需要使用import导入，从而可以在本类中直接通过类名来调用，否则就需要书写类的完整包名和类名。import后，便于编写代码，提高可维护性。</p>
<p><strong>注意要点：</strong></p>
<p> 　1. Java会默认导入java.lang包下所有的类，因此这些类我们可以直接使用。</p>
<p> 　2. 如果导入两个同名的类，只能用包名+类名来显示调用相关类：　</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象(1)</title>
    <url>/2020/03/21/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-1/</url>
    <content><![CDATA[<h3 id="面向过程与面向对象"><a href="#面向过程与面向对象" class="headerlink" title="面向过程与面向对象"></a>面向过程与面向对象</h3><p>面向过程(Procedure Oriented)和面向对象(Object Oriented,OO)都是对软件分析、设计和开发的一种思想,它指导着人们以不同的方式去分析、设计和开发软件。早期先有面向过程思想，随着软件规模的扩大，问题复杂性的提高，面向过程的弊端越来越明显的显示出来，出现了面向对象思想并成为目前主流的方式。两者都贯穿于软件分析、设计和开发各个阶段，对应面向对象就分别称为面向对象分析( OOA )、面向对象设计(OOD)和面向对象编程(OOP)。C语言是一种典型的面向过程语言，Java是一种典型的面向对象语言</p>
<a id="more"></a>

<p><strong>面向过程</strong></p>
<p>面向过程思想思考问题时，我们首先思考“怎么按步骤实现?”并将步骤对应成方法，一步一步，最终完成。 这个适合简单任务，不需要过多协作的情况下。比如，如何开车?我们很容易就列出实现步骤：</p>
<ol>
<li>发动车 2. 挂挡 3.踩油门 4. 走你</li>
</ol>
<p>面向过程适合简单、不需要协作的事务。 但是当我们思考比较复杂的问题，比如“如何造车?”，就会发现列出1234这样的步骤，是不可能的。那是因为，造车太复杂，需要很多协作才能完成。此时面向对象思想就应运而生了。</p>
<p><strong>面向对象</strong></p>
<p>面向对象(Object)思想更契合人的思维模式。我们首先思考的是“怎么设计这个事物?” 比如思考造车，我们就会先思考“车怎么设计?”，而不是“怎么按步骤造车的问题”。这就是思维方式的转变。</p>
<p>面向对象思想思考造车，发现车由如下对象组成：</p>
<ol>
<li>轮胎</li>
<li>发动机</li>
<li>车壳</li>
<li>座椅</li>
<li>挡风玻璃</li>
</ol>
<p>为了便于协作，我们找轮胎厂完成制造轮胎的步骤，发动机厂完成制造发动机的步骤;这样，发现大家可以同时进行车的制造，最终进行组装，大大提高了效率。但是，具体到轮胎厂的一个流水线操作，仍然是有步骤的，还是离不开面向过程思想</p>
<p>因此，面向对象可以帮助我们从宏观上把握、从整体上分析整个系统。 但是，具体到实现部分的微观操作(就是一个个方法)，仍然需要面向过程的思路去处理。</p>
<p><strong>总结</strong></p>
<ul>
<li>面向对象与面向对象是相辅相成的，面向对象离不开面向过程</li>
<li>都是解决问题的思维方式，都是代码组织的方式</li>
<li>解决简单问题可以使用面向过程</li>
<li>解决复杂问题：宏观上使用面向对象把握，微观处理上仍然是面向过程</li>
</ul>
<p><del>和做饭神似，呸，你在FP</del></p>
<p> 面向对象是盖浇饭、面向过程是蛋炒饭。盖浇饭的好处就是“菜”“饭”分离，从而提高了制作盖浇饭的灵活性。饭不满意就换饭，菜不满意换菜。用软件工程的专业术语就是“可维护性”比较好，“饭” 和“菜”的耦合度比较低</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Math类与Random类常用方法</title>
    <url>/2020/02/29/Math%E7%B1%BB%E4%B8%8ERandom%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><em>Java提供的常用类中，Math类为常用的数学计算方法，Random类为常用的随机生成方法</em></p>
<a id="more"></a>

<h2 id="Math类方法"><a href="#Math类方法" class="headerlink" title="Math类方法"></a>Math类方法</h2><p>abs 绝对值</p>
<p>acos,asin,atan,cos,sin,tan 三角函数</p>
<p>sqrt 平方根</p>
<p>pow(double a, double b) a的b次幂</p>
<p>max(double a, double b) 取大值</p>
<p>min(double a, double b) 取小值</p>
<p>ceil(double a) 大于a的最小整数</p>
<p>floor(double a) 小于a的最大整数</p>
<p>random() 返回 0.0 到 1.0 的随机数</p>
<p>long round(double a) double型的数据a转换为long型(四舍五入)</p>
<p>toDegrees(double angrad) 弧度-&gt;角度</p>
<p>toRadians(double angdeg) 角度-&gt;弧度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMath</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//取整相关操作</span></span><br><span class="line">        System.out.println(Math.ceil(<span class="number">3.2</span>));</span><br><span class="line">        System.out.println(Math.floor(<span class="number">3.2</span>));</span><br><span class="line">        System.out.println(Math.round(<span class="number">3.2</span>));</span><br><span class="line">        System.out.println(Math.round(<span class="number">3.8</span>));</span><br><span class="line">        <span class="comment">//绝对值、开方、a的b次幂等操作</span></span><br><span class="line">        System.out.println(Math.abs(-<span class="number">45</span>));</span><br><span class="line">        System.out.println(Math.sqrt(<span class="number">64</span>));</span><br><span class="line">        System.out.println(Math.pow(<span class="number">5</span>, <span class="number">2</span>));</span><br><span class="line">        System.out.println(Math.pow(<span class="number">2</span>, <span class="number">5</span>));</span><br><span class="line">        <span class="comment">//Math类中常用的常量</span></span><br><span class="line">        System.out.println(Math.PI);</span><br><span class="line">        System.out.println(Math.E);</span><br><span class="line">        <span class="comment">//随机数</span></span><br><span class="line">        System.out.println(Math.random());<span class="comment">// [0,1)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Random方法"><a href="#Random方法" class="headerlink" title="Random方法"></a>Random方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRandom</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">//随机生成[0,1)之间的double类型的数据</span></span><br><span class="line">        System.out.println(rand.nextDouble());</span><br><span class="line">        <span class="comment">//随机生成int类型允许范围之内的整型数据</span></span><br><span class="line">        System.out.println(rand.nextInt());</span><br><span class="line">        <span class="comment">//随机生成[0,1)之间的float类型的数据</span></span><br><span class="line">        System.out.println(rand.nextFloat());</span><br><span class="line">        <span class="comment">//随机生成false或者true</span></span><br><span class="line">        System.out.println(rand.nextBoolean());</span><br><span class="line">        <span class="comment">//随机生成[0,10)之间的int类型的数据</span></span><br><span class="line">        System.out.print(rand.nextInt(<span class="number">10</span>));</span><br><span class="line">        <span class="comment">//随机生成[20,30)之间的int类型的数据</span></span><br><span class="line">        System.out.print(<span class="number">20</span> + rand.nextInt(<span class="number">10</span>));</span><br><span class="line">        <span class="comment">//随机生成[20,30)之间的int类型的数据（此种方法计算较为复杂）</span></span><br><span class="line">        System.out.print(<span class="number">20</span> + (<span class="keyword">int</span>) (rand.nextDouble() * <span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>内部类</title>
    <url>/2020/02/24/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="内部类的概念"><a href="#内部类的概念" class="headerlink" title="内部类的概念"></a>内部类的概念</h2><p>一般情况，我们把类定义成独立的单元。有些情况下，我们把一个类放在另一个类的内部定义，称为内部类(innerclasses)。</p>
<a id="more"></a>
<p>内部类可以使用public、default、protected 、private以及static修饰。而外部顶级类(我们以前接触的类)只能使用public和default修饰。</p>
<p><strong>注意</strong></p>
<p>内部类只是一个编译时概念，一旦我们编译成功，就会成为完全不同的两个类。编译完成后会出现两个类的字节码文件。所以内部类是相对独立的一种存在，其成员变量/方法名可以和外部类的相同</p>
<h4 id="内部类的作用"><a href="#内部类的作用" class="headerlink" title="内部类的作用"></a>内部类的作用</h4><ol>
<li><p>内部类提供了更好的封装，只能让外部类直接访问，不允许同一个包中的其它类直接访问。</p>
</li>
<li><p>内部类可以直接访问外部类的私有属性，内部类被当成其外部类的成员。但外部类不能访问内部类的内部属性。</p>
</li>
<li><p>接口只是解决了多重继承的部分问题，而内部类使得多重继承的解决方案变得更加完善。</p>
</li>
</ol>
<h4 id="内部类的使用场景"><a href="#内部类的使用场景" class="headerlink" title="内部类的使用场景"></a>内部类的使用场景</h4><ol>
<li>由于内部类提供了更好的封装特性，并且可以很方便的访问外部类的属性。所以，在只为外部类提供服务的情况下可以优先考虑内部类</li>
<li>内部类的使用可以间接的实现多继承，每个内部类都能独立的继承一个类或者实现某些接口，所以无论外部类是否已经继承了某个类或者实现了某些接口，对于内部类没有任何影响</li>
</ol>
<h2 id="内部类的分类"><a href="#内部类的分类" class="headerlink" title="内部类的分类"></a>内部类的分类</h2><p>在Java中内部类主要分为成员内部类(非静态内部类、静态内部类)、匿名内部类、局部内部类。<br>.成员内部类(可以使用private、default、protected、public任意进行修饰。 类文件：外部类$内部类.class)</p>
<h4 id="非静态内部类-外部类里使用非静态内部类和平时使用其他类没什么不同"><a href="#非静态内部类-外部类里使用非静态内部类和平时使用其他类没什么不同" class="headerlink" title="非静态内部类(外部类里使用非静态内部类和平时使用其他类没什么不同)"></a>非静态内部类(外部类里使用非静态内部类和平时使用其他类没什么不同)</h4><p> i. 非静态内部类必须寄存在一个外部类对象里。因此，如果有一个非静态内部类对象那么一定存在对应的外部类对象。非静态内部类对象单独属于外部类的某个对象。</p>
<p>ii. 非静态内部类可以直接访问外部类的成员，但是外部类不能直接访问非静态内部类成员。</p>
<p>iii. 非静态内部类不能有静态方法、静态属性和静态初始化块。</p>
<p>iv. 外部类的静态方法、静态代码块不能访问非静态内部类，包括不能使用非静态内部类定义变量、创建实例。</p>
<p>v. 成员变量访问特点：</p>
<ol>
<li><p>内部类里方法的局部变量：变量名。</p>
</li>
<li><p>内部类属性：this.变量名。</p>
</li>
<li><p>外部类属性：外部类名.this.变量名。</p>
</li>
</ol>
<h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> age = <span class="number">30</span>;</span><br><span class="line">            System.out.println(<span class="string">"内部类方法里的局部变量age:"</span> + age);<span class="comment">// 30</span></span><br><span class="line">            System.out.println(<span class="string">"内部类的成员变量age:"</span> + <span class="keyword">this</span>.age);<span class="comment">// 20</span></span><br><span class="line">            System.out.println(<span class="string">"外部类的成员变量age:"</span> + Outer.<span class="keyword">this</span>.age);<span class="comment">// 10</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>内部类访问</strong></p>
<ul>
<li>外部类中访问内部类：<code>new Inner()</code></li>
<li>外部类以外的地方访问非静态内部类： <code>Outer.Inner varname = new Outer().new Inner()。</code></li>
</ul>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><h5 id="使用要点"><a href="#使用要点" class="headerlink" title="使用要点"></a>使用要点</h5><ol>
<li><p>当一个静态内部类对象存在，并不一定存在对应的外部类对象。 因此，静态内部类的实例方法不能直接访问外部类的实例方法。</p>
</li>
<li><p>静态内部类看做外部类的一个静态成员。 因此，外部类的方法中可以通过：“静态内部类.名字”的方式访问静态内部类的静态成员，通过 new 静态内部类()访问静态内部类的实例。</p>
</li>
</ol>
<h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="comment">//相当于外部类的一个静态成员</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStaticInnerClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过 new 外部类名.内部类名() 来创建内部类对象</span></span><br><span class="line">        Outer.Inner inner =<span class="keyword">new</span> Outer.Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>适合那种只需要使用一次的类。比如：键盘监听操作等</p>
<h5 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span>  父类构造器(实参类表) \实现接口 () &#123;</span><br><span class="line">           <span class="comment">//匿名内部类类体！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ul>
<li>匿名内部类没有访问修饰符</li>
<li>匿名内部类没有构造方法</li>
</ul>
<h5 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.addWindowListener(<span class="keyword">new</span> WindowAdapter()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosing</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"><span class="keyword">this</span>.addKeyListener(<span class="keyword">new</span> KeyAdapter()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">keyPressed</span><span class="params">(KeyEvent e)</span> </span>&#123;</span><br><span class="line">            myTank.keyPressed(e);</span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">keyReleased</span><span class="params">(KeyEvent e)</span> </span>&#123;</span><br><span class="line">            myTank.keyReleased(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>还有一种内部类，它是定义在方法内部的，作用域只限于本方法，称为局部内部类。</p>
<p>局部内部类的的使用主要是用来解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，所以就产生了局部内部类。局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法中被使用，出了该方法就会失效。</p>
<p>局部内部类在实际开发中应用很少</p>
<h5 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//作用域仅限于该方法</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"helloworld"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Inner().fun();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Test2().show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象之接口</title>
    <url>/2020/02/17/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口就是比“抽象类”还“抽象”的“抽象类”，可以更加规范的对子类进行约束。全面地专业地实现了：规范和具体实现的分离。</p>
<p>抽象类还提供某些具体实现，接口不提供任何实现，接口中所有方法都是抽象方法。接口是完全面向规范的，规定了一批类具有的公共方法规范。</p>
<a id="more"></a>
<p>从接口的实现者角度看，接口定义了可以向外部提供的服务。</p>
<p>从接口的调用者角度看，接口定义了实现者能提供那些服务。</p>
<p>接口是两个模块之间通信的标准，通信的规范。如果能把你要设计的模块之间的接口定义好，就相当于完成了系统的设计大纲，剩下的就是添砖加瓦的现了。大家在工作以后，做系统时往往就是使用“面向接口”的思想来设计系统。</p>
<p>接口和实现类不是父子关系，是实现规则的关系。比如：我定义一个接口Runnable，Car实现它就能在地上跑，Train实现它也能在地上跑，飞机实现它也能在地上跑。就是说，如果它是交通工具，就一定能跑，但是一定要实现Runnable接口。</p>
<h4 id="接口的本质"><a href="#接口的本质" class="headerlink" title="接口的本质"></a>接口的本质</h4><p>接口就是规范，定义的是一组规则，体现了现实世界中“如果你是…则必须能…”的思想。如果你是天使，则必须能飞。如果你是汽车，则必须能跑。如果你是好人，则必须能干掉坏人;如果你是坏人，则必须欺负好人。</p>
<p>接口的本质是契约，就像我们人间的法律一样。制定好后大家都遵守。</p>
<p>面向对象的精髓，是对对象的抽象，最能体现这一点的就是接口。为什么我们讨论设计模式都只针对具备了抽象能力的语言(比如C++、Java、C#等)，就是因为设计模式所研究的，实际上就是如何合理的去抽象。</p>
<h4 id="声明格式"><a href="#声明格式" class="headerlink" title="声明格式"></a>声明格式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[访问修饰符]  interface 接口名   [extends  父接口1，父接口2…]  &#123;</span><br><span class="line">常量定义；  </span><br><span class="line">方法定义；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ol>
<li><p>访问修饰符：只能是public或默认。</p>
</li>
<li><p>接口名：和类名采用相同命名机制。</p>
</li>
<li><p>extends：接口可以多继承。</p>
</li>
<li><p>常量：接口中的属性只能是常量，总是：public static final 修饰。不写也是。</p>
</li>
<li><p>方法：接口中的方法只能是：public abstract。 省略的话，也是public abstract。</p>
</li>
</ol>
<h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><ol>
<li><p>子类通过implements来实现接口中的规范。</p>
</li>
<li><p>接口不能创建实例，但是可用于声明引用变量类型。</p>
</li>
<li><p>一个类实现了接口，必须实现接口中所有的方法，并且这些方法只能是public的。</p>
</li>
<li><p>JDK1.7之前，接口中只能包含静态常量、抽象方法，不能有普通属性、构造方法、普通方法。</p>
</li>
<li><p>JDK1.8后，接口中包含普通的静态方法。</p>
</li>
</ol>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Volant volant = <span class="keyword">new</span> Angel();</span><br><span class="line">        volant.fly();</span><br><span class="line">        System.out.println(Volant.FLY_HIGHT);</span><br><span class="line">        Honest honest = <span class="keyword">new</span> GoodMan();</span><br><span class="line">        honest.helpOther();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**飞行接口*/</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Volant</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> FLY_HIGHT = <span class="number">100</span>;  <span class="comment">// 总是：public static final类型的；</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;   <span class="comment">//总是：public abstract void fly();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**善良接口*/</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Honest</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helpOther</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**Angle类实现飞行接口和善良接口*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Angel</span> <span class="keyword">implements</span> <span class="title">Volant</span>, <span class="title">Honest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">" 飞行 "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helpOther</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">" 嘿嘿嘿嘿 "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoodMan</span> <span class="keyword">implements</span> <span class="title">Honest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helpOther</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"i love helping"</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BirdMan</span> <span class="keyword">implements</span> <span class="title">Volant</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是Birdman"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p><code>接口完全支持多继承。和类的继承类似，子接口扩展某个父接口，将会获得父接口中所定义的一切</code></p>
<h3 id="面向接口的编程"><a href="#面向接口的编程" class="headerlink" title="面向接口的编程"></a>面向接口的编程</h3><p>面向接口编程是面向对象编程的一部分。</p>
<p>为什么需要面向接口编程? 软件设计中最难处理的就是需求的复杂变化，需求的变化更多的体现在具体实现上。我们的编程如果围绕具体实现来展开就会陷入”复杂变化”的汪洋大海中，软件也就不能最终实现。我们必须围绕某种稳定的东西开展，才能以静制动，实现规范的高质量的项目。</p>
<p>接口就是规范，就是项目中最稳定的东东! 面向接口编程可以让我们把握住真正核心的东西，使实现复杂多变的需求成为可能。</p>
<p>通过面向接口编程，而不是面向实现类编程，可以大大降低程序模块间的耦合性，提高整个系统的可扩展性和和可维护性。</p>
<p>面向接口编程的概念比接口本身的概念要大得多。设计阶段相对比较困难，在你没有写实现时就要想好接口，接口一变就乱套了，所以设计要比实现难</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java关键字之super与final</title>
    <url>/2020/02/04/Java%E5%85%B3%E9%94%AE%E5%AD%97%E4%B9%8Bsuper%E4%B8%8Efinal/</url>
    <content><![CDATA[<h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>super是直接对父类对象的引用。可以通过super来访问父类中被子类覆盖的方法或属性。使用super调用普通方法。语句没有位置限制，可以在子类中随意调用。</p>
<a id="more"></a>

<p>若是构造方法的第一行代码没有显式的调用super(…)或者this(…);那么Java默认都会调用super(),含义是调用父类的无参数构造方法。这里的super()可以省略。</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSuper01</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ChildClass().f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FatherClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        value = <span class="number">100</span>;</span><br><span class="line">        System.out.println (<span class="string">"FatherClass.value="</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span> <span class="keyword">extends</span> <span class="title">FatherClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.f();  <span class="comment">//调用父类对象的普通方法</span></span><br><span class="line">        value = <span class="number">200</span>;</span><br><span class="line">        System.out.println(<span class="string">"ChildClass.value="</span>+value);</span><br><span class="line">        System.out.println(value);</span><br><span class="line">        System.out.println(<span class="keyword">super</span>.value); <span class="comment">//调用父类对象的成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p><strong>1.修饰变量：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span>  <span class="keyword">int</span>   MAX_SPEED = <span class="number">120</span>;</span><br></pre></td></tr></table></figure>

<p><strong>2.修饰方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span>  <span class="keyword">void</span>  <span class="title">study</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.修饰类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span>   <span class="class"><span class="keyword">class</span>  <span class="title">A</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面向对象之封装</title>
    <url>/2020/02/04/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<p>封装就是把对象的属性和操作结合为一个独立的整体，并尽可能隐藏对象的内部实现细节。</p>
<a id="more"></a>
<p>我们程序设计要追求“高内聚，低耦合”。 高内聚就是类的内部数据操作细节自己完成，不允许外部干涉;低耦合是仅暴露少量的方法给外部使用，尽量方便外部调用。</p>
<p><strong>封装的优点</strong></p>
<p>提高代码的安全性。</p>
<p>提高代码的复用性。</p>
<p>“高内聚”：封装细节，便于修改内部代码，提高可维护性。</p>
<p>“低耦合”：简化外部调用，便于调用者使用，便于扩展和协作。</p>
<p><strong>封装的实现—使用访问控制符</strong></p>
<p>Java是使用“访问控制符”来控制哪些细节需要封装，哪些细节需要暴露的。 Java中4种“访问控制符”分别为private、default、protected、public，它们说明了面向对象的封装性，所以我们要利用它们尽可能的让访问权限降到最低，从而提高安全性</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>同一个类</th>
<th>同一个包</th>
<th>子类</th>
<th>所有类</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>*</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>default</td>
<td>*</td>
<td>*</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>*</td>
<td>*</td>
<td>*</td>
<td></td>
</tr>
<tr>
<td>public</td>
<td>*</td>
<td>*</td>
<td>*</td>
<td>*</td>
</tr>
</tbody></table>
<ol>
<li><p>private 表示私有，只有自己类能访问</p>
</li>
<li><p>default表示没有修饰符修饰，只有同一个包的类能访问</p>
</li>
<li><p>protected表示可以被同一个包的类以及其他包中的子类访问</p>
</li>
<li><p>public表示可以被该项目的所有包中的所有类访问</p>
</li>
</ol>
<p><strong>类的处理</strong></p>
<ol>
<li><p>一般使用private访问权限。</p>
</li>
<li><p>提供相应的get/set方法来访问相关属性，这些方法通常是public修饰的，以提供对属性的赋值与读取操作(注意：boolean变量的get方法是is开头!)。</p>
</li>
<li><p>一些只用于本类的辅助性方法可以用private修饰，希望其他类调用的方法用public修饰。</p>
</li>
</ol>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 属性一般使用private修饰</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag;</span><br><span class="line">    <span class="comment">// 为属性提供public修饰的set/get方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFlag</span><span class="params">()</span> </span>&#123;<span class="comment">// 注意：boolean类型的属性get方法是is开头的</span></span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">(<span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>世界上没那么多错过</title>
    <url>/2020/02/03/%E4%B8%96%E7%95%8C%E4%B8%8A%E6%B2%A1%E9%82%A3%E4%B9%88%E5%A4%9A%E9%94%99%E8%BF%87/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">曾经对我最重要的那个她</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="ba8cb6c7b05d54bf695eb3dc8236b924d23317a20090a1ad24bd69a3eb41d0d0">b51da61d6a7c52ded424d7f16a42f457e7a124b29fc5a75ad37375523723b91082c7282e072589f5ee6c227352cd24633a5998335e03e0ea52300f130922dfb44c3c79df979a3128129a0bbc2e5f993235cc8701c6328e9d2835f6e94efe06faaa68d8cb4940fa903eae91fa630490d7b9b1eb7b59b4bbea28200f8d926bbf08dbb17dda887d239ab14c201f1dfba516e9f921619f9abd1cea9d4a26b49c8e315770e5d72bcc46e27802c1a5f738550d6409e7e9e8c9922fe7a34412bb163013d8189eed3c4f440a03a6eed616458b5aaf73c1529f4403788295135e85371fc169ea0f34a03148c87774a205d02d227e0a6f5e92fe6d3cf5dfd515b741bac3025fdfc4d0374439de5b91d1fa7766a2cfc88c5e05371d548281a2d7b6460dabe1a7380be4b4278b5fdd8a4624dffddb24dff182729800ecc16a23a6f8a8721c40c5a2e94afb643905ff8b5691f7d44a2295c3ac105c58f2bd3f2a7e082298d3848eed60dd78d61fc4e331b5a1f9977b438d78c1e2ec2d5a83888b0cf45af55ecfcfbc3e4188b5dd55df402dfd41e0cd73d9ecea93eb9acc184ed0665683368c1671d4e773d93382f51eb75df14aa500ac10e0f86a0c24a049004d8b51526b9ac8493379febed12df804a8ad8f19b1f5dc030feb1e393df9cba253ffbe5b2f2e6801fae09a22d1583832a78a037e26424f60216e09bc5a1cddfd9d12d42b76965f76c7608dafc91bc9a494e2a2f03b393e581e6e3e9858fa8f1c150e8f6d21ba75c1396d9ea35309392ec90eb56735ea89326f4e11778b5dc7e9e90c347a5913fb8cc1cfafeb49fc9bfb55abad9734fa6bb9e2598156da8876c676c962332b18fe77bc000ff4f8007c565fef25c90582058b138aff1eda689f95f52c3c826bca90af2b7d04c356fc924bd33163d5b28069423a9d413afc3cb97a2524e5085fc741fdfd6a61e5579cfa4298eab9e75f10dcd7dc8f645ee6fe5c171eb10f6059b3c3a8c81b2cb433536289bf84f6aa4b2fdfe3e0e0d250828fad2f2a3c13ca943c7957431c4e87d78a5f405723c9b68aaa934d9f6f14767b365d301c6aa587ed4b62fc1853262a4e013630ad80caa06c5f7041b5897e9d6e522fc118e4cba17955c9af4c40d15b3e65af6ad119b16688729c92e1bad587ad4e34405c577e9722d748876facc4dd9560b33890df2ea927708a97c21f413104d2e1d9001bcf8ddb4e0b7fd16d2eb5b0228dc9dad244552a5dd8720ed06c5cdee065453cf8250d6e38895ce43aa9f9a50b819d75829df7c7a200180f6a601b6284faddfa123fb56d2a80370e5f0b521f9d426f007275c791a5c2</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>随笔</tag>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中Object类</title>
    <url>/2020/02/03/Java%E4%B8%ADObject%E7%B1%BB/</url>
    <content><![CDATA[<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p>Object类是所有Java类的根基类，也就意味着所有的Java对象都拥有Object类的属性和方法。如果在类的声明中未使用extends关键字指明其父类，则默认继承Object类。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h4><p>Object类中定义有public String toString()方法，其返回值是 String 类型。Object类中toString方法的源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据如上源码得知，默认会返回“类名+@+16进制的hashcode”。在打印输出或者用字符串连接对象时，会自动调用该对象的toString()方法。</p>
<h4 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h4><p>Object类中定义有：public boolean equals(Object obj)方法，提供定义“对象内容相等”的逻辑。比如，我们在公安系统中认为id相同的人就是同一个人、学籍系统中认为学号相同的人就是同一个人。</p>
<p>Object 的 equals 方法默认就是比较两个对象的hashcode，是同一个对象的引用时返回 true 否则返回 false。但是，我们可以根据我们自己的要求重写equals方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//equals方法重写</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEquals</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="number">123</span>,<span class="string">"王一二"</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="number">123</span>,<span class="string">"王三四"</span>);     </span><br><span class="line">        System.out.println(p1==p2);     <span class="comment">//false，不是同一个对象</span></span><br><span class="line">        System.out.println(p1.equals(p2));  <span class="comment">//true，id相同则认为两个对象内容相同</span></span><br><span class="line">        String s1 = <span class="keyword">new</span> String(<span class="string">"尚学堂"</span>);</span><br><span class="line">        String s2 = <span class="keyword">new</span> String(<span class="string">"尚学堂"</span>);</span><br><span class="line">        System.out.println(s1==s2);         <span class="comment">//false, 两个字符串不是同一个对象</span></span><br><span class="line">        System.out.println(s1.equals(s2));  <span class="comment">//true,  两个字符串内容相同</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> id,String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id=id;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">                Person c = (Person)obj;</span><br><span class="line">                <span class="keyword">if</span>(c.id==<span class="keyword">this</span>.id) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>python程序的基本格式</title>
    <url>/2020/01/31/python%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>恰当的空格，缩进问题</strong></p>
<p>　　 (1) 逻辑行首的空白(空格和制表符)用来决定逻辑行的缩进层次，从而用来决定语句的分组。</p>
<a id="more"></a>
<p>　　 (2) 语句从新行的第一列开始。</p>
<p>　　 (3) 缩进风格统一：</p>
<p>　　         ① 每个缩进层次使用 单个制表符 或四个空格(IDE会自动将制表符设置成4个空格)</p>
<p>　　         ② Python用缩进而不是{}表示程序块</p>
<p><strong>Python区分大小写</strong></p>
<p><strong>注释</strong></p>
<p>　　 (1) 行注释</p>
<p>　　     每行注释前加#号。当解释器看到#，则忽略这一行#后面的内容</p>
<p>　　 (2) 段注释</p>
<p>　　     使用三个连续单引号(‘’’)。当解释看到’’’，则会扫描到下一个’’’，然后忽略他们之间的内容。</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM、JRE和JDK</title>
    <url>/2020/01/30/JVM%E3%80%81JRE%E5%92%8CJDK/</url>
    <content><![CDATA[<p>计算机高级语言的类型主要有编译型和解释型两种，而Java 语言是两种类型的结合。<br>Java首先利用文本编辑器编写 Java源程序，源文件的后缀名为.java；再利用编译器（javac）将源程序编译成字节码文件，字节码文件的后缀名为.class； 最后利用虚拟机（解释器，java）解释执行。</p>
<a id="more"></a>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494836063440655.png" alt="Alt Java"></p>
<p>JVM(Java Virtual Machine)就是一个虚拟的用于执行bytecode字节码的”虚拟计算机”。他也定义了指令集、寄存器集、结构栈、垃圾收集堆、内存区域。JVM负责将Java字节码解释运行，边解释边运行，这样，速度就会受到一定的影响。</p>
<p>不同的操作系统有不同的虚拟机。Java 虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，随处运行”。 Java虚拟机是实现跨平台的核心机制。如图所示：<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494837984812122.png" alt="Alt JVM"></p>
<p>Java Runtime Environment (JRE) 包含：Java虚拟机、库函数、运行Java应用程序所必须的文件。</p>
<p>Java  Development Kit (JDK)包含：包含JRE，以及增加编译器和调试器等用于程序开发的文件。</p>
<p>JDK、JRE和JVM的关系如图所示。<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494837979897855.png" alt="Alt 关系图"></p>
<p>  ·如果只是要运行Java程序，只需要JRE就可以。JRE通常非常小，其中包含了JVM。</p>
<p>  ·如果要开发Java程序，就需要安装JDK。</p>
<p><strong>Java环境搭建</strong></p>
<p>下载JDK<br>    下载地址：<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">www.oracle.com/technetwork/java/javase/downloads/index.html</a></p>
<p>点击下载JDK，会出现下载列表界面。首先，点击”Accept License Agreement”，然后选择对应的版本，下载即可。</p>
<p>注意：<br>    32位操作系统只能安装32位JDK；<br>    64位操作系统可安装32位JDK，也可以安装64位JDK。</p>
<p>安装JDK</p>
<p>安装过程和普通软件安装没什么区别，过程中会让你选择JDK和JRE安装目录，采用默认即可。也就是说，通通点击“下一步”就能完成安装。<br>安装成功后我们再进入JDK的安装目录，可以看到如下的结构：<br>其中：</p>
<pre><code>bin目录是存储一些可执行的二进制文件；

lib存储相关jar包；

src.zip是JDK相关JAVA类的源代码。</code></pre><p><strong>环境变量Path的配置</strong><br>&emsp;&emsp;环境变量是在操作系统中一个具有特定名字的对象， 它包含了一个或者多个应用程序所将使用到的信息。</p>
<p>&emsp;&emsp;Path是一个常见的环境变量，它告诉操作系统，当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下寻找此程序外，还应到哪些目录下寻找。</p>
<p>设置Parh环境变量：</p>
<ol>
<li><p>右键计算机——&gt;属性——&gt;高级系统设置<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494838772220505.png" alt="Alt 1"></p>
</li>
<li><p>单击环境变量按钮<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494838780549127.png" alt="Alt 2"></p>
</li>
<li><p>单击新建按钮，新建JAVA_HOME变量（用于说明JDK的安装目录）<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494838787522279.png" alt="Alt 3"></p>
</li>
<li><p>修改系统环境变量Path，在最前面追加%JAVA_HOME%\bin  并以;和原路径分隔。再增加：“.;”。这是表示当前目录的意思<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170515/1494838936169679.png" alt="Alt 4"></p>
</li>
</ol>
<p>注意：</p>
<pre><code>此处一定是英文分号而不是中文分号！！！

classpath配置问题：如果使用JDK1.5以上就不需要配置这个环境变量！JRE会自动搜索当前路径下的类文件及相关jar文件</code></pre>]]></content>
      <tags>
        <tag>Java</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础语法</title>
    <url>/2020/01/16/Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>一个Java程序可以认为是一系列对象的集合，而这些对象通过调用彼此的方法来协同工作。下面简要介绍一下类、对象、方法和实例变量的概念。</p>
<a id="more"></a>
<pre><code>对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。

类：类是一个模板，它描述一类对象的行为和状态。

方法：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。

实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。</code></pre><p>控制台编译Java源代码(进入源码目录下)：<br>    :&gt; javac name.java<br>    :&gt; java name</p>
<h3 id="Java名称定义格式"><a href="#Java名称定义格式" class="headerlink" title="Java名称定义格式"></a>Java名称定义格式</h3><p>· 大小写敏感：Java是大小写敏感的，及标识符大写与小写是不同<br>· 类名：对于所有类来说，类名的首字母应该大写，如果由若干单词来构成，那么每个单词首字母都应该大写<br>· 方法名：所有的方法名都应该以小写字母开头，如果方法名由若干单词构成，那么第一个首字母小写，后面每个单词的首字母大写<br>· 源文件名：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 .java。（如果文件名和类名不相同则会导致编译错误）。<br>· 主方法入口：所有的 Java 程序由 public static void main(String []args) 方法开始执行。</p>
<h3 id="Java标识符"><a href="#Java标识符" class="headerlink" title="Java标识符"></a>Java标识符</h3><p>Java 所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。</p>
<pre><code>所有的标识符都应该以字母（A-Z 或者 a-z）,美元符（$）、或者下划线（_）开始

首字符之后可以是字母（A-Z 或者 a-z）,美元符（$）、下划线（_）或数字的任何字符组合

关键字不能用作标识符

标识符是大小写敏感的

合法标识符举例：age、$salary、_value、__1_value

非法标识符举例：123abc、-salary</code></pre><h3 id="Java修饰符"><a href="#Java修饰符" class="headerlink" title="Java修饰符"></a>Java修饰符</h3><p>像其他语言一样，Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：</p>
<pre><code>访问控制修饰符 : default, public , protected, private

非访问控制修饰符 : final, abstract, static, synchronized</code></pre><h3 id="Java变量"><a href="#Java变量" class="headerlink" title="Java变量"></a>Java变量</h3><p>局部变量</p>
<p>类变量(静态变量)</p>
<p>成员变量(非静态变量)</p>
<h3 id="Java数组"><a href="#Java数组" class="headerlink" title="Java数组"></a>Java数组</h3><p>数组是储存在堆上的对象，可以保存多个同类型变量</p>
<p>一维数组的定义<br>    <code>dataType[] arrayRefVar = new dataType[arraySize];</code></p>
<p>多维数组的定义<br>    <code>dataType[][] arrayRefVar = new dataType[arraySize][arraySize];</code></p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在 Java 中，一个类可以由其他类派生。如果你要创建一个类，而且已经存在一个类具有你所需要的属性或方法，那么你可以将新创建的类继承该类。</p>
<p>利用继承的方法，可以重用已存在类的方法和属性，而不用重写这些代码。被继承的类称为超类（super class），派生类称为子类（subclass）。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>在 Java 中，接口可理解为对象间相互通信的协议。接口在继承中扮演着很重要的角色。</p>
<p>接口只定义派生要用到的方法，但是方法的具体实现完全取决于派生类。</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++之文件操作</title>
    <url>/2019/12/26/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>C语言中对于文件的操作是通过指针来完成的，要注意，文件指针不是指向一段内存空间的，它实际上指向的是描述这个文件相关信息的一个文件结构体</p>
<a id="more"></a>
<h3 id="声明文件变量"><a href="#声明文件变量" class="headerlink" title="声明文件变量"></a>声明文件变量</h3><pre><code>FILE *file;</code></pre><p>声明了一个名为file的文件指针<br>定义好一个文件指针变量后就需要初始化这个文件指针变量或者说是打开文件</p>
<h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>打开文件通过fopen函数完成，比如：</p>
<pre><code>file = fopen(&quot;1.text&quot;,&quot;r+&quot;);</code></pre><p>fopen函数中有两个传入参数，第一个参数是文件的名称，比如“1.txt”，要注意，如果这个文件没有和你的程序处于同一目录下，需要写入全部路径，例如   “c:\1\1.txt”；第二个参数为打开文件的方式，他可以从下面几个方式中打开 </p>
<p>正常返回：<code>被打开文件的文件指针</code><br>异常返回：<code>NULL</code></p>
<center> 文件的打开方式 </center>

<table>
<thead>
<tr>
<th>打开方式</th>
<th>含义</th>
<th>指定文件不存在时</th>
<th>指定文件存在时</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>只读方式打开文本文件</td>
<td>出错</td>
<td>正常打开</td>
</tr>
<tr>
<td>w</td>
<td>只写方式打开文本文件</td>
<td>建立新文件</td>
<td>文件原有内容丢失</td>
</tr>
<tr>
<td>a</td>
<td>追加方式打开文本文件</td>
<td>建立新文件</td>
<td>在原有内容末尾追加</td>
</tr>
<tr>
<td>r+</td>
<td>读/写方式打开文本文件</td>
<td>出错</td>
<td>正常打开</td>
</tr>
<tr>
<td>w+</td>
<td>读/写方式创建新的文本文件</td>
<td>建立新文件</td>
<td>文件原有内容丢失</td>
</tr>
<tr>
<td>a+</td>
<td>读/追加方式建立新的文本文件</td>
<td>建立新文件</td>
<td>在原有内容末尾追加</td>
</tr>
<tr>
<td>rb</td>
<td>只读方式打开二进制文件</td>
<td>出错</td>
<td>正常打开</td>
</tr>
<tr>
<td>wb</td>
<td>只写方式打开二进制文件</td>
<td>建立新文件</td>
<td>文件原有内容丢失</td>
</tr>
<tr>
<td>ab</td>
<td>追加方式打开二进制文件</td>
<td>建立新文件</td>
<td>在原有内容末尾添加</td>
</tr>
<tr>
<td>rb+</td>
<td>读/写方式打开二进制文件</td>
<td>出错</td>
<td>正常打开</td>
</tr>
<tr>
<td>wb+</td>
<td>读/写方式创建新的二进制文件</td>
<td>建立新文件</td>
<td>文件原有内容丢失</td>
</tr>
<tr>
<td>ab+</td>
<td>读/追加方式创建新的二进制文件</td>
<td>建立新文件</td>
<td>在原有内容末尾追加</td>
</tr>
</tbody></table>
<h3 id="文件关闭"><a href="#文件关闭" class="headerlink" title="文件关闭"></a>文件关闭</h3><pre><code>fclose(FILE *fp);</code></pre><p>关闭已经打开的一个名为fp的FILE文件指针</p>
<p>正常返回：<code>0</code><br>异常返回：<code>EOF</code></p>
<h3 id="文件的顺序读写函数"><a href="#文件的顺序读写函数" class="headerlink" title="文件的顺序读写函数"></a>文件的顺序读写函数</h3><table>
<thead>
<tr>
<th>功能</th>
<th>函数名</th>
<th>适用于</th>
</tr>
</thead>
<tbody><tr>
<td>字符输入函数</td>
<td>fgetc</td>
<td>所有输入流</td>
</tr>
<tr>
<td>字符输出函数</td>
<td>fputc</td>
<td>所有输出流</td>
</tr>
<tr>
<td>文本行输出函数</td>
<td>fputs</td>
<td>所有输出流</td>
</tr>
<tr>
<td>格式化输入函数</td>
<td>fscanf</td>
<td>所有输入流</td>
</tr>
<tr>
<td>格式化输出函数</td>
<td>fprintf</td>
<td>所有输出流</td>
</tr>
<tr>
<td>二进制输入</td>
<td>fread</td>
<td>文件</td>
</tr>
<tr>
<td>二进制输出</td>
<td>fwrite</td>
<td>文件</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算小结</title>
    <url>/2019/12/25/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>位运算主要包括按位与(&amp;)、按位或(|)、按位异或(^)、取反(~)、左移(&lt;&lt;)、右移(&gt;&gt;)这几种，其中除了取反(~)以外，其他的都是二目运算符，即要求运算符左右两侧均有一个运算量</p>
<a id="more"></a>
<h3 id="位运算概览"><a href="#位运算概览" class="headerlink" title="位运算概览"></a>位运算概览</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
<th>运算规则</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;&lt;</td>
<td>左移</td>
<td>各二进位全部左移若干位，高位丢弃，低位补0</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移</td>
<td>各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移</td>
</tr>
<tr>
<td>|</td>
<td>按位或</td>
<td>两个位都为0时，结果才为0</td>
</tr>
<tr>
<td>&amp;</td>
<td>按位与</td>
<td>两个位都为1时，结果才为1</td>
</tr>
<tr>
<td>~</td>
<td>按位取反</td>
<td>0变1，1变0</td>
</tr>
<tr>
<td>^</td>
<td>按位异或</td>
<td>^    异或    两个位相同为0，相异为1</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/2019/12/20/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p><code>十个二分九个错</code>,二分虽然它的思想比较容易理解，但写出一个没有bug的二分，着实有些难受</p>
<a id="more"></a>
<h3 id="什么是二分"><a href="#什么是二分" class="headerlink" title="什么是二分"></a>什么是二分</h3><p>二分查找针对的是一个有序的数据集合，每次通过跟区间中间的元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间缩小为0</p>
<h4 id="二分查找的思路如下"><a href="#二分查找的思路如下" class="headerlink" title="二分查找的思路如下"></a>二分查找的思路如下</h4><p>（1）首先，从数组的中间元素开始搜索，如果该元素正好是目标元素，则搜索过程结束，否则执行下一步。</p>
<p>（2）如果目标元素大于/小于中间元素，则在数组大于/小于中间元素的那一半区域查找，然后重复步骤上述操作的操作。</p>
<p>（3）如果某一步数组为空，则表示找不到目标元素。</p>
<p>二分法查找的时间复杂度O(logn),且不需要额外的空间</p>
<h4 id="二分图解"><a href="#二分图解" class="headerlink" title="二分图解"></a>二分图解</h4><p><img src="http://www.cppblog.com/images/cppblog_com/guogangj/ds_binarysearch.png" alt="Image 二分查找"></p>
<h3 id="传统二分"><a href="#传统二分" class="headerlink" title="传统二分"></a>传统二分</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (nums[len - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 等于的情况最简单，我们应该放在第 1 个分支进行判断</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                <span class="comment">// 题目要我们返回大于或者等于目标值的第 1 个数的索引</span></span><br><span class="line">                <span class="comment">// 此时 mid 一定不是所求的左边界，</span></span><br><span class="line">                <span class="comment">// 此时左边界更新为 mid + 1</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 既然不会等于，此时 nums[mid] &gt; target</span></span><br><span class="line">                <span class="comment">// mid 也一定不是所求的右边界</span></span><br><span class="line">                <span class="comment">// 此时右边界更新为 mid - 1</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意：一定得返回左边界 left，</span></span><br><span class="line">        <span class="comment">// 理由是对于 [1,3,5,6]，target = 2，返回大于等于 target 的第 1 个数的索引，此时应该返回 1</span></span><br><span class="line">        <span class="comment">// 在上面的 while (left &lt;= right) 退出循环以后，right &lt; left，right = 0 ，left = 1</span></span><br><span class="line">        <span class="comment">// 根据题意应该返回 left，</span></span><br><span class="line">        <span class="comment">// 如果题目要求你返回小于等于 target 的所有数里最大的那个索引值，应该返回 right</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p><strong>取中位数索引的代码有问题</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span> ;</span><br></pre></td></tr></table></figure>
<p>这也不能说不对，但是如果当<code>left</code>和<code>right</code>都非常大的时候，那么<code>left+right</code>就很有可能会超过int类型能表示的最大范围，及整型溢出，这样就会缩小数据的处理范围，可以写成这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span> ;</span><br></pre></td></tr></table></figure>
<p>事实上，<code>int mid = left + (right - left) / 2</code>在<code>right</code>很大、<code>left</code>是负数且很小的时候，<code>right - left</code>也有可能超过int类型能表示的最范围，只不过一般情况下<code>left</code>和<code>right</code>表示的是数组索引值<code>left</code>是非负数，因此<code>right - left</code>溢出的可能性很小<br>所以使用“左边界索引 + 右边界索引”，然后“无符号右移 1 位”是推荐的写法，计算机的处理速度也会更快</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span> ;</span><br></pre></td></tr></table></figure>

<p><strong>返回条件的问题</strong></p>
<p>循环可以进行的条件写成<code>while (left &lt;= right)</code>时，在退出循环的时候，需要考虑返回<code>left</code>还是<code>right</code>，稍不注意，就容易出错<br>或许，我们可以回避这个问题^_^</p>
<h3 id="改良二分"><a href="#改良二分" class="headerlink" title="改良二分"></a>改良二分</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>首先我们把循环条件改为<code>while(left &lt; right)</code>,那么在退出循环的时候，一定有<code>left=right</code>成立，所以我们返回<code>left</code>或<code>right</code>都可以了<br>或许你可能会有一个疑问，退出循环的时候还有一个值没有判断啊(退出循环时left或right的索引值)<br>木有关系滴，那就退出循环来看，经过分析，甚至都不用看就能确定他是目标值<br>更深层次的思想是“夹逼法”或者可以说是“排除法”</p>
<p>其实，二分排除的过程中就是将区间不断“夹逼”的过程，在这过程中，不断排除一半的区间，从而加快查找速度</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>中位数先写 int mid = (left + right) &gt;&gt;&gt; 1 ; 根据循环里分支的编写情况，再做调整<br>理解这一点，首先要知道：当数组的元素个数是偶数的时候，中位数有左中位数和右中位数之分。</p>
<p>当数组的元素个数是偶数的时候：<br>使用 int mid = left + (right - left) / 2 ; 得到左中位数的索引；</p>
<p>使用 int mid = left + (right - left + 1) / 2 ; 得到右中位数的索引。</p>
<p>当数组的元素个数是奇数的时候，以上二者都能选到最中间的那个中位数。<br>其次，</p>
<p>int mid = left + (right - left) / 2 ; 等价于 int mid = (left + right) &gt;&gt;&gt; 1；</p>
<p>int mid = left + (right - left + 1) / 2 ; 等价于 int mid = (left + right + 1) &gt;&gt;&gt; 1 。</p>
<p>记忆方法：</p>
<p>(right - left) 不加 1 选左中位数，加 1 选右中位数。</p>
<p>那么，什么时候使用左中位数，什么时候使用右中位数呢？选中位数的依据是为了避免死循环，得根据分支的逻辑来选择中位数，而分支逻辑的编写也有技巧，下面具体说。</p>
<p>先写逻辑上容易想到的分支逻辑，这个分支逻辑通常是排除中位数的逻辑；</p>
<pre><code>如果分支的逻辑，在选择左边界的时候，不能排除中位数，那么中位数就选“右中位数”，只有这样区间才会收缩，否则进入死循环；
同理，如果分支的逻辑，在选择右边界的时候，不能排除中位数，那么中位数就选“左中位数”，只有这样区间才会收缩，否则进入死循环。</code></pre><p>举个栗子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="keyword">while</span> left &lt; right:</span><br><span class="line">      <span class="comment">//先写左中位数，看看你的分支会不会让你代码出现死循环，从而调整</span></span><br><span class="line">    mid = left + (right - left) <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">if</span> (check(mid)):</span><br><span class="line">        <span class="comment">//选择右边界的时候，可以排除中位数</span></span><br><span class="line">        right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">//选择左边界的时候，不能排除中位数</span></span><br><span class="line">        left = mid</span><br></pre></td></tr></table></figure>
<p>在区间中的元素只剩下2个时候，例如：left = 3，right = 4。<br>此时左中位数就是左边界，如果你的逻辑执行到 left = mid 这个分支，且你选择的中位数是左中位数，此时左边界就不会得到更新，区间就不会再收缩（理解这句话是关键），从而进入死循环；<br>为了避免出现死循环，你需要选择中位数是右中位数，当逻辑执行到 left = mid 这个分支的时候，因为你选择了右中位数，让逻辑可以转而执行到 right = mid - 1 让区间收缩，最终成为1个数，退出while循环。</p>
<p><em>如果出现了死循环，那么就打印输出左右边界、中位数的值和目标值、分支逻辑等必要的信息，进而进行分析</em></p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表之单向链表</title>
    <url>/2019/12/05/%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>链表是物理存储结构上非连续，非顺序的存储结构，但是在逻辑上它是通过链表指针指向而实现的顺序结构</p>
<a id="more"></a>
<p><strong>链表与数组的区别</strong></p>
<p>· 数组是静态分布内存，链表是动态分布内存<br>· 数组在内存中是连续的，链表是不连续的<br>· 数组利用下表定位，查找的时间复杂度是O(1),链表通过遍历定位元素，查找的复杂度是O(n)<br>· 数组的插入和移除都需要移动其它元素，时间复杂度是O(n)，；链表的插入或删除不需要移动其它元素，时间复杂度是O(1)</p>
<p><strong>数组的优点</strong></p>
<p>· 随机访问性比较强<br>· 查找速度快</p>
<p><strong>数组的缺点</strong></p>
<p>· 插入和删除的效率低，需要移动其它元素<br>· 会造成内存的浪费，因为内存是连续的，所以在申请数组的时候就必须规定内存的大小，如果长度不合适就会照成内存的浪费<br>· 内存空间的要求高，创建一个数组，必须要有足够的连续内存空间<br>· 数组的大小是固定的，在创建数组的时候就已经规定好，不能够动态拓展</p>
<p><strong>链表的优点</strong></p>
<p>· 插入和删除的效率高，只需要改变指针的指向就可以进行插入和删除<br>· 内存利用效率高，不会浪费内存，可以使用内存中细小的不连续空间，只有在有需要的时候才去创建空间，大小不固定，拓展很灵活</p>
<p><strong>链表的缺点</strong></p>
<p>· 查找效率低，因为链表是从第一个节点向后遍历查找</p>
<p><strong>图表演示</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20181108094742801.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lobF9qeHk=,size_16,color_FFFFFF,t_70" alt="alt 单向链表"></p>
<p><strong>结构体构建单向链表</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体定义链表节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Listnode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;       <span class="comment">//数据域</span></span><br><span class="line">    ListNode *next; <span class="comment">//后继指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>尾插法构建单向链表</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//尾插法构建单向链表</span></span><br><span class="line"><span class="function">struct Listnode* <span class="title">Creat_Listnode</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Listnode</span> *<span class="title">head</span>,*<span class="title">p</span>,*<span class="title">q</span>;</span></span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x) &amp;&amp; x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        p = (struct Listnode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Listnode));</span><br><span class="line">        p-&gt;data = x;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            q-&gt;next = p;</span><br><span class="line">        q = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取链表长度</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取链表长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length_Listnode</span><span class="params">(struct Listnode *head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Listnode</span> *<span class="title">t</span>;</span></span><br><span class="line">    t = head;</span><br><span class="line">    <span class="keyword">while</span>(t != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        len++;</span><br><span class="line">        t = t-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>链表排序</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链表排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort_Listnode</span><span class="params">(struct Listnode *head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = Length_Listnode(head);</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Listnode</span> *<span class="title">p</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;len<span class="number">-1</span>; i++)&#123;         <span class="comment">//冒泡排序的思想</span></span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len-i<span class="number">-1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;data &gt; p-&gt;next-&gt;data)&#123;</span><br><span class="line">                tmp = p-&gt;data;</span><br><span class="line">                p-&gt;data = p-&gt;next-&gt;data;</span><br><span class="line">                p-&gt;next-&gt;data = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>链表插入节点</strong></p>
<p>·主要头节点与尾节点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//顺序插入节点</span></span><br><span class="line"><span class="function">struct Listnode* <span class="title">Insert_Listnode</span><span class="params">(struct Listnode *head, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Listnode</span> *<span class="title">t</span>,*<span class="title">p</span>;</span></span><br><span class="line">    t = head;</span><br><span class="line">    p = (struct Listnode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Listnode));</span><br><span class="line">    <span class="keyword">if</span>(x &lt; head-&gt;data)&#123;         <span class="comment">//插入头节点</span></span><br><span class="line">        p-&gt;data = head-&gt;data;</span><br><span class="line">        p-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;data = x;</span><br><span class="line">        head-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;                   <span class="comment">//非头节点插入</span></span><br><span class="line">        <span class="keyword">while</span>(t!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;next==<span class="literal">NULL</span> || t-&gt;next-&gt;data &gt;x)&#123;</span><br><span class="line">                p-&gt;data=x;</span><br><span class="line">                p-&gt;next=t-&gt;next;        <span class="comment">//新增指针的后继指针指向当前后继指针指向的结点</span></span><br><span class="line">                t-&gt;next=p;              <span class="comment">//当前指针的后继指针指向当前指针</span></span><br><span class="line">                <span class="keyword">break</span>;                  <span class="comment">//注意是否要跳出，跳出只删除符合的第一个数吗，不跳则删除所有符合的数</span></span><br><span class="line">            &#125;</span><br><span class="line">            t=t-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>链表删除</strong></p>
<p>·同样是要注意头和尾滴</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除链表节点</span></span><br><span class="line"><span class="function">struct Listnode* <span class="title">Delete_Listnode</span><span class="params">(struct Listnode *head, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Listnode</span> *<span class="title">t</span>,*<span class="title">p</span>;</span></span><br><span class="line">    t=head;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;data == x)&#123;       <span class="comment">//头节点删除</span></span><br><span class="line">        p = head-&gt;next;</span><br><span class="line">        head-&gt;data = head-&gt;next-&gt;data;</span><br><span class="line">        head-&gt;next = head-&gt;next-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);                <span class="comment">//free()释放内存空间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;                       <span class="comment">//非头节点删除</span></span><br><span class="line">        <span class="keyword">while</span>(t != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;next-&gt;data == x)&#123;</span><br><span class="line">                p = t-&gt;next;</span><br><span class="line">                t-&gt;next = p-&gt;next;</span><br><span class="line">               <span class="built_in">free</span>(p);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            t = t-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>链表打印</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打印链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print_Listnode</span><span class="params">(struct Listnode *head)</span></span>&#123;</span><br><span class="line">    Listnode *t;</span><br><span class="line">    t = head;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">NULL</span>)       <span class="comment">//判断链表为空</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"!链表为空!"</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;               <span class="comment">//顺序打印链表</span></span><br><span class="line">        <span class="keyword">while</span>(t != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,t-&gt;data);</span><br><span class="line">            t = t-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<hr>
<p>以上就是涉及到链表的所有操作，包括创建、排序、插入、删除、打印等，了解链表的思想，主要是要注意表头，表中和表位，以及地址的指向。emmmm,其实c++，Java应该是用面向对象的写法来写。什么，你没有对象，new一个就好了 //滑稽</p>
<p>完整的代码我就不贴了，略略略(主要是比较长，我都要哭了)</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言基础</title>
    <url>/2019/12/05/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>C语言是一门面向过程的计算机编程语言，它的设计目标是提供一种能以简易的方式编译、处理低级存储器、仅产生少量的机器码以及不需要任何运行环境支持便能运行的编程语言。C语言描述问题比汇编语言迅速、工作量小、可读性好、易于调试、修改和移植，而代码质量与汇编语言相当。</p>
<a id="more"></a>
<p><strong>算法结构</strong></p>
<p>·  顺序结构<br>·  选择结构<br>·  循环结构<br>·  循环结构又分为while型、until型、for循环结构</p>
<p><strong>结构化程序设计方法</strong></p>
<p>·  自顶向下<br>·  逐步细化<br>·  模块化设计<br>·  结构化编码</p>
<p><strong>数据类型</strong></p>
<p>常量：常量包括字面常量、直接常量和符号常量</p>
<p>变量：C语言规定标志符只能由字母、数字和下划线三种字符组成，且第一个字符必须是字母或者下划线；必须压迫先定义后使用；每一个变量被定义以确定类型后，在编译时就能为其分配相应的存储单元</p>
<p>整数类型：整数常量有十进制、八进制和十六进制；“%d”</p>
<p>整形变量：数据在内存中存放形式是以二进制形式存放；有int型、short int型和long int型，无符号整型变量的范围是-32768—32767，有符号型为0~65535.通常把long定义为32位，把short定义为16位，int可以是32位也可以为16位，这都主要取决于机器字长。</p>
<p>实型常量的表示方法：</p>
<p>十进制，0.0<br>指数形式，123e3<br>实型变量：实数型数据在内存中的存放形式，一般在内存中占4个字节，分成整数部分和小数部分存放。实型变量分为float型、double型long double型。实型数据会存在舍入误差。<br>实型常量的类型：C编译系统将实型常量作为双精度来处理。</p>
<p>字符型数组：</p>
<p>字符常量：转义字符（\n——换行，\t——tab,\r——回车，\f——换页，\b——退格，\ddd——1到3位8进制的数代表的字符）<br>字符变量：字符数据存储形式实际是以ASCII码存储。“%c”<br>字符串常量：双撇号括起来的一系列字符序列</p>
<p><strong>C的运算符</strong></p>
<p>　　1、算术运算符（+ - * /  %）结合方向自左向右</p>
<p>　　2、关系运算符（&gt; &lt; == &gt;= &lt;= !=）</p>
<p>　　3、逻辑运算符(! &amp;&amp; ||)</p>
<p>　　4、位运算符(&lt;&lt; &gt;&gt; ~ | ^ &amp;)</p>
<p>　　5、赋值运算符(=及符号扩展赋值运算符)</p>
<p>　　6、条件运算符(? : )</p>
<p>　　7、逗号运算符( , )</p>
<p>　　8、指针运算符（* &amp;）</p>
<p>　　9、求字节运算符（sizeof）</p>
<p>　　10、强制类型转换运算符((类型))</p>
<p>　　11、分量运算符( . -&gt;)</p>
<p>　　12、下标运算符([])</p>
<p>　　13、其他</p>
<p><strong>数组</strong></p>
<p>　　一维数组的定义：类型说明符 数组名【常量表达式】；先定义后引用；一维数组初始化时可以只对一部分元素初始化，在对全部数组元素初始化的时候可以部规定长度；但是若被定义的数组长度与提供的初始值不一样时，则数组长度不能省略。</p>
<p>　　二维数组的定义：类型说明符 数组名【常量表达式】【常量表达式】C语言中存放二维数组是先存放第一行的元素，紧接着是第二行，其实也是以一维的方式存放。如果初始化时能指定所有元素的初始值，第一维大小可以省略，但是第二维不能省略。</p>
<p>　　字符数组：定义和初始化跟数组差不多，只是需要加单引号。字符和字符串结束标志，C语言规定，以‘\0’代表。</p>
<p><strong>字符串处理函数</strong></p>
<p>　　1、puts()将一个字符串输出到终端</p>
<p>　　2、gets（）从终端输入一个字符串到字符数组，并且得到一个函数值。</p>
<p>　　3、strcat（）链接两个字符数组中的字符串。</p>
<p>　　4、strcpy（）字符串复制函数。</p>
<p>　　5、strcmp（）比较字符串作用。</p>
<p>　　6、strlen（）测试字符串长度的函数不包括“\0”</p>
<p>　　7、strlwr（）将字符串中的大写字母转换为小写字母。</p>
<p>　　8、strupr（）将字符串中的小写字母转换为大写字母。</p>
<p><strong>形参与实参</strong></p>
<p>　　(1) 在定义函数中指定的形参，在未出现函数调用时，他们并不占用内存中的存储单元，只有发生调用时，才会分配内存。</p>
<p>　　(2) 实参可以是常量、变量或者表达式；有时传递的时地址；</p>
<p>　　(3) 在被定义中，形参必须指定类型；</p>
<p>　　(4) 实参与形参的类型应相同或赋值兼容；</p>
<p>　　(5) C语言规定，实参变量对形参变量的数据传递是“值传递”，即单向传递，只有实参传递给形参，而不能由形参传递给实参。</p>
<p>局部变量和全局变量：</p>
<p>　　（一）局部变量在一个函数内部定义的变量是内部变量，它只是在本函数范围内的有效，主函数也不能使用其它函数中定义的变量；不同函数中可以使用相同的名字的变量，他们代表不同的对象，互不干扰；形式参数也是局部变量；在一个函数内部，可以在复合语句中定义变量，这些变量只在本复合语句中有效，这种复合句也可以称为“分程序”或“程序块”；<br>　　（二）全局变量，在函数之外定义的变量称为外部变量，全局变量可以增加函数间数据联系的渠道，一般不再必要时不要使用，他在程序的全部执行过程中占用存储单元，是函数的通用性，使用全局变量会使程序的清晰性降低。还要注意若果同一源文件中，外部变量和局部变量同名，则在局部变量作用范围内，外部变量被“屏蔽”，不起任何作用。</p>
]]></content>
      <tags>
        <tag>C语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>c++&amp;vector</title>
    <url>/2019/12/03/c-vector/</url>
    <content><![CDATA[<p>在c++中，vector是一个十分有用的容器。</p>
<p>作用：它能够像容器一样存放各种类型的对象，简单地说，vector是一个能够存放任意类型的动态数组，能够增加和压缩数据。</p>
<p>vector在C++标准模板库中的部分内容，它是一个多功能的，能够操作多种数据结构和算法的模板类和函数库。</p>
<a id="more"></a>
<p><strong>特别注意：</strong></p>
<p>使用vector需要注意以下几点：</p>
<p>1.加入头文件<code>&lt;vector&gt;</code></p>
<p>2.如果你要表示的向量长度较长（需要为向量内部保存很多数），容易导致内存泄漏，而且效率会很低；</p>
<p>3.Vector作为函数的参数或者返回值时，需要注意它的写法：</p>
<p> ==double Distance(vector<int>&amp;a, vector<int>&amp;b) 其中的“&amp;”绝对不能少！！！==</p>
<h2 id="一维vector"><a href="#一维vector" class="headerlink" title=" 一维vector"></a><center> 一维vector</center></h2><p><strong>创建一维vector：</strong></p>
<pre><code>vector&lt;int&gt; nums;       //不指定长度
vector&lt;int&gt; nums(n);    //指定长度为n</code></pre><p><strong>添加元素</strong></p>
<pre><code>nums.push_back(1);      //直接从数组末端添加
nums[i]=1;              //直接赋值给第i个位置
nums.insert(nums.begin()+i,a);  //在第i+1个元素前插入a</code></pre><p><strong>删除元素</strong></p>
<pre><code>nums.resize(nums.size-i);    //直接将数组长度减少，某种意义上删掉了后面i个
nums.pop_back();             //删掉最后一个元素
nums.erase(nums.begin()+i);  //删掉第i+1个元素
nums.erase(nums.begin()+i,nums.end()+j);    //删除区间[i,j-1],区间从0开始
nums.clear();                //清空</code></pre><p><strong>其它</strong></p>
<p>获取长度：nums.size();</p>
<p>排序(O(nlogn))：sort(nums.begin(),nums.end());</p>
<p>翻转：reverse(nums.begin(),nums.end());</p>
<p>合并两个vector：合并nums1和nums2，并将合并的数组赋值给nums</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums1(m),nums2(n);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">nums.resize(m+n);</span><br><span class="line">merge(nums1.<span class="built_in">begin</span>(),nums1.<span class="built_in">end</span>(),nums2.<span class="built_in">begin</span>(),nums2.<span class="built_in">end</span>(),nums);</span><br></pre></td></tr></table></figure>

<h2 id="二维vector"><a href="#二维vector" class="headerlink" title="二维vector"></a><center>二维vector</center></h2><p><strong>创建M*n二维vector</strong></p>
<pre><code>vector&lt; vector&lt;int&gt; &gt; nums(m,vector&lt;int&gt;(n));   //m*n的二维vector</code></pre><p>解释：</p>
<p>定义了一个vector容器，元素类型为vector<int>，初始化为包含m个vector<int>对象，每个对象都是一个新创立的vector<int>对象的拷贝，而这个新创立的vector<int>对象被初始化为包含n个0。</p>
<p>vector<int>(n)表示构造一个无名且含n个0的vector<int>对象。</p>
<p><strong>动态创建m*n的二维vector</strong></p>
<p>==方法一==</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; &gt; nums;<span class="number">3</span></span><br><span class="line"></span><br><span class="line">nums.resize(m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) nums[i].resize(n);</span><br></pre></td></tr></table></figure>

<p>==方法二==</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; &gt; nums;</span><br><span class="line">nums.resize(m,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br></pre></td></tr></table></figure>
<p><strong>初始化二维数组</strong></p>
<pre><code>vector&lt;vector &lt;int&gt; &gt; nums(m ,vector&lt;int&gt;(n,0));    //m*n的二维vector，所有元素为0</code></pre><p>获得二维数组的行数：nums.size(); </p>
<p>获得二维数组的列数：nums[0].size()；</p>
<p><strong>数组遍历</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m = nums.<span class="built_in">size</span>(),n = nums[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;nums[i][j]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用vector还可以用结构体类型哟"><a href="#用vector还可以用结构体类型哟" class="headerlink" title="用vector还可以用结构体类型哟"></a><del>用vector还可以用结构体类型哟</del></h3>]]></content>
      <tags>
        <tag>c++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>最近好像有点飘</title>
    <url>/2019/11/26/%E6%9C%80%E8%BF%91%E5%A5%BD%E5%83%8F%E6%9C%89%E7%82%B9%E9%A3%98/</url>
    <content><![CDATA[<p>闲来回想了下自己最近，好像非常忙，又好像非常闲，忙这忙那的，似乎并没有学到太多。</p>
<a id="more"></a>

<p>进入到新的生活，因为之前学过自己专业所需要的技术，也和许多优秀的人(他们才是真正的大佬，我真的就是个渣渣啊啊啊)一起玩耍，打比赛，熬夜码代码。可是，来到这里，好像失去了当初的那份热爱，忘记了自己的本心。一天一天的混过一节又一节课。曾经计划要学的，也都还没有动。</p>
<p>我，应该清醒清醒了，在别人正在重点大学里寻求高峰，甚至有些曾经朝夕相处的伙伴在之前早就拿到了国外名校的offer，而我，在干什么</p>
<p>我却在浑浑噩噩的活着</p>
<p>生活从来没有安逸，寻求难度与刺激才是真正的我</p>
<p>我或许知道我要做的是什么了</p>
<h3 id="Everyone-should-have-a-dream-and-fight-for-it"><a href="#Everyone-should-have-a-dream-and-fight-for-it" class="headerlink" title="Everyone should have a dream and fight for it"></a>Everyone should have a dream and fight for it</h3>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title>排序之归并排序</title>
    <url>/2019/11/26/%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>来说说归并排序是啥？归并排序就是排序呗。啥，啥排序？归并呗。 </p>
<h2 id="哔bibibi-瞎哔哔"><a href="#哔bibibi-瞎哔哔" class="headerlink" title=" 哔bibibi(瞎哔哔)"></a> <del>哔bibibi(瞎哔哔)</del></h2><a id="more"></a>
<p>好吧,归并排序，是创建在归并操作上的一种有效的排序算法，效率为O(nlogn)。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分</p>
<p>治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。速度仅次于快速排序，为稳定排序算法，一般用</p>
<p>于对总体无序，但是各子项相对有序的数列，归并排序的比较次数小于快速排序的比较次数，移动次数一般多于快速排序的移动次数。</p>
<p><strong>算法思想</strong></p>
<p>该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶</p>
<p>段则将分的阶段得到的各答案”修补”在一起，即分而治之)。既然归并排序采用的是分治法，并且依托于归并操作，那么其思想肯定是分</p>
<p>而治之。我们知道归并操作是将两个有序的数列合并到一个有序的序列，那么对于一个无序的长序列，可以把它分解为若干个有序的子</p>
<p>序列，然后依次进行归并。如果我们说每一个数字都是单独有序的序列，那么只要把原始长序列依次分解，直到每个子序列都只有一个</p>
<p>元素的时候，再依次把所有的序列进行归并，直到序列数为1</p>
<p><img src="https://ftp.bmp.ovh/imgs/2019/12/623396b9f4e3a0ab.jpg" alt="alt 单向链表"></p>
<p>综上可知：</p>
<p>归并排序其实要做两件事：</p>
<p>（1）“分解”——将序列每次折半划分。<br>（2）“合并”——将划分后的序列段两两合并后排序。</p>
<p><strong>算法步骤</strong></p>
<p>(1)申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</p>
<p>(2)设定两个指针，最初位置分别为两个已经排序序列的起始位置；</p>
<p>(3)比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</p>
<p>(4)重复步骤 3 直到某一指针达到序列尾；</p>
<p>(5)将另一序列剩下的所有元素直接复制到合并序列尾。</p>
<p><strong>话不多说，上代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring &gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//归并过程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> help[r-l+<span class="number">1</span>];<span class="comment">//辅助数组</span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> lIndex = l;</span><br><span class="line">	<span class="keyword">int</span> rIndex = mid+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(lIndex &lt;= mid &amp;&amp; rIndex &lt;= r)&#123;</span><br><span class="line">		help[i++] = arr[lIndex] &lt; arr[rIndex] ? arr[lIndex++]:arr[rIndex++];</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//左边和右边肯定有一边到头了，不可能同时，因为每次只移动一边</span></span><br><span class="line">	<span class="keyword">while</span>(lIndex &lt;= mid)&#123;</span><br><span class="line">		help[i++] = arr[lIndex++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(rIndex &lt;= r)&#123;</span><br><span class="line">		help[i++] = arr[rIndex++];</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//将排好序的辅助数组赋值给原始数组，不需要返回值</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; r-l+<span class="number">1</span>; i++)&#123;</span><br><span class="line">		arr[l+i] = help[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">msort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//左半部分归并排序</span></span><br><span class="line">	msort(arr, l, mid);</span><br><span class="line">    <span class="comment">//右半部分归并排序</span></span><br><span class="line">	msort(arr, mid+<span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">//左右部分归并</span></span><br><span class="line">	merge(arr, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序整个数组</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">msort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果数组为空或只有一个元素，不需要排序</span></span><br><span class="line">	<span class="keyword">if</span>(arr == <span class="literal">NULL</span> || n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	msort(arr,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arry[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;arry[i];</span><br><span class="line">    msort(arry, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;arry[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>c++</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>排序之快速排序</title>
    <url>/2019/11/24/%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="快排及快速排序，是排序算法中比较快速常用的一种排序方式"><a href="#快排及快速排序，是排序算法中比较快速常用的一种排序方式" class="headerlink" title="快排及快速排序，是排序算法中比较快速常用的一种排序方式"></a>快排及快速排序，是排序算法中比较快速常用的一种排序方式</h3><a id="more"></a>

<h2 id="一-基本原理"><a href="#一-基本原理" class="headerlink" title="一 基本原理"></a>一 基本原理</h2><h5 id="快速排序的根本可以说就是通过分治法来实现，简单举一个例子来理解一下快速排序的过程。"><a href="#快速排序的根本可以说就是通过分治法来实现，简单举一个例子来理解一下快速排序的过程。" class="headerlink" title="快速排序的根本可以说就是通过分治法来实现，简单举一个例子来理解一下快速排序的过程。"></a>快速排序的根本可以说就是通过分治法来实现，简单举一个例子来理解一下快速排序的过程。</h5><p> 我们现在对（56，28，45，93，10，32，44，95，60，58）进行排序。首先我们定义三个量，i，j，flag。i是数组第一个值的下表即i=0。j是数组最后一个值的下表即j=9，flag就是数组的第一个值即flag=56，现在我们要做的就是讲这个数组中所有比flag小的数放到他的前面，把所有比flag大的数放到他的后面。</p>
<ul>
<li><p>第一步从j开始向左（前）找，找到第一个比flag小的数，是下标为6的数44，我们就将44与flag56进行交换从而使数组变成（44，28，45，93，10，32，56，95，60，58），此时的j=6</p>
</li>
<li><p>第二步从i开始向右（后）找，找到第一个比flag大的数，是下标为3的数93，我们就将93与flag56进行交换从而使数组变成（44，28，45，56，10，32，93，95，60，58），此时的i=3</p>
</li>
<li><p>第三步继续从j（此时j=6）开始向左找，找到比flag小的数，是下标为5的数32，我们将32与flag进行交换，得到数组（44，28，45，32，10，56，93，95，60，58），此时j=5</p>
</li>
<li><p>第四步从i（此时i=3）开始向右找，找到比flag大的数，直到i=j,我们发现在j之前已经找不到比flag更大的数，此时快速排序的第一轮就已经结束，这个时候在flag之前的数都是比他小的，在他之后都是比他大的，我们再将flag前后两片区域重新定义成新的无序的数组，分别对他们重复刚才的过程，直到分解到每个重新划分的区域内只有一个值，排序就算完成了。我们直接将过程贴在下面</p>
<pre><code>（44，28，45，32，10）（56）（93，95，60，58）

（10，28，45，32，44）（56）（58，95，60，93）

（10，28，44，32，45）（56）（58，93，60，95）

（10，28，32，44，45）（56）（58，60，93，95）

（10，28，32）（44）（45）（56）（58）（60）（93）（95）

（10）（28）（32）（44）（45）（56）（58）（60）（93）（95）</code></pre></li>
</ul>
<p>排序结束</p>
<h2 id="二-稳定性问题"><a href="#二-稳定性问题" class="headerlink" title="二 稳定性问题"></a>二 稳定性问题</h2><p>&emsp;&emsp;首先大家应该都知道快速排序是一个不稳定排序算法，那么到底什么才是排序的稳定性呢，我认为通俗的讲有两个相同的数A和B，在排序之前A在B的前面，而经过排序之后，B跑到了A的前面，对于这种情况的发生，我们管他叫做排序的不稳定性，而快速排序在对存在相同数进行排序时就有可能发生这种情况。</p>
<p>&emsp;&emsp;例如（5，3A，6，3B）对这个进行排序，排序之前相同的数3A与3B，A在B的前面，经过排序之后会变成（3B，3A，5，6），所以说快速排序是一个不稳定的排序</p>
<p>三 时间复杂度</p>
<p>== 简单的总结一下快速排序的时间复杂度问题 ==</p>
<ul>
<li><p>最优情况:每一次的flag刚好都可以平分整个数组，此时的时间复杂度为O(nlogn)</p>
</li>
<li><p>最坏情况:每一次的flag刚好都是最大或者最小的数，此时的时间复杂度为O(n2)</p>
</li>
<li><p>平均情况:经过推到平均情况为O(nlogn)</p>
</li>
</ul>
<h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*qsort 快速排序</span></span><br><span class="line"><span class="comment">*@auther wyt</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">200</span>];</span><br><span class="line"><span class="comment">//定义快排函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, mid, t;</span><br><span class="line">	i = l;</span><br><span class="line">	j = r;</span><br><span class="line">	mid = a[(l + r) / <span class="number">2</span>];</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (a[i] &lt; mid) i++;		<span class="comment">//寻找左边小于mid的数</span></span><br><span class="line">		<span class="keyword">while</span> (a[j] &gt; mid) j--;     <span class="comment">//寻找右边小于mid的数</span></span><br><span class="line">		<span class="keyword">if</span> (i &lt;= j) &#123;</span><br><span class="line">			t = a[i];		        <span class="comment">//进行数值交换</span></span><br><span class="line">			a[i] = a[j];</span><br><span class="line">			a[j] = t;</span><br><span class="line">			i++;			        <span class="comment">//继续寻找</span></span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (i &lt;= j);</span><br><span class="line">	<span class="keyword">if</span> (j &gt; l) qsort(l, j);			<span class="comment">//继续快排左右子序列</span></span><br><span class="line">	<span class="keyword">if</span> (i &lt; r) qsort(i, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	qsort(<span class="number">1</span>, n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><del>~ PS ~</del></p>
<ul>
<li><p>C++中有自带的快排库(<algorithm>)，用法：sort(*array+left , *array+right)</p>
</li>
<li><p>C中的库是在(&lt;stdlib.h&gt;)中<br>用法：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">qsort(a, <span class="number">1000</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), cmp);</span><br><span class="line"><span class="comment">//其中cmp函数应写为：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">int</span>*)a - *(<span class="keyword">int</span>*)b; <span class="comment">//由小到大排序</span></span><br><span class="line">    <span class="comment">//return *(int *)b - *(int *)a; 由大到小排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>c++</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>排序之选择排序</title>
    <url>/2019/11/20/%E6%8E%92%E5%BA%8F%E4%B9%8B%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<p>之前谈过冒泡排序，今天谈谈选择排序。选择排序，从头至尾扫描序列，找出最小的一个元素，和第一个元素交换，接着从剩下的元素中继续这种选择和交换方式，最终得到一个有序序列。</p>
<a id="more"></a>
<h5 id="文字说明"><a href="#文字说明" class="headerlink" title="文字说明"></a>文字说明</h5><ul>
<li>第1趟比较：拿第1个元素依次和它后面的每个元素进行比较，如果第1个元素大于后面某个元素，交换它们，经过第1趟比较，数组中最小的元素被选出，它被排在第一位</li>
<li>第2趟比较：拿第2个元素依次和它后面的每个元素进行比较，如果第2个元素大于后面某个元素，交换它们，经过第2趟比较，数组中第2小的元素被选出，它被排在第二位<br>……</li>
<li>第n-1趟比较：第n-1个元素和第n个元素作比较，如果第n-1个元素大于第n个元素，交换它们</li>
</ul>
<h5 id="图像演示"><a href="#图像演示" class="headerlink" title="图像演示"></a>图像演示</h5><p><img src="https://img-blog.csdn.net/20180120151515134?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2MxMjU4MDAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="alt 选择排序"></p>
<h5 id="核心代码演示"><a href="#核心代码演示" class="headerlink" title="核心代码演示"></a>核心代码演示</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">           <span class="keyword">if</span>(nums[i] &gt; nums[j]) &#123;</span><br><span class="line">               swap(nums[i], nums[j]); 交换nums[i]和nums[j]的值</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间复杂度：O(n²)</li>
<li>空间复杂度：O(1)，只需要一个附加程序单元用于交换</li>
<li>稳定性：选择排序是不稳定的排序算法，因为无法保证值相等的元素的相对位置不变，例如 [3, 4, 3, 1, 5]这个数组，第一次交换，第一个3和1交换位置，此时原来两个3的相对位置发生了变化。</li>
</ul>
<h5 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h5><p>上面的算法的缺点：在每趟比较过程中，一旦发现某个元素比第1位的元素小，就交换它们，但这是没必要的，徒增了交换的次数。<br>优化：选择排序的核心是，在每趟比较中，找到本趟中最小的元素放在本趟比较的第1个位置，所以选择排序的每趟比较只需要交换一次即可，只要找到本趟比较中最小的元素和本趟比较中第1位置的元素交换即可。</p>
]]></content>
      <tags>
        <tag>c++</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>人生路不长，别再等以后(转载)</title>
    <url>/2019/11/12/%E4%BA%BA%E7%94%9F%E8%B7%AF%E4%B8%8D%E9%95%BF%EF%BC%8C%E5%88%AB%E5%86%8D%E7%AD%89%E4%BB%A5%E5%90%8E-%E8%BD%AC%E8%BD%BD/</url>
    <content><![CDATA[<center><font face="隶书" size=4>人生路不长，别再等以后</font></center>

<a id="more"></a>

<center></center****> 


<p>一辈子很短，短得来不及细算<br>童年，不知不觉没了<br>青春，不知不觉没了<br>而那些无忧无虑的快乐<br>好像也消失不见了<br>一辈子三万天而已<br>没有你想得那么长<br>有什么心愿，快点实现<br>有什么目标，快点奋战<br>别等来等去<br>等来了年龄增长<br>等来了热情褪去<br>人生不是花，败了再开<br>身体不是叶，落了再生<br>我们每个人<br>都只有一次人生，只有一个身体<br>生病不能等，健康没了，人就完了<br>人生不能等，时间过了，人就终了<br>一辈子不长，别再等以后<br>想吃的东西，去吃<br>想做的事情，趁早<br>想要的感情，去追<br>想去的地方，快去<br>别一等再等<br>等牙没有了，想吃就难了<br>等人离开了，想爱就晚了<br>一辈子很短，这一生短暂<br>时间不等人，岁月不等你<br>趁我们都还活着<br>对父母，孝顺点，对爱人，珍惜点<br>对朋友，真心点，对自己，好一点</p>
<p>```</p>
<h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title>学计算机的都是一群疯子(转载)</title>
    <url>/2019/11/11/%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E9%83%BD%E6%98%AF%E4%B8%80%E7%BE%A4%E7%96%AF%E5%AD%90-%E8%BD%AC%E8%BD%BD/</url>
    <content><![CDATA[<h3 id="一名计算机专业的吐槽，，，无奈╮-╯▽╰-╭"><a href="#一名计算机专业的吐槽，，，无奈╮-╯▽╰-╭" class="headerlink" title="一名计算机专业的吐槽，，，无奈╮(╯▽╰)╭"></a>一名计算机专业的吐槽，，，无奈╮(╯▽╰)╭</h3><a id="more"></a>
<p><del>学计算机的你们伤不起啊！！！！！！！</del><br>你们学得都是人说的语言啊！！！！！！<br>好歹有点腔调肢体环境神马的做参考！！！！！<br>哥学得是计算机语言啊！！！！！！    </p>
<p>计算机不会跟你点头yes摇头no啊！！！！！<br>它就会报一堆不知所云的错误啊！！！！有木有！！！！   </p>
<p>有时候啥都不报，直接崩溃啊！！！有木有！！！<br>法语德语数字难念！！！！！<br>你随便找本算法书啊！！！！！厚的跟《康熙字典》一啊！！！！有木有！！！！！<br>各种堆！！！栈！！！树！！！！图！！！！<br>说到树就泪目啊！！！！  </p>
<p>光树就分生成树！！最小生成树！！有向树！！非平凡有向<br>树！！二叉树！！平凡二叉树！！平衡二叉树！！完全二叉树！！完全正则二叉树！！哈夫曼树！！晕了没？  </p>
<p>还要遍历！！！前序中序后序！！！<br>汇编语言！！！看着就是乱码啊！！！光寄存器就有N个啊！！！就差没写二进制来编程了啊！！！！！写个最简单的两数相加就要死人啊！！！！<br>C++啊！！！！一个指针就能搞死你！！！！内存溢出那是普遍的！！！！链表啊！！！<br>还双向链表啊！！！彻底的坑死哥啊！！！<br>java啊！！！各种框架就是搞出来坑哥的啊！！！！！<br>一个spring能从今年spring学到明年spring！！！！有木有！！！！<br>好不容易学会了！！！！！！又给淘汰了！！！新框架又出来了！！！！有木有！！！！！！<br>操作系统！！！Linux服务器！！！要记各种命令啊！！！vi编辑器那简直是折翼<br>啊！！！！Linux内核啊！！！  </p>
<p>研究出来孩子都多大了！！！！<br>数据库！！！！</p>
<p>又学一门SQL语言！！！！MySql跟orcle的SQL还不一样！！！！group by，order by！！！！左连接右连接交叉连接！！！笛卡尔集！！！！<br>你们写错个把单词不影响理解！！！！！计算机你错个标点它都不搭理你！！！！  </p>
<p>体会过系统不断崩溃就是找不到原因的闷骚心情么！！！！！一群人熬夜一个星期！！！<br>最后发现是一行注释多敲了个回车键！！！！<br>bug总是越改越多！！！还有玩着小游戏的测试员拿着小鞭子敲打你！！！！！好不容易做出来了！！！！ </p>
<p>客户一句话：“改”！！！！ </p>
<p>又是加班熬夜暗无天日啊！！！！！当年怎么想起来学计机！！！</p>
<p>学计算机你们伤不起啊！！ ！！</p>
<p>天杀的专业啊！！！别人知道你是个学个计算机的！！！！平时拍个照啊修个图啊！！！<br>装个电脑啊！！！！装个系统啊！！！！修个打印机都TM找我！！！！！哥只是个计算机专业的学的还是网络工程。。。。。为嘛跟计算机沾边的老子都要会啊！！！！更<br>牛的excel表格出个问题都找我！！！！哥哥只是个学计算机的倒霉蛋！！！！不是神仙啊！！！！！！！</p>
<p>跟人家解释，你是做软件的，不是修电脑的，你也不知道这个电脑值多少钱，人家就会以为你明明知道不肯告诉他那种鄙夷。。。。。。。。。靠！！！！<br>我现在都练出来了！！！被别人的白眼逼出来了。。。装电脑！！！装系统！！！修电脑！！！修打印机！！！和现在电脑 相机以及电脑周边产品的物价！！！！！！！我都<br>快成全能了！！！！！！！！！！！悲催了！！！！！！！！！我连硒鼓加粉都会了！！！！！我还有神马不会的！！！！！！</p>
<p>原文地址：<a href="http://blog.csdn.net/niushuai666/article/details/6763692" target="_blank" rel="noopener">学计算机的都是一群疯子</a></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title>flybird</title>
    <url>/2019/11/11/flybird/</url>
    <content><![CDATA[<h2 id="一个简单的C-小游戏"><a href="#一个简单的C-小游戏" class="headerlink" title="一个简单的C++小游戏"></a>一个简单的C++小游戏</h2> <a id="more"></a>

<hr>
<h3 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Lines = <span class="number">35</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Columns = <span class="number">120</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LeftLineColumn = <span class="number">20</span>;</span><br><span class="line">HANDLE hOut;</span><br><span class="line">DWORD dword;</span><br><span class="line"><span class="keyword">char</span> tmp[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> cur_time, start_time, last_time;</span><br><span class="line"><span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawBird</span><span class="params">(<span class="keyword">double</span> xx, <span class="keyword">double</span> yy)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = (<span class="keyword">int</span>)(xx + <span class="number">0.5</span>);</span><br><span class="line">  <span class="keyword">int</span> y = (<span class="keyword">int</span>)(yy + <span class="number">0.5</span>);</span><br><span class="line">  <span class="keyword">static</span> DWORD dword;</span><br><span class="line">  WriteConsoleOutputCharacter(hOut, <span class="string">"v"</span>, <span class="number">1</span>, (COORD)&#123;x, y - <span class="number">1</span>&#125;, &amp;dword);</span><br><span class="line">  WriteConsoleOutputCharacter(hOut, <span class="string">"&gt;&gt;&gt;"</span>, <span class="number">3</span>, (COORD)&#123;x - <span class="number">1</span>, y&#125;, &amp;dword);</span><br><span class="line">  WriteConsoleOutputCharacter(hOut, <span class="string">"^"</span>, <span class="number">1</span>, (COORD)&#123;x, y + <span class="number">1</span>&#125;, &amp;dword);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearBird</span><span class="params">(<span class="keyword">double</span> xx, <span class="keyword">double</span> yy)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = (<span class="keyword">int</span>)(xx + <span class="number">0.5</span>);</span><br><span class="line">  <span class="keyword">int</span> y = (<span class="keyword">int</span>)(yy + <span class="number">0.5</span>);</span><br><span class="line">  WriteConsoleOutputCharacter(hOut, <span class="string">" "</span>, <span class="number">1</span>, (COORD)&#123;x, y - <span class="number">1</span>&#125;, &amp;dword);</span><br><span class="line">  WriteConsoleOutputCharacter(hOut, <span class="string">"   "</span>, <span class="number">3</span>, (COORD)&#123;x - <span class="number">1</span>, y&#125;, &amp;dword);</span><br><span class="line">  WriteConsoleOutputCharacter(hOut, <span class="string">" "</span>, <span class="number">1</span>, (COORD)&#123;x, y + <span class="number">1</span>&#125;, &amp;dword);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Write at Middle/Left */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">WriteMiddle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> l = <span class="built_in">strlen</span>(str);</span><br><span class="line">  WriteConsoleOutputCharacter(hOut, str, l, (COORD)&#123;(Columns - l) / <span class="number">2</span>, y&#125;, &amp;dword);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">WriteLeft</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> l = <span class="built_in">strlen</span>(str);</span><br><span class="line">  WriteConsoleOutputCharacter(hOut, str, l, (COORD)&#123;<span class="number">1</span>, y&#125;, &amp;dword);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitLeftSide</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lines; ++i)</span><br><span class="line">    WriteConsoleOutputCharacter(hOut, <span class="string">"|"</span>, <span class="number">2</span>, (COORD)&#123;LeftLineColumn, i&#125;, &amp;dword);</span><br><span class="line">  <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">  ++p; WriteLeft(<span class="string">"Help:"</span>, p);</span><br><span class="line">  ++p; WriteLeft(<span class="string">" Press &lt;Space&gt; to"</span>, p);</span><br><span class="line">  ++p; WriteLeft(<span class="string">"make the bird fly."</span>, p);</span><br><span class="line">  ++p; WriteLeft(<span class="string">" Don't fall to the"</span>, p);</span><br><span class="line">  ++p; WriteLeft(<span class="string">"ground or hit pipes"</span>, p);</span><br><span class="line">  ++p; <span class="comment">// Empty line</span></span><br><span class="line">  ++p; WriteLeft(<span class="string">"Time:"</span>, p);</span><br><span class="line">  ++p; <span class="comment">// Time</span></span><br><span class="line">  ++p; WriteLeft(<span class="string">"Fps:"</span>, p);</span><br><span class="line">  ++p; <span class="comment">// Fps</span></span><br><span class="line">  ++p; <span class="comment">// Empty line</span></span><br><span class="line">  ++p; WriteLeft(<span class="string">"Score:"</span>, p);</span><br><span class="line">  ++p; <span class="comment">// Score</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawLeftSide</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">  ++p; <span class="comment">// WriteLeft("Help:", p);</span></span><br><span class="line">  ++p; <span class="comment">// WriteLeft(" Press &lt;Space&gt; to", p);</span></span><br><span class="line">  ++p; <span class="comment">// WriteLeft("make the bird fly.", p);</span></span><br><span class="line">  ++p; <span class="comment">// WriteLeft(" Don't fall to the", p);</span></span><br><span class="line">  ++p; <span class="comment">// WriteLeft("ground or hit pipes", p);</span></span><br><span class="line">  ++p; <span class="comment">// Empty line</span></span><br><span class="line">  ++p; <span class="comment">// WriteLeft("Time:", p);</span></span><br><span class="line">  <span class="built_in">sprintf</span>(tmp, <span class="string">" %5.2lfs"</span>, (<span class="keyword">double</span>)(cur_time - start_time) / CLOCKS_PER_SEC);</span><br><span class="line">  ++p; WriteLeft(tmp, p);</span><br><span class="line">  ++p; <span class="comment">// WriteLeft("Fps:", p);</span></span><br><span class="line">  <span class="built_in">sprintf</span>(tmp, <span class="string">" %5.2lf"</span>, CLOCKS_PER_SEC / (<span class="keyword">double</span>)(cur_time - last_time));</span><br><span class="line">  ++p; WriteLeft(tmp, p);</span><br><span class="line">  ++p; <span class="comment">// Empty line</span></span><br><span class="line">  ++p; <span class="comment">// WriteLeft("Score:", p);</span></span><br><span class="line">  <span class="built_in">sprintf</span>(tmp, <span class="string">" %3d"</span>, score);</span><br><span class="line">  ++p; WriteLeft(tmp, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pipe</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> H, D; <span class="comment">// A Pipe, [x, x + 1] * ([0, H] and [D, Lines))</span></span><br><span class="line">  <span class="keyword">double</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">RandRange</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="keyword">return</span> rand() % (r - l + <span class="number">1</span>) + l; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Pipe <span class="title">RandomPipe</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> br = RandRange(<span class="number">8</span>, <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">int</span> h = RandRange(<span class="number">3</span>, Lines - br - <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> (Pipe)&#123;h, h + br, (<span class="keyword">double</span>)x&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">CheckPipe</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">double</span> y, <span class="keyword">const</span> Pipe &amp;p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> px = (<span class="keyword">int</span>)(p.x + <span class="number">0.5</span>);</span><br><span class="line">  <span class="keyword">int</span> dx = <span class="built_in">std</span>::<span class="built_in">min</span>(<span class="built_in">std</span>::<span class="built_in">abs</span>(x - px), <span class="built_in">std</span>::<span class="built_in">abs</span>(x - px - <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">if</span> (dx &gt; <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (dx == <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> y &gt; p.H - <span class="number">0.5</span> &amp;&amp; y &lt; p.D + <span class="number">0.5</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (dx == <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> y &gt; p.H + <span class="number">0.5</span> &amp;&amp; y &lt; p.D - <span class="number">0.5</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> y &gt; p.H + <span class="number">1.5</span> &amp;&amp; y &lt; p.D - <span class="number">1.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearPipe</span><span class="params">(<span class="keyword">const</span> Pipe &amp;p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> px = (<span class="keyword">int</span>)(p.x + <span class="number">0.5</span>);</span><br><span class="line">  <span class="keyword">if</span> (px != LeftLineColumn &amp;&amp; px + <span class="number">1</span> &lt; Columns) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.H; ++i)</span><br><span class="line">      WriteConsoleOutputCharacter(hOut, <span class="string">"  "</span>, <span class="number">2</span>, (COORD)&#123;px, i&#125;, &amp;dword);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p.D + <span class="number">1</span>; i &lt; Lines; ++i)</span><br><span class="line">      WriteConsoleOutputCharacter(hOut, <span class="string">"  "</span>, <span class="number">2</span>, (COORD)&#123;px, i&#125;, &amp;dword);</span><br><span class="line">    WriteConsoleOutputCharacter(hOut, <span class="string">"  "</span>, <span class="number">2</span>, (COORD)&#123;px + <span class="number">1</span>, p.H&#125;, &amp;dword);</span><br><span class="line">    WriteConsoleOutputCharacter(hOut, <span class="string">"  "</span>, <span class="number">2</span>, (COORD)&#123;px + <span class="number">1</span>, p.D&#125;, &amp;dword);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> x = px == LeftLineColumn ? px + <span class="number">1</span> : px;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.H; ++i)</span><br><span class="line">      WriteConsoleOutputCharacter(hOut, <span class="string">" "</span>, <span class="number">1</span>, (COORD)&#123;x, i&#125;, &amp;dword);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p.D + <span class="number">1</span>; i &lt; Lines; ++i)</span><br><span class="line">      WriteConsoleOutputCharacter(hOut, <span class="string">" "</span>, <span class="number">1</span>, (COORD)&#123;x, i&#125;, &amp;dword);</span><br><span class="line">    WriteConsoleOutputCharacter(hOut, <span class="string">" "</span>, <span class="number">1</span>, (COORD)&#123;x, p.H&#125;, &amp;dword);</span><br><span class="line">    WriteConsoleOutputCharacter(hOut, <span class="string">" "</span>, <span class="number">1</span>, (COORD)&#123;x, p.D&#125;, &amp;dword);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawPipe</span><span class="params">(<span class="keyword">const</span> Pipe &amp;p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> px = (<span class="keyword">int</span>)(p.x + <span class="number">0.5</span>);</span><br><span class="line">  <span class="keyword">if</span> (px &lt; LeftLineColumn) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (px != LeftLineColumn &amp;&amp; px + <span class="number">1</span> &lt; Columns) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.H; ++i)</span><br><span class="line">      WriteConsoleOutputCharacter(hOut, <span class="string">"||"</span>, <span class="number">2</span>, (COORD)&#123;px, i&#125;, &amp;dword);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p.D + <span class="number">1</span>; i &lt; Lines; ++i)</span><br><span class="line">      WriteConsoleOutputCharacter(hOut, <span class="string">"||"</span>, <span class="number">2</span>, (COORD)&#123;px, i&#125;, &amp;dword);</span><br><span class="line">    WriteConsoleOutputCharacter(hOut, <span class="string">"--"</span>, <span class="number">2</span>, (COORD)&#123;px, p.H&#125;, &amp;dword);</span><br><span class="line">    WriteConsoleOutputCharacter(hOut, <span class="string">"--"</span>, <span class="number">2</span>, (COORD)&#123;px, p.D&#125;, &amp;dword);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> x = px == LeftLineColumn ? px + <span class="number">1</span> : px;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.H; ++i)</span><br><span class="line">      WriteConsoleOutputCharacter(hOut, <span class="string">"|"</span>, <span class="number">1</span>, (COORD)&#123;x, i&#125;, &amp;dword);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p.D + <span class="number">1</span>; i &lt; Lines; ++i)</span><br><span class="line">      WriteConsoleOutputCharacter(hOut, <span class="string">"|"</span>, <span class="number">1</span>, (COORD)&#123;x, i&#125;, &amp;dword);</span><br><span class="line">    WriteConsoleOutputCharacter(hOut, <span class="string">"-"</span>, <span class="number">1</span>, (COORD)&#123;x, p.H&#125;, &amp;dword);</span><br><span class="line">    WriteConsoleOutputCharacter(hOut, <span class="string">"-"</span>, <span class="number">1</span>, (COORD)&#123;x, p.D&#125;, &amp;dword);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">HideCursor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  CONSOLE_CURSOR_INFO cci;</span><br><span class="line">  GetConsoleCursorInfo(hOut,&amp;cci);</span><br><span class="line">  cci.bVisible = FALSE;</span><br><span class="line">  SetConsoleCursorInfo(hOut,&amp;cci);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  srand(time(<span class="literal">NULL</span>));</span><br><span class="line">  <span class="built_in">sprintf</span>(tmp, <span class="string">"mode con lines=%d cols=%d"</span>, Lines, Columns);</span><br><span class="line">  system(tmp);</span><br><span class="line">  hOut = GetStdHandle(STD_OUTPUT_HANDLE);</span><br><span class="line">  HideCursor();</span><br><span class="line">  InitLeftSide();</span><br><span class="line">  WriteMiddle(<span class="string">"Flappy bird (Simple)"</span>, Lines / <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">  WriteMiddle(<span class="string">"--By _wyt"</span>, Lines / <span class="number">2</span>);</span><br><span class="line">  WriteMiddle(<span class="string">"Press any key to start..."</span>, Lines / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">  _getch();</span><br><span class="line">  system(<span class="string">"cls"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pipe pipes[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Init();</span><br><span class="line">  InitLeftSide();</span><br><span class="line">  last_time = start_time = clock();</span><br><span class="line">  score = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> g = <span class="number">35</span>; <span class="comment">// Gravitational acceleration, grid / s^2</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> vx = <span class="number">12.0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> x = <span class="number">27.0</span>;</span><br><span class="line">  <span class="keyword">double</span> y = <span class="number">5.0</span>, vy = <span class="number">0.0</span>;</span><br><span class="line">  <span class="keyword">int</span> pipe_n = <span class="number">0</span>;</span><br><span class="line">  pipes[pipe_n++] = RandomPipe(Columns - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (kbhit()) &#123;</span><br><span class="line">      <span class="keyword">char</span> c = _getch();</span><br><span class="line">      <span class="keyword">if</span> (c == <span class="number">32</span>) vy = <span class="number">-15.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cur_time = clock();</span><br><span class="line">    <span class="keyword">double</span> time_break = (<span class="keyword">double</span>)(cur_time - last_time) / CLOCKS_PER_SEC;</span><br><span class="line">    ClearBird(x, y);</span><br><span class="line">    y = <span class="built_in">std</span>::<span class="built_in">min</span>(vy * time_break + y, <span class="number">33.0</span>);</span><br><span class="line">    vy += g * time_break;</span><br><span class="line">    <span class="keyword">if</span> (y &lt; <span class="number">1</span> - <span class="number">1e-6</span>) &#123; y = <span class="number">1</span>; vy = <span class="number">.0</span>; &#125;</span><br><span class="line">    DrawBird(x, y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pipe_n; ++i) &#123;</span><br><span class="line">      <span class="keyword">double</span> px = pipes[i].x, px2 = pipes[i].x - vx * time_break;</span><br><span class="line">      <span class="keyword">if</span> ((<span class="keyword">int</span>)(px + <span class="number">0.5</span>) != (<span class="keyword">int</span>)(px2 + <span class="number">0.5</span>)) &#123;</span><br><span class="line">        ClearPipe(pipes[i]);</span><br><span class="line">        pipes[i].x = px2;</span><br><span class="line">        DrawPipe(pipes[i]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pipes[i].x = px2;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Columns - pipes[pipe_n - <span class="number">1</span>].x &gt; <span class="number">30</span>)</span><br><span class="line">      DrawPipe(pipes[pipe_n++] = RandomPipe(Columns - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> failed = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pipe_n; ++i) &#123;</span><br><span class="line">      failed = failed || !CheckPipe((<span class="keyword">int</span>)(x + <span class="number">0.5</span>), y, pipes[i]);</span><br><span class="line">      <span class="keyword">if</span> ((<span class="keyword">int</span>)(pipes[i].x + <span class="number">0.5</span>) &gt;= LeftLineColumn)</span><br><span class="line">        pipes[j++] = pipes[i];</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        ++score;</span><br><span class="line">    &#125;</span><br><span class="line">    pipe_n = j;</span><br><span class="line">    DrawLeftSide();</span><br><span class="line">    <span class="keyword">if</span> (y &gt;= <span class="number">33.0</span> - <span class="number">1e-6</span> || failed) &#123;</span><br><span class="line">      DrawBird(x, y);</span><br><span class="line">      WriteMiddle(<span class="string">"-------------------------------"</span>, Lines / <span class="number">2</span> - <span class="number">2</span>);</span><br><span class="line">      WriteMiddle(<span class="string">"|                             |"</span>, Lines / <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">      WriteMiddle(<span class="string">"|                             |"</span>, Lines / <span class="number">2</span>);</span><br><span class="line">      WriteMiddle(<span class="string">"|                             |"</span>, Lines / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">      WriteMiddle(<span class="string">"|                             |"</span>, Lines / <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line">      WriteMiddle(<span class="string">"-------------------------------"</span>, Lines / <span class="number">2</span> + <span class="number">3</span>);</span><br><span class="line">      <span class="built_in">sprintf</span>(tmp, <span class="string">"Your score: %d!"</span>, score);</span><br><span class="line">      WriteMiddle(tmp, Lines / <span class="number">2</span>);</span><br><span class="line">      WriteMiddle(<span class="string">"Press any key to exit..."</span>, Lines / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">      _getch();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    last_time = cur_time;</span><br><span class="line">    Sleep(<span class="number">40</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> _ **** 嘿嘿，慢慢玩 _</p>
]]></content>
      <tags>
        <tag>随笔</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>排序入坑之冒泡</title>
    <url>/2019/11/11/%E6%8E%92%E5%BA%8F%E5%85%A5%E5%9D%91%E4%B9%8B%E5%86%92%E6%B3%A1/</url>
    <content><![CDATA[<h3 id="算法入坑第一步，冒泡排序。"><a href="#算法入坑第一步，冒泡排序。" class="headerlink" title="算法入坑第一步，冒泡排序。"></a>算法入坑第一步，冒泡排序。</h3><p>搜索算法是我们学习过程中必不可少的一步，其实理解以后，它也没有那么难…来先看个冒泡吧</p>
<a id="more"></a>
<h5 id="冒泡算法"><a href="#冒泡算法" class="headerlink" title="冒泡算法"></a>冒泡算法</h5><p><strong>如果遇到相等的值不进行交换，那这种排序方式是稳定的排序方式。</strong></p>
<p>原理：比较两个相邻的元素，将值大的元素交换到右边</p>
<p>思路：依次比较相邻的两个数，将比较小的数放在前面，比较大的数放在后面。</p>
<ul>
<li><p>第一次比较：首先比较第一和第二个数，将小数放在前面，将大数放在后面。</p>
</li>
<li><p>比较第2和第3个数，将小数 放在前面，大数放在后面。</p>
<p>  ……</p>
</li>
<li><p>如此继续，知道比较到最后的两个数，将小数放在前面，大数放在后面，重复步骤，直至全部排序完成</p>
</li>
<li><p>在上面一趟比较完成后，最后一个数一定是数组中最大的一个数，所以在比较第二趟的时候，最后一个数是不参加比较的。</p>
</li>
<li><p>在第二趟比较完成后，倒数第二个数也一定是数组中倒数第二大数，所以在第三趟的比较中，最后两个数是不参与比较的。</p>
</li>
<li><p>依次类推，每一趟比较次数减少依次</p>
</li>
</ul>
<p>举例：</p>
<p>　　　　(1)要排序数组:[10,1,35,61,89,36,55]<br>　　　　(2)第一趟排序：</p>
<p>　　　　　　第一次排序：10和1比较，10大于1，交换位置 　　 　  [1,10,35,61,89,36,55]</p>
<p>　　　　　　第二次排序：10和35比较，10小于35，不交换位置　　[1,10,35,61,89,36,55]</p>
<p>　　　　　　第三次排序：35和61比较，35小于61，不交换位置　　[1,10,35,61,89,36,55]</p>
<p>　　　　　　第四次排序：61和89比较，61小于89，不交换位置　　[1,10,35,61,89,36,55]</p>
<p>　　　　　　第五次排序：10和1比较，10大于1，交换位置 　　 　  [1,10,35,61,89,36,55]</p>
<p>　　　　　　第六次排序：89和55比较，89大于55，交换位置　　　[1,10,35,61,36,55,89]</p>
<p>　　　　　　第一趟总共进行了六次比较，排序结果：[1,10,35,61,36,55,89]</p>
<p>　　　　(3)第二趟排序：</p>
<p>　　　　　　第一次排序：1和10比较，1小于10，不交换位置　　[1,10,35,61,36,55,89]</p>
<p>　　　　　　第二次排序：10和35比较，10小于35，不交换位置    [1,10,35,61,36,55,89]</p>
<p>　　　　　　第三次排序：35和61比较，35小于61，不交换位置     [1,10,35,61,36,55,89]</p>
<p>　　　　　　第四次排序：61和36比较，61大于36，交换位置　　　[1,10,35,36,61,55,89]</p>
<p>　　　　　　第五次排序：61和55比较，61大于55，交换位置　　　[1,10,35,36,55,61,89]</p>
<p>　　　　　　第二趟总共进行了5次比较，排序结果：[1,10,35,36,55,61,89]</p>
<p>　　　　(4)第三趟排序：</p>
<p>　　　　　　第一次排序：1和10比较，1小于10，不交换位置　　[1,10,35,36,55,61,89]</p>
<p>　　　　　　第二次排序：10和35比较，10小于35，不交换位置    [1,10,35,36,55,61,89]</p>
<p>　　　　　　第三次排序：35和36比较，35小于36，不交换位置     [1,10,35,36,55,61,89]</p>
<p>　　　　　　第四次排序：36和61比较，36小于61，不交换位置　　　1,10,35,36,55,61,89</p>
<p>　　　　　　第三趟总共进行了4次比较，排序结果：1,10,35,36,55,61,89</p>
<p>　　　　　　到目前位置已经为有序的情形了。　　　　</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span>    <span class="comment">//下面是函数sort的程序 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,temp;    <span class="comment">//定义三个整型变量 </span></span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;n<span class="number">-1</span>;j++)    <span class="comment">//用一个嵌套循环来遍历一遍每一对相邻元素 （所以冒泡函数慢嘛，时间复杂度高）  </span></span><br><span class="line">    &#123;                           </span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>-j;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;a[i+<span class="number">1</span>])  <span class="comment">//从大到小排就把左边的"&gt;"改为"&lt;"</span></span><br><span class="line">            &#123;</span><br><span class="line">                temp=a[i];      <span class="comment">//a[i]与a[i+1](即a[i]后面那个) 交换</span></span><br><span class="line">                a[i]=a[i+<span class="number">1</span>];    <span class="comment">//基本的交换原理"c=a;a=b;b=c" </span></span><br><span class="line">                a[i+<span class="number">1</span>]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.算法分析：</p>
<p>　　　　(1)由此可见：N个数字要排序完成，总共进行N-1趟排序，每i趟的排序次数为(N-i)次，所以可以用双重循环语句，外层控制循环多少趟，内层控制每一趟的循环次数</p>
<p>　　　　(2)冒泡排序的优点：每进行一趟排序，就会少比较一次，因为每进行一趟排序都会找出一个较大值。如上例：第一趟比较之后，排在最后的一个数一定是最大的一个数，第二趟排序的时候，只需要比较除了最后一个数以外的其他的数，同样也能找出一个最大的数排在参与第二趟比较的数后面，第三趟比较的时候，只需要比较除了最后两个数以外的其他的数，以此类推……也就是说，没进行一趟比较，每一趟少比较一次，一定程度上减少了算法的量。<br>　　　　<br>　　　　(3)时间复杂度</p>
<p>　　　　1.如果我们的数据正序，只需要走一趟即可完成排序。所需的比较次数C和记录移动次数M均达到最小值，即：Cmin=n-1;Mmin=0;所以，冒泡排序最好的时间复杂度为O(n)。</p>
<p>　　　　2.如果很不幸我们的数据是反序的，则需要进行n-1趟排序。每趟排序要进行n-i次比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：</p>
<p>　　　　　　综上所述：冒泡排序总的平均时间复杂度为：O(n2) ,时间复杂度和数据状况无关。</p>
]]></content>
      <tags>
        <tag>c++</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>素数，他，他又来了</title>
    <url>/2019/11/10/%E7%B4%A0%E6%95%B0%EF%BC%8C%E4%BB%96%EF%BC%8C%E4%BB%96%E5%8F%88%E6%9D%A5%E4%BA%86/</url>
    <content><![CDATA[<p>是他，是他，就是他，我们的…咳咳，走错片场了。一大堆素数朝你涌来，感谢埃拉托斯特尼，感谢欧拉(其实一点也不╮(╯▽╰)╭)</p>
<a id="more"></a>
<p>上次实际上是对单个数进行判断是否为素数，但是如果我们有一大堆素数，还用上次的方法的话，那么，，，一定很有趣。好吧我就直接说了，一大堆数进行判断，一个一个的进行循环无疑是很浪费时间的，那么我们就可以构建一个素数表，只需要判断一堆数是否在素数表里就可以了。</p>
<p>有请第一位嘉宾——埃拉托斯特尼筛法(简称埃氏筛法)</p>
<h3 id="埃氏筛法"><a href="#埃氏筛法" class="headerlink" title="埃氏筛法"></a>埃氏筛法</h3><p>首先，我们将2到n范围内的所有整数写下来。其中最小的数字2是素数。将表中所有2的倍数都划去。表中剩余的最小数字是3，它不能被更小的数整除，所以是素数。再将表中所有3的倍数都划去。依此类推，如果表中剩余的最小数字是m时，m就是素数。然后将表中所有m的倍数都化去。像这样反复操作，就能依次枚举n以内的素数。</p>
<p>话不多说，上代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> u[MAXN];			<span class="comment">//定义一个筛子</span></span><br><span class="line"><span class="keyword">int</span> su[MAXN], num = <span class="number">0</span>;	<span class="comment">//定义一个素数表及表的长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;		<span class="comment">//埃氏筛法函数</span></span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; MAXN; i++)		<span class="comment">//进行数组初始化</span></span><br><span class="line">		u[i] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; MAXN; i++)			<span class="comment">//从2到MAXN进行循环</span></span><br><span class="line">		<span class="keyword">if</span> (u[i]) &#123;						<span class="comment">//一旦u[i]是素数，那么筛去它小于MAXN的所有倍数</span></span><br><span class="line">			<span class="keyword">for</span> (j = <span class="number">2</span>; i * j &lt; MAXN; j++)</span><br><span class="line">				u[i * j] = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; MAXN; i++)			<span class="comment">//将筛出的素数填入素数表中</span></span><br><span class="line">		<span class="keyword">if</span> (u[i])</span><br><span class="line">			su[++num] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面埃氏筛法中，大家有没有发现一个问题</p>
<p>最小的素数是2，那么2的整数倍都不是素数，删去4,6,8…余下的数里，最小的素数是3，删去6,9,12…最终未被删去的数就是素数。但，这样在效率上有一个问题：一个数会被删去多次。例如42会被2 3 7都删去一遍，其时间复杂度为O(NlogNlogN)，，，所以，，，</p>
<h3 id="有请欧拉上场"><a href="#有请欧拉上场" class="headerlink" title="有请欧拉上场"></a>有请欧拉上场</h3><p>对每个合数a×b，它会被每个质因数都筛去一遍，但我们只要用最小的质因数筛去就好了为此，我们需要记录下所产生的全部素数，上代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> u[MAXN];        <span class="comment">//筛子</span></span><br><span class="line"><span class="keyword">int</span> su[MAXN],num=<span class="number">0</span>;       <span class="comment">//创建素数表及表长</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eulerSieve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(u,<span class="literal">true</span>,<span class="keyword">sizeof</span>(u));       <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;=MAXN; i++)&#123;         <span class="comment">//顺序分析区间表中的每个数</span></span><br><span class="line">        <span class="keyword">if</span>(u[i])</span><br><span class="line">            su[++num]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=num; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i*su[j]&gt;MAXN)        <span class="comment">//如果i与当前素数的乘积大于MAXN，则跳过</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            u[i*su[j]]=<span class="literal">false</span>;       <span class="comment">//素数的倍数必为非素数，筛去</span></span><br><span class="line">            <span class="keyword">if</span>(i%su[j]==<span class="number">0</span>)          <span class="comment">//如果su[j]是i的最小素数，则进行下一个i的判断</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心就是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(i%su[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>如果i能整除su[k]，说明su[k]是i的因子，所以su[k]也是i的任意倍数的因子。所以su[k]也是i×su[x] (x&gt;k)的因子。考虑到primelist单增，对i×su[x]，su[k]就是它的比su[x]更小的因子。故不用考虑其后的质因子了（i×su[x]会被su[k]作为因子在i更大时被筛掉）</p>
]]></content>
      <tags>
        <tag>c++</tag>
        <tag>素数</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的模计算</title>
    <url>/2019/11/10/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%A8%A1%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<p>常用的模计算，没有公式证明，只统计了相关结论</p>
<a id="more"></a>
<h1 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h1><hr>
<h5 id="对于正整数和整数-，定义如下运算："><a href="#对于正整数和整数-，定义如下运算：" class="headerlink" title="对于正整数和整数 , ，定义如下运算："></a>对于正整数和整数 , ，定义如下运算：</h5><p>取模运算：a % p（或a mod p），表示a除以p的余数。</p>
<p>模p加法：(a + b) % p ，其结果是a+b算术和除以p的余数，也就是说，(a+b) = kp +r，则(a + b) % p = r。</p>
<p>模p减法：(a-b) % p ，其结果是a-b算术差除以p的余数。</p>
<p>模p乘法：(a * b) % p，其结果是 a * b算术乘法除以p的余数。</p>
<ol>
<li><p>同余式：正整数a，b对p取模，它们的余数相同，记做 a ≡ b % p或者a ≡ b (mod p)。</p>
</li>
<li><p>n % p得到结果的正负由被除数n决定,与p无关。例如：7%4 = 3， -7%4 = -3， 7%-4 = 3， -7%-4 = -3。 </p>
</li>
</ol>
<p>（1）若p|(a-b)，则a≡b (% p)。例如 11 ≡ 4 (% 7)， 18 ≡ 4(% 7)</p>
<p>（2）(a % p)=(b % p)意味a≡b (% p)</p>
<p>（3）对称性：a≡b (% p)等价于b≡a (% p)</p>
<p>（4）传递性：若a≡b (% p)且b≡c (% p) ，则a≡c (% p) 模运算与基本四则运算有些相似，但是除法例外。其规则如下：</p>
<p>(a + b) % p = (a % p + b % p) % p （1）</p>
<p>(a - b) % p = (a % p - b % p) % p （2）</p>
<p>(a * b) % p = (a % p * b % p) % p （3）</p>
<p>(a^b) % p = ((a % p)^b) % p （4）</p>
<p>结合律：<br>((a+b) % p + c) % p = (a + (b+c) % p) % p （5）</p>
<p>((a<em>b) % p * c)% p = (a * b</em>c) % p （6）// (a%p<em>b)%p=(a</em>b)%p</p>
<p>交换律：<br>(a + b) % p = (b+a) % p （7）</p>
<p>(a * b) % p = (b * a) % p （8）</p>
<p>分配律：<br>((a +b)% p * c) % p = ((a * c) % p + (b * c) % p) % p （9）</p>
<h3 id="重要定理："><a href="#重要定理：" class="headerlink" title="重要定理："></a>重要定理：</h3><p>若a≡b (% p)，则对于任意的c，都有(a + c) ≡ (b + c) (%p)；（10）</p>
<p>若a≡b (% p)，则对于任意的c，都有(a * c) ≡ (b * c) (%p)；（11）</p>
<p>若a≡b (% p)，c≡d (% p)，则 (a + c) ≡ (b + d) (%p)，(a - c) ≡ (b - d) (%p)，<br>(a * c) ≡ (b * d) (%p)，(a / c) ≡ (b / d) (%p)； （12）</p>
<p><del>23333</del></p>
]]></content>
      <tags>
        <tag>随笔</tag>
        <tag>模</tag>
      </tags>
  </entry>
  <entry>
    <title>动规的初级理解</title>
    <url>/2019/11/10/%E5%8A%A8%E8%A7%84%E7%9A%84%E5%88%9D%E7%BA%A7%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>动态规划是学习算法过程中的一道绊脚石，那么今天就让我们，走进动态规划的世界里，不要恐惧它，其实挺有意思的</p>
<a id="more"></a>
<h4 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h4><p>动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。</p>
<h4 id="二、基本思想与策略"><a href="#二、基本思想与策略" class="headerlink" title="二、基本思想与策略"></a>二、基本思想与策略</h4><p>基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。</p>
<p>由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。</p>
<p>与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。</p>
<h4 id="三、适用的情况"><a href="#三、适用的情况" class="headerlink" title="三、适用的情况"></a>三、适用的情况</h4><p>能采用动态规划求解的问题的一般要具有3个性质：</p>
<p>(1) 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。</p>
<p>(2) 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</p>
<p>（3）有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）</p>
<hr>
<hr>
<h4 id="四、求解的基本步骤"><a href="#四、求解的基本步骤" class="headerlink" title="四、求解的基本步骤"></a>四、求解的基本步骤</h4><p>动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。</p>
<p>初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态</p>
<p>图1 动态规划决策过程示意图</p>
<p>(1)划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。</p>
<p>(2)确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。</p>
<p>(3)确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。</p>
<p>(4)寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。</p>
<p>一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。</p>
<p>实际应用中可以按以下几个简化的步骤进行设计：</p>
<p>（1）分析最优解的性质，并刻画其结构特征。</p>
<p>（2）递归的定义最优解。</p>
<p>（3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值</p>
<p>（4）根据计算最优值时得到的信息，构造问题的最优解</p>
<h4 id="五、算法实现的说明"><a href="#五、算法实现的说明" class="headerlink" title="五、算法实现的说明"></a>五、算法实现的说明</h4><p>动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。</p>
<p>使用动态规划求解问题，最重要的就是确定动态规划三要素：</p>
<p>（1）问题的阶段 （2）每个阶段的状态</p>
<p>（3）从前一个阶段转化到后一个阶段之间的递推关系。</p>
<p>递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。</p>
<p>确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">f(n,m)=<span class="built_in">max</span>&#123;f(n<span class="number">-1</span>,m), f(n<span class="number">-1</span>,m-w[n])+P(n,m)&#125;</span><br></pre></td></tr></table></figure>
<h3 id="六、动态规划算法基本框架"><a href="#六、动态规划算法基本框架" class="headerlink" title="六、动态规划算法基本框架"></a>六、动态规划算法基本框架</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=m; j=j+<span class="number">1</span>) <span class="comment">// 第一个阶段</span></span><br><span class="line">   xn[j] = 初始值;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span>(i=n<span class="number">-1</span>; i&gt;=<span class="number">1</span>; i=i<span class="number">-1</span>)<span class="comment">// 其他n-1个阶段</span></span><br><span class="line">   <span class="keyword">for</span>(j=<span class="number">1</span>; j&gt;=f(i); j=j+<span class="number">1</span>)<span class="comment">//f(i)与i有关的表达式</span></span><br><span class="line">     xi[j]=j=<span class="built_in">max</span>（或<span class="built_in">min</span>）&#123;g(xi<span class="number">-1</span>[j1:j2]), ......, g(xi<span class="number">-1</span>[jk:jk+<span class="number">1</span>])&#125;;</span><br><span class="line"> </span><br><span class="line">t = g(x1[j1:j2]); <span class="comment">// 由子问题的最优解求解整个问题的最优解的方案</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(x1[j1]);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;=n<span class="number">-1</span>; i=i+<span class="number">1</span>）</span><br><span class="line">&#123;  </span><br><span class="line">     t = t-xi<span class="number">-1</span>[ji];</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">for</span>(j=<span class="number">1</span>; j&gt;=f(i); j=j+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>(t=xi[ji])</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>c++</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>悲伤发廊</title>
    <url>/2019/11/10/%E6%82%B2%E4%BC%A4%E5%8F%91%E5%BB%8A/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">曾经对我最重要的那个她</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="f356b37a14f7945dec52238914ba2b926d9ffad122b0fa6440a9e0c03ef80912">45bae770a26b23f1ab6df10a14e4f0722ff982f785666094d2f241d8c6c2f6f178f6951d6e87000443f284e54968f40ee6934daf7703976ce6f1479ad5817fe6e24dd3081ad697ced619276428bc8c33b0255dcd576a266b7a264cf3b7efa945d6c1e5c118e18f12776ac566dc311532a880bd523b21ce91b5d28444fe31f57c264a27f2ff60e6124bf7ccc7ac813153e41411e19797fe7c8edb6dfc5ba5318929ec1cb0a8a7a024f69d2aa7acb082e7cf701c8f04e719337e4f78959b1103f2328ebfeed9d14b85d4e561c571f218ccc58cdf1029cc1919ab9544c033239698ef75627ff93a8c3a4dbe5b1016ac0b61f2b4c87752a03261118ecf7c40be117f814c3f815512d175b3c19af33fae118110b4e27bcefd0c7f4128dbd11e1c6c932b12074807a07ed15cae3b4f961aa6ca292d91a5e26f09dacb1b72975c51ecb0951b3371eabf6d9ff08de727abc672b2a5b4c4c43c54b605b1285b968d91012b5342b443b9b3ed120d00c58b66eed9f07eb39cc161383c5a86b645898c168ce9cdeae9be0ae6b1eb4a444f625cd20d5c3503af337357ddfa6b6e45338d026cbdcc154f1205b72219345b55eb0fbcb8e110bb1130be74e98762e13ae75b66698f7f9b59560f5babc3cdae429cbccf96f1756c8d006320ab37babeb3277540360d781c5d58d9af9b6be70f4721e5ed7310cffa491588dd209acc8fad5569d167db583f67207dd94c58edb4dc890ce36c0321dd66209a576883ed9aa53f46769431b9aa03a250575e2d4e34af0946595d9bba17a75c66d0b6721b24239986516b83f3ad1d9688c6c5cdc6ebbdee02427d2deef4c2ad43ab47085398ef1cec56b6c8d09a2115c80aa0a752f4dcdce3fa61aaef65c3b41e044c5a476f9943d0bcd768a94e44e1758431cf18640a4070739d11378e451f5a5de3c6faa21b5a040e0173f1a590d2833683990ffe1b93ea3321eed93c014d4e9cfdf77a7ada34b68b8e5032379b169057c7e53b79555580b59fab27f2f906b6e7c737ed90cdc7ee62e1568f5dc0829fd17bf79e95ba39f88e1fdff9a1b7c0882d0b56edbfbb5270155246a98bfbebfd3ee69ca64e2b02b27b49dd3c758148e7ea6633025464b10474c440caa22430f451310bbd3f2207c3fd3fd446588f0c9e968bc0510934ab322e50a775edaa7adebfc71b866aa5427dc2cce27343af2d5b99c61661575fc379f22d59</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title>初级素数判断</title>
    <url>/2019/11/10/%E5%88%9D%E7%BA%A7%E7%B4%A0%E6%95%B0%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<p>这篇只是让大家初步了解如何判断素数，是最基础的内容，之后会讲一些欧拉，埃氏等素数筛的方法</p>
<a id="more"></a>
<h6 id="第一次的想法"><a href="#第一次的想法" class="headerlink" title="第一次的想法:"></a>第一次的想法:</h6><p>==让它爆搜一遍不就好了== <del>爆搜大法好爆搜大法好</del></p>
<blockquote>
<p>具体实现就是让数n从2开始模,一直模到n-1,如果都不能被整除,那就是素数<strong>紧扣定义</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否是素数1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"please inpout a number."</span>;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; m; ++i)</span><br><span class="line">        <span class="keyword">if</span> (m%i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="string">" isn't a prime\n"</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="string">" is a prime\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这么复杂,那来进行下简单优化:<br>如果一个数有因子的话，那么在它的平方根数以内就应该有，否则就没有因子。例如66的平方根在8与9之间，因为66不是素数，，则它一定有比8还小的因子，我们知道66的因子是2、3、6等<br><strong>那我们就可以这样写了</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="built_in">sqrt</span>(m); ++i)&#123;</span><br><span class="line">    <span class="keyword">if</span> (m%i == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="string">" isn't a prime\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>本次初级素数判断就先到这里</strong><br><strong>有没有感觉到循环挺浪费时间的呢</strong><br><strong>那去想想有什么方法能够进一步降低时间复杂度</strong></p>
]]></content>
      <tags>
        <tag>c++</tag>
        <tag>素数</tag>
      </tags>
  </entry>
  <entry>
    <title>hello</title>
    <url>/2019/11/10/hello/</url>
    <content><![CDATA[<h1 id="重建-GitHub-hexo-博客的第一篇笔记"><a href="#重建-GitHub-hexo-博客的第一篇笔记" class="headerlink" title="重建 GitHub+hexo 博客的第一篇笔记"></a>重建 GitHub+hexo 博客的第一篇笔记</h1><p>虽然GitHub有时候不太稳定，但我依然是很爱她的，今后的blog将不再漂泊，我会陆陆续续将其它地方的blog渐渐挪到这上面来，现在虽然用的还是hexo官网上的主题，emmmm，肯定是要好好学学web技术，未来全部换成自己写的组件</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
