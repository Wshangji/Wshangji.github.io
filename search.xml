<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>二分查找</title>
    <url>/2019/12/20/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p><code>十个二分九个错</code>,二分虽然它的思想比较容易理解，但写出一个没有bug的二分，着实有些难受</p>
<a id="more"></a>
<h3 id="什么是二分"><a href="#什么是二分" class="headerlink" title="什么是二分"></a>什么是二分</h3><p>二分查找针对的是一个有序的数据集合，每次通过跟区间中间的元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间缩小为0</p>
<h4 id="二分查找的思路如下"><a href="#二分查找的思路如下" class="headerlink" title="二分查找的思路如下"></a>二分查找的思路如下</h4><p>（1）首先，从数组的中间元素开始搜索，如果该元素正好是目标元素，则搜索过程结束，否则执行下一步。</p>
<p>（2）如果目标元素大于/小于中间元素，则在数组大于/小于中间元素的那一半区域查找，然后重复步骤上述操作的操作。</p>
<p>（3）如果某一步数组为空，则表示找不到目标元素。</p>
<p>二分法查找的时间复杂度O(logn),且不需要额外的空间</p>
<h4 id="二分图解"><a href="#二分图解" class="headerlink" title="二分图解"></a>二分图解</h4><p><img src="http://www.cppblog.com/images/cppblog_com/guogangj/ds_binarysearch.png" alt="Image 二分查找"></p>
<h3 id="传统二分"><a href="#传统二分" class="headerlink" title="传统二分"></a>传统二分</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (nums[len - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 等于的情况最简单，我们应该放在第 1 个分支进行判断</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                <span class="comment">// 题目要我们返回大于或者等于目标值的第 1 个数的索引</span></span><br><span class="line">                <span class="comment">// 此时 mid 一定不是所求的左边界，</span></span><br><span class="line">                <span class="comment">// 此时左边界更新为 mid + 1</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 既然不会等于，此时 nums[mid] &gt; target</span></span><br><span class="line">                <span class="comment">// mid 也一定不是所求的右边界</span></span><br><span class="line">                <span class="comment">// 此时右边界更新为 mid - 1</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意：一定得返回左边界 left，</span></span><br><span class="line">        <span class="comment">// 理由是对于 [1,3,5,6]，target = 2，返回大于等于 target 的第 1 个数的索引，此时应该返回 1</span></span><br><span class="line">        <span class="comment">// 在上面的 while (left &lt;= right) 退出循环以后，right &lt; left，right = 0 ，left = 1</span></span><br><span class="line">        <span class="comment">// 根据题意应该返回 left，</span></span><br><span class="line">        <span class="comment">// 如果题目要求你返回小于等于 target 的所有数里最大的那个索引值，应该返回 right</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>查找</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表之单向链表</title>
    <url>/2019/12/05/%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>链表是物理存储结构上非连续，非顺序的存储结构，但是在逻辑上它是通过链表指针指向而实现的顺序结构</p>
<a id="more"></a>
<p><strong>链表与数组的区别</strong></p>
<p>· 数组是静态分布内存，链表是动态分布内存<br>· 数组在内存中是连续的，链表是不连续的<br>· 数组利用下表定位，查找的时间复杂度是O(1),链表通过遍历定位元素，查找的复杂度是O(n)<br>· 数组的插入和移除都需要移动其它元素，时间复杂度是O(n)，；链表的插入或删除不需要移动其它元素，时间复杂度是O(1)</p>
<p><strong>数组的优点</strong></p>
<p>· 随机访问性比较强<br>· 查找速度快</p>
<p><strong>数组的缺点</strong></p>
<p>· 插入和删除的效率低，需要移动其它元素<br>· 会造成内存的浪费，因为内存是连续的，所以在申请数组的时候就必须规定内存的大小，如果长度不合适就会照成内存的浪费<br>· 内存空间的要求高，创建一个数组，必须要有足够的连续内存空间<br>· 数组的大小是固定的，在创建数组的时候就已经规定好，不能够动态拓展</p>
<p><strong>链表的优点</strong></p>
<p>· 插入和删除的效率高，只需要改变指针的指向就可以进行插入和删除<br>· 内存利用效率高，不会浪费内存，可以使用内存中细小的不连续空间，只有在有需要的时候才去创建空间，大小不固定，拓展很灵活</p>
<p><strong>链表的缺点</strong></p>
<p>· 查找效率低，因为链表是从第一个节点向后遍历查找</p>
<p><strong>图表演示</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20181108094742801.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lobF9qeHk=,size_16,color_FFFFFF,t_70" alt="alt 单向链表"></p>
<p><strong>结构体构建单向链表</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体定义链表节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Listnode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;       <span class="comment">//数据域</span></span><br><span class="line">    ListNode *next; <span class="comment">//后继指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>尾插法构建单向链表</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//尾插法构建单向链表</span></span><br><span class="line"><span class="function">struct Listnode* <span class="title">Creat_Listnode</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Listnode</span> *<span class="title">head</span>,*<span class="title">p</span>,*<span class="title">q</span>;</span></span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x) &amp;&amp; x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        p = (struct Listnode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Listnode));</span><br><span class="line">        p-&gt;data = x;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            q-&gt;next = p;</span><br><span class="line">        q = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取链表长度</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取链表长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length_Listnode</span><span class="params">(struct Listnode *head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Listnode</span> *<span class="title">t</span>;</span></span><br><span class="line">    t = head;</span><br><span class="line">    <span class="keyword">while</span>(t != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        len++;</span><br><span class="line">        t = t-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>链表排序</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链表排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort_Listnode</span><span class="params">(struct Listnode *head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = Length_Listnode(head);</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Listnode</span> *<span class="title">p</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;len<span class="number">-1</span>; i++)&#123;         <span class="comment">//冒泡排序的思想</span></span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len-i<span class="number">-1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;data &gt; p-&gt;next-&gt;data)&#123;</span><br><span class="line">                tmp = p-&gt;data;</span><br><span class="line">                p-&gt;data = p-&gt;next-&gt;data;</span><br><span class="line">                p-&gt;next-&gt;data = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>链表插入节点</strong></p>
<p>·主要头节点与尾节点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//顺序插入节点</span></span><br><span class="line"><span class="function">struct Listnode* <span class="title">Insert_Listnode</span><span class="params">(struct Listnode *head, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Listnode</span> *<span class="title">t</span>,*<span class="title">p</span>;</span></span><br><span class="line">    t = head;</span><br><span class="line">    p = (struct Listnode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Listnode));</span><br><span class="line">    <span class="keyword">if</span>(x &lt; head-&gt;data)&#123;         <span class="comment">//插入头节点</span></span><br><span class="line">        p-&gt;data = head-&gt;data;</span><br><span class="line">        p-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;data = x;</span><br><span class="line">        head-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;                   <span class="comment">//非头节点插入</span></span><br><span class="line">        <span class="keyword">while</span>(t!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;next==<span class="literal">NULL</span> || t-&gt;next-&gt;data &gt;x)&#123;</span><br><span class="line">                p-&gt;data=x;</span><br><span class="line">                p-&gt;next=t-&gt;next;        <span class="comment">//新增指针的后继指针指向当前后继指针指向的结点</span></span><br><span class="line">                t-&gt;next=p;              <span class="comment">//当前指针的后继指针指向当前指针</span></span><br><span class="line">                <span class="keyword">break</span>;                  <span class="comment">//注意是否要跳出，跳出只删除符合的第一个数吗，不跳则删除所有符合的数</span></span><br><span class="line">            &#125;</span><br><span class="line">            t=t-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>链表删除</strong></p>
<p>·同样是要注意头和尾滴</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除链表节点</span></span><br><span class="line"><span class="function">struct Listnode* <span class="title">Delete_Listnode</span><span class="params">(struct Listnode *head, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Listnode</span> *<span class="title">t</span>,*<span class="title">p</span>;</span></span><br><span class="line">    t=head;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;data == x)&#123;       <span class="comment">//头节点删除</span></span><br><span class="line">        p = head-&gt;next;</span><br><span class="line">        head-&gt;data = head-&gt;next-&gt;data;</span><br><span class="line">        head-&gt;next = head-&gt;next-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);                <span class="comment">//free()释放内存空间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;                       <span class="comment">//非头节点删除</span></span><br><span class="line">        <span class="keyword">while</span>(t != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;next-&gt;data == x)&#123;</span><br><span class="line">                p = t-&gt;next;</span><br><span class="line">                t-&gt;next = p-&gt;next;</span><br><span class="line">               <span class="built_in">free</span>(p);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            t = t-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>链表打印</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打印链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print_Listnode</span><span class="params">(struct Listnode *head)</span></span>&#123;</span><br><span class="line">    Listnode *t;</span><br><span class="line">    t = head;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">NULL</span>)       <span class="comment">//判断链表为空</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"!链表为空!"</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;               <span class="comment">//顺序打印链表</span></span><br><span class="line">        <span class="keyword">while</span>(t != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,t-&gt;data);</span><br><span class="line">            t = t-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<hr>
<p>以上就是涉及到链表的所有操作，包括创建、排序、插入、删除、打印等，了解链表的思想，主要是要注意表头，表中和表位，以及地址的指向。emmmm,其实c++，Java应该是用面向对象的写法来写。什么，你没有对象，new一个就好了 //滑稽</p>
<p>完整的代码我就不贴了，略略略(主要是比较长，我都要哭了)</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言基础</title>
    <url>/2019/12/05/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>C语言是一门面向过程的计算机编程语言，它的设计目标是提供一种能以简易的方式编译、处理低级存储器、仅产生少量的机器码以及不需要任何运行环境支持便能运行的编程语言。C语言描述问题比汇编语言迅速、工作量小、可读性好、易于调试、修改和移植，而代码质量与汇编语言相当。</p>
<a id="more"></a>
<p><strong>算法结构</strong></p>
<p>·  顺序结构<br>·  选择结构<br>·  循环结构<br>·  循环结构又分为while型、until型、for循环结构</p>
<p><strong>结构化程序设计方法</strong></p>
<p>·  自顶向下<br>·  逐步细化<br>·  模块化设计<br>·  结构化编码</p>
<p><strong>数据类型</strong></p>
<p>常量：常量包括字面常量、直接常量和符号常量</p>
<p>变量：C语言规定标志符只能由字母、数字和下划线三种字符组成，且第一个字符必须是字母或者下划线；必须压迫先定义后使用；每一个变量被定义以确定类型后，在编译时就能为其分配相应的存储单元</p>
<p>整数类型：整数常量有十进制、八进制和十六进制；“%d”</p>
<p>整形变量：数据在内存中存放形式是以二进制形式存放；有int型、short int型和long int型，无符号整型变量的范围是-32768—32767，有符号型为0~65535.通常把long定义为32位，把short定义为16位，int可以是32位也可以为16位，这都主要取决于机器字长。</p>
<p>实型常量的表示方法：</p>
<p>十进制，0.0<br>指数形式，123e3<br>实型变量：实数型数据在内存中的存放形式，一般在内存中占4个字节，分成整数部分和小数部分存放。实型变量分为float型、double型long double型。实型数据会存在舍入误差。<br>实型常量的类型：C编译系统将实型常量作为双精度来处理。</p>
<p>字符型数组：</p>
<p>字符常量：转义字符（\n——换行，\t——tab,\r——回车，\f——换页，\b——退格，\ddd——1到3位8进制的数代表的字符）<br>字符变量：字符数据存储形式实际是以ASCII码存储。“%c”<br>字符串常量：双撇号括起来的一系列字符序列</p>
<p><strong>C的运算符</strong></p>
<p>　　1、算术运算符（+ - * /  %）结合方向自左向右</p>
<p>　　2、关系运算符（&gt; &lt; == &gt;= &lt;= !=）</p>
<p>　　3、逻辑运算符(! &amp;&amp; ||)</p>
<p>　　4、位运算符(&lt;&lt; &gt;&gt; ~ | ^ &amp;)</p>
<p>　　5、赋值运算符(=及符号扩展赋值运算符)</p>
<p>　　6、条件运算符(? : )</p>
<p>　　7、逗号运算符( , )</p>
<p>　　8、指针运算符（* &amp;）</p>
<p>　　9、求字节运算符（sizeof）</p>
<p>　　10、强制类型转换运算符((类型))</p>
<p>　　11、分量运算符( . -&gt;)</p>
<p>　　12、下标运算符([])</p>
<p>　　13、其他</p>
<p><strong>数组</strong></p>
<p>　　一维数组的定义：类型说明符 数组名【常量表达式】；先定义后引用；一维数组初始化时可以只对一部分元素初始化，在对全部数组元素初始化的时候可以部规定长度；但是若被定义的数组长度与提供的初始值不一样时，则数组长度不能省略。</p>
<p>　　二维数组的定义：类型说明符 数组名【常量表达式】【常量表达式】C语言中存放二维数组是先存放第一行的元素，紧接着是第二行，其实也是以一维的方式存放。如果初始化时能指定所有元素的初始值，第一维大小可以省略，但是第二维不能省略。</p>
<p>　　字符数组：定义和初始化跟数组差不多，只是需要加单引号。字符和字符串结束标志，C语言规定，以‘\0’代表。</p>
<p><strong>字符串处理函数</strong></p>
<p>　　1、puts()将一个字符串输出到终端</p>
<p>　　2、gets（）从终端输入一个字符串到字符数组，并且得到一个函数值。</p>
<p>　　3、strcat（）链接两个字符数组中的字符串。</p>
<p>　　4、strcpy（）字符串复制函数。</p>
<p>　　5、strcmp（）比较字符串作用。</p>
<p>　　6、strlen（）测试字符串长度的函数不包括“\0”</p>
<p>　　7、strlwr（）将字符串中的大写字母转换为小写字母。</p>
<p>　　8、strupr（）将字符串中的小写字母转换为大写字母。</p>
<p><strong>形参与实参</strong></p>
<p>　　(1) 在定义函数中指定的形参，在未出现函数调用时，他们并不占用内存中的存储单元，只有发生调用时，才会分配内存。</p>
<p>　　(2) 实参可以是常量、变量或者表达式；有时传递的时地址；</p>
<p>　　(3) 在被定义中，形参必须指定类型；</p>
<p>　　(4) 实参与形参的类型应相同或赋值兼容；</p>
<p>　　(5) C语言规定，实参变量对形参变量的数据传递是“值传递”，即单向传递，只有实参传递给形参，而不能由形参传递给实参。</p>
<p>局部变量和全局变量：</p>
<p>　　（一）局部变量在一个函数内部定义的变量是内部变量，它只是在本函数范围内的有效，主函数也不能使用其它函数中定义的变量；不同函数中可以使用相同的名字的变量，他们代表不同的对象，互不干扰；形式参数也是局部变量；在一个函数内部，可以在复合语句中定义变量，这些变量只在本复合语句中有效，这种复合句也可以称为“分程序”或“程序块”；<br>　　（二）全局变量，在函数之外定义的变量称为外部变量，全局变量可以增加函数间数据联系的渠道，一般不再必要时不要使用，他在程序的全部执行过程中占用存储单元，是函数的通用性，使用全局变量会使程序的清晰性降低。还要注意若果同一源文件中，外部变量和局部变量同名，则在局部变量作用范围内，外部变量被“屏蔽”，不起任何作用。</p>
]]></content>
      <tags>
        <tag>C语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>c++&amp;vector</title>
    <url>/2019/12/03/c-vector/</url>
    <content><![CDATA[<p>在c++中，vector是一个十分有用的容器。</p>
<p>作用：它能够像容器一样存放各种类型的对象，简单地说，vector是一个能够存放任意类型的动态数组，能够增加和压缩数据。</p>
<p>vector在C++标准模板库中的部分内容，它是一个多功能的，能够操作多种数据结构和算法的模板类和函数库。</p>
<a id="more"></a>
<p><strong>特别注意：</strong></p>
<p>使用vector需要注意以下几点：</p>
<p>1.加入头文件<code>&lt;vector&gt;</code></p>
<p>2.如果你要表示的向量长度较长（需要为向量内部保存很多数），容易导致内存泄漏，而且效率会很低；</p>
<p>3.Vector作为函数的参数或者返回值时，需要注意它的写法：</p>
<p> ==double Distance(vector<int>&amp;a, vector<int>&amp;b) 其中的“&amp;”绝对不能少！！！==</p>
<h2 id="一维vector"><a href="#一维vector" class="headerlink" title=" 一维vector"></a><center> 一维vector</center></h2><p><strong>创建一维vector：</strong></p>
<pre><code>vector&lt;int&gt; nums;       //不指定长度
vector&lt;int&gt; nums(n);    //指定长度为n</code></pre><p><strong>添加元素</strong></p>
<pre><code>nums.push_back(1);      //直接从数组末端添加
nums[i]=1;              //直接赋值给第i个位置
nums.insert(nums.begin()+i,a);  //在第i+1个元素前插入a</code></pre><p><strong>删除元素</strong></p>
<pre><code>nums.resize(nums.size-i);    //直接将数组长度减少，某种意义上删掉了后面i个
nums.pop_back();             //删掉最后一个元素
nums.erase(nums.begin()+i);  //删掉第i+1个元素
nums.erase(nums.begin()+i,nums.end()+j);    //删除区间[i,j-1],区间从0开始
nums.clear();                //清空</code></pre><p><strong>其它</strong></p>
<p>获取长度：nums.size();</p>
<p>排序(O(nlogn))：sort(nums.begin(),nums.end());</p>
<p>翻转：reverse(nums.begin(),nums.end());</p>
<p>合并两个vector：合并nums1和nums2，并将合并的数组赋值给nums</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums1(m),nums2(n);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">nums.resize(m+n);</span><br><span class="line">merge(nums1.<span class="built_in">begin</span>(),nums1.<span class="built_in">end</span>(),nums2.<span class="built_in">begin</span>(),nums2.<span class="built_in">end</span>(),nums);</span><br></pre></td></tr></table></figure>

<h2 id="二维vector"><a href="#二维vector" class="headerlink" title="二维vector"></a><center>二维vector</center></h2><p><strong>创建M*n二维vector</strong></p>
<pre><code>vector&lt; vector&lt;int&gt; &gt; nums(m,vector&lt;int&gt;(n));   //m*n的二维vector</code></pre><p>解释：</p>
<p>定义了一个vector容器，元素类型为vector<int>，初始化为包含m个vector<int>对象，每个对象都是一个新创立的vector<int>对象的拷贝，而这个新创立的vector<int>对象被初始化为包含n个0。</p>
<p>vector<int>(n)表示构造一个无名且含n个0的vector<int>对象。</p>
<p><strong>动态创建m*n的二维vector</strong></p>
<p>==方法一==</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; &gt; nums;<span class="number">3</span></span><br><span class="line"></span><br><span class="line">nums.resize(m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) nums[i].resize(n);</span><br></pre></td></tr></table></figure>

<p>==方法二==</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; &gt; nums;</span><br><span class="line">nums.resize(m,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br></pre></td></tr></table></figure>
<p><strong>初始化二维数组</strong></p>
<pre><code>vector&lt;vector &lt;int&gt; &gt; nums(m ,vector&lt;int&gt;(n,0));    //m*n的二维vector，所有元素为0</code></pre><p>获得二维数组的行数：nums.size(); </p>
<p>获得二维数组的列数：nums[0].size()；</p>
<p><strong>数组遍历</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m = nums.<span class="built_in">size</span>(),n = nums[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;nums[i][j]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用vector还可以用结构体类型哟"><a href="#用vector还可以用结构体类型哟" class="headerlink" title="用vector还可以用结构体类型哟"></a><del>用vector还可以用结构体类型哟</del></h3>]]></content>
      <tags>
        <tag>c++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>最近好像有点飘</title>
    <url>/2019/11/26/%E6%9C%80%E8%BF%91%E5%A5%BD%E5%83%8F%E6%9C%89%E7%82%B9%E9%A3%98/</url>
    <content><![CDATA[<p>闲来回想了下自己最近，好像非常忙，又好像非常闲，忙这忙那的，似乎并没有学到太多。</p>
<a id="more"></a>

<p>进入到新的生活，因为之前学过自己专业所需要的技术，也和许多优秀的人(他们才是真正的大佬，我真的就是个渣渣啊啊啊)一起玩耍，打比赛，熬夜码代码。可是，来到这里，好像失去了当初的那份热爱，忘记了自己的本心。一天一天的混过一节又一节课。曾经计划要学的，也都还没有动。</p>
<p>我，应该清醒清醒了，在别人正在重点大学里寻求高峰，甚至有些曾经朝夕相处的伙伴在之前早就拿到了国外名校的offer，而我，在干什么</p>
<p>我却在浑浑噩噩的活着</p>
<p>生活从来没有安逸，寻求难度与刺激才是真正的我</p>
<p>我或许知道我要做的是什么了</p>
<h3 id="Everyone-should-have-a-dream-and-fight-for-it"><a href="#Everyone-should-have-a-dream-and-fight-for-it" class="headerlink" title="Everyone should have a dream and fight for it"></a>Everyone should have a dream and fight for it</h3>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title>排序之归并排序</title>
    <url>/2019/11/26/%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>来说说归并排序是啥？归并排序就是排序呗。啥，啥排序？归并呗。 </p>
<h2 id="哔bibibi-瞎哔哔"><a href="#哔bibibi-瞎哔哔" class="headerlink" title=" 哔bibibi(瞎哔哔)"></a> <del>哔bibibi(瞎哔哔)</del></h2><a id="more"></a>
<p>好吧,归并排序，是创建在归并操作上的一种有效的排序算法，效率为O(nlogn)。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分</p>
<p>治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。速度仅次于快速排序，为稳定排序算法，一般用</p>
<p>于对总体无序，但是各子项相对有序的数列，归并排序的比较次数小于快速排序的比较次数，移动次数一般多于快速排序的移动次数。</p>
<p><strong>算法思想</strong></p>
<p>该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶</p>
<p>段则将分的阶段得到的各答案”修补”在一起，即分而治之)。既然归并排序采用的是分治法，并且依托于归并操作，那么其思想肯定是分</p>
<p>而治之。我们知道归并操作是将两个有序的数列合并到一个有序的序列，那么对于一个无序的长序列，可以把它分解为若干个有序的子</p>
<p>序列，然后依次进行归并。如果我们说每一个数字都是单独有序的序列，那么只要把原始长序列依次分解，直到每个子序列都只有一个</p>
<p>元素的时候，再依次把所有的序列进行归并，直到序列数为1</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7789414-2737ec30a70ff74f.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/811/format/webp" alt="alt 单向链表"></p>
<p>综上可知：</p>
<p>归并排序其实要做两件事：</p>
<p>（1）“分解”——将序列每次折半划分。<br>（2）“合并”——将划分后的序列段两两合并后排序。</p>
<p><strong>算法步骤</strong></p>
<p>(1)申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</p>
<p>(2)设定两个指针，最初位置分别为两个已经排序序列的起始位置；</p>
<p>(3)比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</p>
<p>(4)重复步骤 3 直到某一指针达到序列尾；</p>
<p>(5)将另一序列剩下的所有元素直接复制到合并序列尾。</p>
<p><strong>话不多说，上代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring &gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//归并过程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> help[r-l+<span class="number">1</span>];<span class="comment">//辅助数组</span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> lIndex = l;</span><br><span class="line">	<span class="keyword">int</span> rIndex = mid+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(lIndex &lt;= mid &amp;&amp; rIndex &lt;= r)&#123;</span><br><span class="line">		help[i++] = arr[lIndex] &lt; arr[rIndex] ? arr[lIndex++]:arr[rIndex++];</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//左边和右边肯定有一边到头了，不可能同时，因为每次只移动一边</span></span><br><span class="line">	<span class="keyword">while</span>(lIndex &lt;= mid)&#123;</span><br><span class="line">		help[i++] = arr[lIndex++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(rIndex &lt;= r)&#123;</span><br><span class="line">		help[i++] = arr[rIndex++];</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//将排好序的辅助数组赋值给原始数组，不需要返回值</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; r-l+<span class="number">1</span>; i++)&#123;</span><br><span class="line">		arr[l+i] = help[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">msort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//左半部分归并排序</span></span><br><span class="line">	msort(arr, l, mid);</span><br><span class="line">    <span class="comment">//右半部分归并排序</span></span><br><span class="line">	msort(arr, mid+<span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">//左右部分归并</span></span><br><span class="line">	merge(arr, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序整个数组</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">msort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果数组为空或只有一个元素，不需要排序</span></span><br><span class="line">	<span class="keyword">if</span>(arr == <span class="literal">NULL</span> || n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	msort(arr,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arry[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;arry[i];</span><br><span class="line">    msort(arry, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;arry[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>c++</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>排序之快速排序</title>
    <url>/2019/11/24/%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="快排及快速排序，是排序算法中比较快速常用的一种排序方式"><a href="#快排及快速排序，是排序算法中比较快速常用的一种排序方式" class="headerlink" title="快排及快速排序，是排序算法中比较快速常用的一种排序方式"></a>快排及快速排序，是排序算法中比较快速常用的一种排序方式</h3><a id="more"></a>

<h2 id="一-基本原理"><a href="#一-基本原理" class="headerlink" title="一 基本原理"></a>一 基本原理</h2><h5 id="快速排序的根本可以说就是通过分治法来实现，简单举一个例子来理解一下快速排序的过程。"><a href="#快速排序的根本可以说就是通过分治法来实现，简单举一个例子来理解一下快速排序的过程。" class="headerlink" title="快速排序的根本可以说就是通过分治法来实现，简单举一个例子来理解一下快速排序的过程。"></a>快速排序的根本可以说就是通过分治法来实现，简单举一个例子来理解一下快速排序的过程。</h5><p> 我们现在对（56，28，45，93，10，32，44，95，60，58）进行排序。首先我们定义三个量，i，j，flag。i是数组第一个值的下表即i=0。j是数组最后一个值的下表即j=9，flag就是数组的第一个值即flag=56，现在我们要做的就是讲这个数组中所有比flag小的数放到他的前面，把所有比flag大的数放到他的后面。</p>
<ul>
<li><p>第一步从j开始向左（前）找，找到第一个比flag小的数，是下标为6的数44，我们就将44与flag56进行交换从而使数组变成（44，28，45，93，10，32，56，95，60，58），此时的j=6</p>
</li>
<li><p>第二步从i开始向右（后）找，找到第一个比flag大的数，是下标为3的数93，我们就将93与flag56进行交换从而使数组变成（44，28，45，56，10，32，93，95，60，58），此时的i=3</p>
</li>
<li><p>第三步继续从j（此时j=6）开始向左找，找到比flag小的数，是下标为5的数32，我们将32与flag进行交换，得到数组（44，28，45，32，10，56，93，95，60，58），此时j=5</p>
</li>
<li><p>第四步从i（此时i=3）开始向右找，找到比flag大的数，直到i=j,我们发现在j之前已经找不到比flag更大的数，此时快速排序的第一轮就已经结束，这个时候在flag之前的数都是比他小的，在他之后都是比他大的，我们再将flag前后两片区域重新定义成新的无序的数组，分别对他们重复刚才的过程，直到分解到每个重新划分的区域内只有一个值，排序就算完成了。我们直接将过程贴在下面</p>
<pre><code>（44，28，45，32，10）（56）（93，95，60，58）

（10，28，45，32，44）（56）（58，95，60，93）

（10，28，44，32，45）（56）（58，93，60，95）

（10，28，32，44，45）（56）（58，60，93，95）

（10，28，32）（44）（45）（56）（58）（60）（93）（95）

（10）（28）（32）（44）（45）（56）（58）（60）（93）（95）</code></pre></li>
</ul>
<p>排序结束</p>
<h2 id="二-稳定性问题"><a href="#二-稳定性问题" class="headerlink" title="二 稳定性问题"></a>二 稳定性问题</h2><p>&emsp;&emsp;首先大家应该都知道快速排序是一个不稳定排序算法，那么到底什么才是排序的稳定性呢，我认为通俗的讲有两个相同的数A和B，在排序之前A在B的前面，而经过排序之后，B跑到了A的前面，对于这种情况的发生，我们管他叫做排序的不稳定性，而快速排序在对存在相同数进行排序时就有可能发生这种情况。</p>
<p>&emsp;&emsp;例如（5，3A，6，3B）对这个进行排序，排序之前相同的数3A与3B，A在B的前面，经过排序之后会变成（3B，3A，5，6），所以说快速排序是一个不稳定的排序</p>
<p>三 时间复杂度</p>
<p>== 简单的总结一下快速排序的时间复杂度问题 ==</p>
<ul>
<li><p>最优情况:每一次的flag刚好都可以平分整个数组，此时的时间复杂度为O(nlogn)</p>
</li>
<li><p>最坏情况:每一次的flag刚好都是最大或者最小的数，此时的时间复杂度为O(n2)</p>
</li>
<li><p>平均情况:经过推到平均情况为O(nlogn)</p>
</li>
</ul>
<h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*qsort 快速排序</span></span><br><span class="line"><span class="comment">*@auther wyt</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">200</span>];</span><br><span class="line"><span class="comment">//定义快排函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, mid, t;</span><br><span class="line">	i = l;</span><br><span class="line">	j = r;</span><br><span class="line">	mid = a[(l + r) / <span class="number">2</span>];</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (a[i] &lt; mid) i++;		<span class="comment">//寻找左边小于mid的数</span></span><br><span class="line">		<span class="keyword">while</span> (a[j] &gt; mid) j--;     <span class="comment">//寻找右边小于mid的数</span></span><br><span class="line">		<span class="keyword">if</span> (i &lt;= j) &#123;</span><br><span class="line">			t = a[i];		        <span class="comment">//进行数值交换</span></span><br><span class="line">			a[i] = a[j];</span><br><span class="line">			a[j] = t;</span><br><span class="line">			i++;			        <span class="comment">//继续寻找</span></span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (i &lt;= j);</span><br><span class="line">	<span class="keyword">if</span> (j &gt; l) qsort(l, j);			<span class="comment">//继续快排左右子序列</span></span><br><span class="line">	<span class="keyword">if</span> (i &lt; r) qsort(i, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	qsort(<span class="number">1</span>, n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><del>~ PS ~</del></p>
<ul>
<li><p>C++中有自带的快排库(<algorithm>)，用法：sort(*array+left , *array+right)</p>
</li>
<li><p>C中的库是在(&lt;stdlib.h&gt;)中<br>用法：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">qsort(a, <span class="number">1000</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), cmp);</span><br><span class="line"><span class="comment">//其中cmp函数应写为：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">int</span>*)a - *(<span class="keyword">int</span>*)b; <span class="comment">//由小到大排序</span></span><br><span class="line">    <span class="comment">//return *(int *)b - *(int *)a; 由大到小排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>c++</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>排序之选择排序</title>
    <url>/2019/11/20/%E6%8E%92%E5%BA%8F%E4%B9%8B%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<p>之前谈过冒泡排序，今天谈谈选择排序。选择排序，从头至尾扫描序列，找出最小的一个元素，和第一个元素交换，接着从剩下的元素中继续这种选择和交换方式，最终得到一个有序序列。</p>
<a id="more"></a>
<h5 id="文字说明"><a href="#文字说明" class="headerlink" title="文字说明"></a>文字说明</h5><ul>
<li>第1趟比较：拿第1个元素依次和它后面的每个元素进行比较，如果第1个元素大于后面某个元素，交换它们，经过第1趟比较，数组中最小的元素被选出，它被排在第一位</li>
<li>第2趟比较：拿第2个元素依次和它后面的每个元素进行比较，如果第2个元素大于后面某个元素，交换它们，经过第2趟比较，数组中第2小的元素被选出，它被排在第二位<br>……</li>
<li>第n-1趟比较：第n-1个元素和第n个元素作比较，如果第n-1个元素大于第n个元素，交换它们</li>
</ul>
<h5 id="图像演示"><a href="#图像演示" class="headerlink" title="图像演示"></a>图像演示</h5><p><img src="https://img-blog.csdn.net/20180120151515134?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2MxMjU4MDAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="alt 选择排序"></p>
<h5 id="核心代码演示"><a href="#核心代码演示" class="headerlink" title="核心代码演示"></a>核心代码演示</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">           <span class="keyword">if</span>(nums[i] &gt; nums[j]) &#123;</span><br><span class="line">               swap(nums[i], nums[j]); 交换nums[i]和nums[j]的值</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间复杂度：O(n²)</li>
<li>空间复杂度：O(1)，只需要一个附加程序单元用于交换</li>
<li>稳定性：选择排序是不稳定的排序算法，因为无法保证值相等的元素的相对位置不变，例如 [3, 4, 3, 1, 5]这个数组，第一次交换，第一个3和1交换位置，此时原来两个3的相对位置发生了变化。</li>
</ul>
<h5 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h5><p>上面的算法的缺点：在每趟比较过程中，一旦发现某个元素比第1位的元素小，就交换它们，但这是没必要的，徒增了交换的次数。<br>优化：选择排序的核心是，在每趟比较中，找到本趟中最小的元素放在本趟比较的第1个位置，所以选择排序的每趟比较只需要交换一次即可，只要找到本趟比较中最小的元素和本趟比较中第1位置的元素交换即可。</p>
]]></content>
      <tags>
        <tag>c++</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>人生路不长，别再等以后(转载)</title>
    <url>/2019/11/12/%E4%BA%BA%E7%94%9F%E8%B7%AF%E4%B8%8D%E9%95%BF%EF%BC%8C%E5%88%AB%E5%86%8D%E7%AD%89%E4%BB%A5%E5%90%8E-%E8%BD%AC%E8%BD%BD/</url>
    <content><![CDATA[<center><font face="隶书" size=4>人生路不长，别再等以后</font></center>

<a id="more"></a>

<center></center****> 


<p>一辈子很短，短得来不及细算<br>童年，不知不觉没了<br>青春，不知不觉没了<br>而那些无忧无虑的快乐<br>好像也消失不见了<br>一辈子三万天而已<br>没有你想得那么长<br>有什么心愿，快点实现<br>有什么目标，快点奋战<br>别等来等去<br>等来了年龄增长<br>等来了热情褪去<br>人生不是花，败了再开<br>身体不是叶，落了再生<br>我们每个人<br>都只有一次人生，只有一个身体<br>生病不能等，健康没了，人就完了<br>人生不能等，时间过了，人就终了<br>一辈子不长，别再等以后<br>想吃的东西，去吃<br>想做的事情，趁早<br>想要的感情，去追<br>想去的地方，快去<br>别一等再等<br>等牙没有了，想吃就难了<br>等人离开了，想爱就晚了<br>一辈子很短，这一生短暂<br>时间不等人，岁月不等你<br>趁我们都还活着<br>对父母，孝顺点，对爱人，珍惜点<br>对朋友，真心点，对自己，好一点</p>
<p>```</p>
<h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title>学计算机的都是一群疯子(转载)</title>
    <url>/2019/11/11/%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E9%83%BD%E6%98%AF%E4%B8%80%E7%BE%A4%E7%96%AF%E5%AD%90-%E8%BD%AC%E8%BD%BD/</url>
    <content><![CDATA[<h3 id="一名计算机专业的吐槽，，，无奈╮-╯▽╰-╭"><a href="#一名计算机专业的吐槽，，，无奈╮-╯▽╰-╭" class="headerlink" title="一名计算机专业的吐槽，，，无奈╮(╯▽╰)╭"></a>一名计算机专业的吐槽，，，无奈╮(╯▽╰)╭</h3><a id="more"></a>
<p><del>学计算机的你们伤不起啊！！！！！！！</del><br>你们学得都是人说的语言啊！！！！！！<br>好歹有点腔调肢体环境神马的做参考！！！！！<br>哥学得是计算机语言啊！！！！！！    </p>
<p>计算机不会跟你点头yes摇头no啊！！！！！<br>它就会报一堆不知所云的错误啊！！！！有木有！！！！   </p>
<p>有时候啥都不报，直接崩溃啊！！！有木有！！！<br>法语德语数字难念！！！！！<br>你随便找本算法书啊！！！！！厚的跟《康熙字典》一啊！！！！有木有！！！！！<br>各种堆！！！栈！！！树！！！！图！！！！<br>说到树就泪目啊！！！！  </p>
<p>光树就分生成树！！最小生成树！！有向树！！非平凡有向<br>树！！二叉树！！平凡二叉树！！平衡二叉树！！完全二叉树！！完全正则二叉树！！哈夫曼树！！晕了没？  </p>
<p>还要遍历！！！前序中序后序！！！<br>汇编语言！！！看着就是乱码啊！！！光寄存器就有N个啊！！！就差没写二进制来编程了啊！！！！！写个最简单的两数相加就要死人啊！！！！<br>C++啊！！！！一个指针就能搞死你！！！！内存溢出那是普遍的！！！！链表啊！！！<br>还双向链表啊！！！彻底的坑死哥啊！！！<br>java啊！！！各种框架就是搞出来坑哥的啊！！！！！<br>一个spring能从今年spring学到明年spring！！！！有木有！！！！<br>好不容易学会了！！！！！！又给淘汰了！！！新框架又出来了！！！！有木有！！！！！！<br>操作系统！！！Linux服务器！！！要记各种命令啊！！！vi编辑器那简直是折翼<br>啊！！！！Linux内核啊！！！  </p>
<p>研究出来孩子都多大了！！！！<br>数据库！！！！</p>
<p>又学一门SQL语言！！！！MySql跟orcle的SQL还不一样！！！！group by，order by！！！！左连接右连接交叉连接！！！笛卡尔集！！！！<br>你们写错个把单词不影响理解！！！！！计算机你错个标点它都不搭理你！！！！  </p>
<p>体会过系统不断崩溃就是找不到原因的闷骚心情么！！！！！一群人熬夜一个星期！！！<br>最后发现是一行注释多敲了个回车键！！！！<br>bug总是越改越多！！！还有玩着小游戏的测试员拿着小鞭子敲打你！！！！！好不容易做出来了！！！！ </p>
<p>客户一句话：“改”！！！！ </p>
<p>又是加班熬夜暗无天日啊！！！！！当年怎么想起来学计机！！！</p>
<p>学计算机你们伤不起啊！！ ！！</p>
<p>天杀的专业啊！！！别人知道你是个学个计算机的！！！！平时拍个照啊修个图啊！！！<br>装个电脑啊！！！！装个系统啊！！！！修个打印机都TM找我！！！！！哥只是个计算机专业的学的还是网络工程。。。。。为嘛跟计算机沾边的老子都要会啊！！！！更<br>牛的excel表格出个问题都找我！！！！哥哥只是个学计算机的倒霉蛋！！！！不是神仙啊！！！！！！！</p>
<p>跟人家解释，你是做软件的，不是修电脑的，你也不知道这个电脑值多少钱，人家就会以为你明明知道不肯告诉他那种鄙夷。。。。。。。。。靠！！！！<br>我现在都练出来了！！！被别人的白眼逼出来了。。。装电脑！！！装系统！！！修电脑！！！修打印机！！！和现在电脑 相机以及电脑周边产品的物价！！！！！！！我都<br>快成全能了！！！！！！！！！！！悲催了！！！！！！！！！我连硒鼓加粉都会了！！！！！我还有神马不会的！！！！！！</p>
<p>原文地址：<a href="http://blog.csdn.net/niushuai666/article/details/6763692" target="_blank" rel="noopener">学计算机的都是一群疯子</a></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title>flybird</title>
    <url>/2019/11/11/flybird/</url>
    <content><![CDATA[<h2 id="一个简单的C-小游戏"><a href="#一个简单的C-小游戏" class="headerlink" title="一个简单的C++小游戏"></a>一个简单的C++小游戏</h2> <a id="more"></a>

<hr>
<h3 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Lines = <span class="number">35</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Columns = <span class="number">120</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LeftLineColumn = <span class="number">20</span>;</span><br><span class="line">HANDLE hOut;</span><br><span class="line">DWORD dword;</span><br><span class="line"><span class="keyword">char</span> tmp[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> cur_time, start_time, last_time;</span><br><span class="line"><span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawBird</span><span class="params">(<span class="keyword">double</span> xx, <span class="keyword">double</span> yy)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = (<span class="keyword">int</span>)(xx + <span class="number">0.5</span>);</span><br><span class="line">  <span class="keyword">int</span> y = (<span class="keyword">int</span>)(yy + <span class="number">0.5</span>);</span><br><span class="line">  <span class="keyword">static</span> DWORD dword;</span><br><span class="line">  WriteConsoleOutputCharacter(hOut, <span class="string">"v"</span>, <span class="number">1</span>, (COORD)&#123;x, y - <span class="number">1</span>&#125;, &amp;dword);</span><br><span class="line">  WriteConsoleOutputCharacter(hOut, <span class="string">"&gt;&gt;&gt;"</span>, <span class="number">3</span>, (COORD)&#123;x - <span class="number">1</span>, y&#125;, &amp;dword);</span><br><span class="line">  WriteConsoleOutputCharacter(hOut, <span class="string">"^"</span>, <span class="number">1</span>, (COORD)&#123;x, y + <span class="number">1</span>&#125;, &amp;dword);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearBird</span><span class="params">(<span class="keyword">double</span> xx, <span class="keyword">double</span> yy)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = (<span class="keyword">int</span>)(xx + <span class="number">0.5</span>);</span><br><span class="line">  <span class="keyword">int</span> y = (<span class="keyword">int</span>)(yy + <span class="number">0.5</span>);</span><br><span class="line">  WriteConsoleOutputCharacter(hOut, <span class="string">" "</span>, <span class="number">1</span>, (COORD)&#123;x, y - <span class="number">1</span>&#125;, &amp;dword);</span><br><span class="line">  WriteConsoleOutputCharacter(hOut, <span class="string">"   "</span>, <span class="number">3</span>, (COORD)&#123;x - <span class="number">1</span>, y&#125;, &amp;dword);</span><br><span class="line">  WriteConsoleOutputCharacter(hOut, <span class="string">" "</span>, <span class="number">1</span>, (COORD)&#123;x, y + <span class="number">1</span>&#125;, &amp;dword);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Write at Middle/Left */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">WriteMiddle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> l = <span class="built_in">strlen</span>(str);</span><br><span class="line">  WriteConsoleOutputCharacter(hOut, str, l, (COORD)&#123;(Columns - l) / <span class="number">2</span>, y&#125;, &amp;dword);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">WriteLeft</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> l = <span class="built_in">strlen</span>(str);</span><br><span class="line">  WriteConsoleOutputCharacter(hOut, str, l, (COORD)&#123;<span class="number">1</span>, y&#125;, &amp;dword);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitLeftSide</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lines; ++i)</span><br><span class="line">    WriteConsoleOutputCharacter(hOut, <span class="string">"|"</span>, <span class="number">2</span>, (COORD)&#123;LeftLineColumn, i&#125;, &amp;dword);</span><br><span class="line">  <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">  ++p; WriteLeft(<span class="string">"Help:"</span>, p);</span><br><span class="line">  ++p; WriteLeft(<span class="string">" Press &lt;Space&gt; to"</span>, p);</span><br><span class="line">  ++p; WriteLeft(<span class="string">"make the bird fly."</span>, p);</span><br><span class="line">  ++p; WriteLeft(<span class="string">" Don't fall to the"</span>, p);</span><br><span class="line">  ++p; WriteLeft(<span class="string">"ground or hit pipes"</span>, p);</span><br><span class="line">  ++p; <span class="comment">// Empty line</span></span><br><span class="line">  ++p; WriteLeft(<span class="string">"Time:"</span>, p);</span><br><span class="line">  ++p; <span class="comment">// Time</span></span><br><span class="line">  ++p; WriteLeft(<span class="string">"Fps:"</span>, p);</span><br><span class="line">  ++p; <span class="comment">// Fps</span></span><br><span class="line">  ++p; <span class="comment">// Empty line</span></span><br><span class="line">  ++p; WriteLeft(<span class="string">"Score:"</span>, p);</span><br><span class="line">  ++p; <span class="comment">// Score</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawLeftSide</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">  ++p; <span class="comment">// WriteLeft("Help:", p);</span></span><br><span class="line">  ++p; <span class="comment">// WriteLeft(" Press &lt;Space&gt; to", p);</span></span><br><span class="line">  ++p; <span class="comment">// WriteLeft("make the bird fly.", p);</span></span><br><span class="line">  ++p; <span class="comment">// WriteLeft(" Don't fall to the", p);</span></span><br><span class="line">  ++p; <span class="comment">// WriteLeft("ground or hit pipes", p);</span></span><br><span class="line">  ++p; <span class="comment">// Empty line</span></span><br><span class="line">  ++p; <span class="comment">// WriteLeft("Time:", p);</span></span><br><span class="line">  <span class="built_in">sprintf</span>(tmp, <span class="string">" %5.2lfs"</span>, (<span class="keyword">double</span>)(cur_time - start_time) / CLOCKS_PER_SEC);</span><br><span class="line">  ++p; WriteLeft(tmp, p);</span><br><span class="line">  ++p; <span class="comment">// WriteLeft("Fps:", p);</span></span><br><span class="line">  <span class="built_in">sprintf</span>(tmp, <span class="string">" %5.2lf"</span>, CLOCKS_PER_SEC / (<span class="keyword">double</span>)(cur_time - last_time));</span><br><span class="line">  ++p; WriteLeft(tmp, p);</span><br><span class="line">  ++p; <span class="comment">// Empty line</span></span><br><span class="line">  ++p; <span class="comment">// WriteLeft("Score:", p);</span></span><br><span class="line">  <span class="built_in">sprintf</span>(tmp, <span class="string">" %3d"</span>, score);</span><br><span class="line">  ++p; WriteLeft(tmp, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pipe</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> H, D; <span class="comment">// A Pipe, [x, x + 1] * ([0, H] and [D, Lines))</span></span><br><span class="line">  <span class="keyword">double</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">RandRange</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="keyword">return</span> rand() % (r - l + <span class="number">1</span>) + l; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Pipe <span class="title">RandomPipe</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> br = RandRange(<span class="number">8</span>, <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">int</span> h = RandRange(<span class="number">3</span>, Lines - br - <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> (Pipe)&#123;h, h + br, (<span class="keyword">double</span>)x&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">CheckPipe</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">double</span> y, <span class="keyword">const</span> Pipe &amp;p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> px = (<span class="keyword">int</span>)(p.x + <span class="number">0.5</span>);</span><br><span class="line">  <span class="keyword">int</span> dx = <span class="built_in">std</span>::<span class="built_in">min</span>(<span class="built_in">std</span>::<span class="built_in">abs</span>(x - px), <span class="built_in">std</span>::<span class="built_in">abs</span>(x - px - <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">if</span> (dx &gt; <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (dx == <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> y &gt; p.H - <span class="number">0.5</span> &amp;&amp; y &lt; p.D + <span class="number">0.5</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (dx == <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> y &gt; p.H + <span class="number">0.5</span> &amp;&amp; y &lt; p.D - <span class="number">0.5</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> y &gt; p.H + <span class="number">1.5</span> &amp;&amp; y &lt; p.D - <span class="number">1.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearPipe</span><span class="params">(<span class="keyword">const</span> Pipe &amp;p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> px = (<span class="keyword">int</span>)(p.x + <span class="number">0.5</span>);</span><br><span class="line">  <span class="keyword">if</span> (px != LeftLineColumn &amp;&amp; px + <span class="number">1</span> &lt; Columns) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.H; ++i)</span><br><span class="line">      WriteConsoleOutputCharacter(hOut, <span class="string">"  "</span>, <span class="number">2</span>, (COORD)&#123;px, i&#125;, &amp;dword);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p.D + <span class="number">1</span>; i &lt; Lines; ++i)</span><br><span class="line">      WriteConsoleOutputCharacter(hOut, <span class="string">"  "</span>, <span class="number">2</span>, (COORD)&#123;px, i&#125;, &amp;dword);</span><br><span class="line">    WriteConsoleOutputCharacter(hOut, <span class="string">"  "</span>, <span class="number">2</span>, (COORD)&#123;px + <span class="number">1</span>, p.H&#125;, &amp;dword);</span><br><span class="line">    WriteConsoleOutputCharacter(hOut, <span class="string">"  "</span>, <span class="number">2</span>, (COORD)&#123;px + <span class="number">1</span>, p.D&#125;, &amp;dword);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> x = px == LeftLineColumn ? px + <span class="number">1</span> : px;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.H; ++i)</span><br><span class="line">      WriteConsoleOutputCharacter(hOut, <span class="string">" "</span>, <span class="number">1</span>, (COORD)&#123;x, i&#125;, &amp;dword);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p.D + <span class="number">1</span>; i &lt; Lines; ++i)</span><br><span class="line">      WriteConsoleOutputCharacter(hOut, <span class="string">" "</span>, <span class="number">1</span>, (COORD)&#123;x, i&#125;, &amp;dword);</span><br><span class="line">    WriteConsoleOutputCharacter(hOut, <span class="string">" "</span>, <span class="number">1</span>, (COORD)&#123;x, p.H&#125;, &amp;dword);</span><br><span class="line">    WriteConsoleOutputCharacter(hOut, <span class="string">" "</span>, <span class="number">1</span>, (COORD)&#123;x, p.D&#125;, &amp;dword);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawPipe</span><span class="params">(<span class="keyword">const</span> Pipe &amp;p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> px = (<span class="keyword">int</span>)(p.x + <span class="number">0.5</span>);</span><br><span class="line">  <span class="keyword">if</span> (px &lt; LeftLineColumn) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (px != LeftLineColumn &amp;&amp; px + <span class="number">1</span> &lt; Columns) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.H; ++i)</span><br><span class="line">      WriteConsoleOutputCharacter(hOut, <span class="string">"||"</span>, <span class="number">2</span>, (COORD)&#123;px, i&#125;, &amp;dword);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p.D + <span class="number">1</span>; i &lt; Lines; ++i)</span><br><span class="line">      WriteConsoleOutputCharacter(hOut, <span class="string">"||"</span>, <span class="number">2</span>, (COORD)&#123;px, i&#125;, &amp;dword);</span><br><span class="line">    WriteConsoleOutputCharacter(hOut, <span class="string">"--"</span>, <span class="number">2</span>, (COORD)&#123;px, p.H&#125;, &amp;dword);</span><br><span class="line">    WriteConsoleOutputCharacter(hOut, <span class="string">"--"</span>, <span class="number">2</span>, (COORD)&#123;px, p.D&#125;, &amp;dword);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> x = px == LeftLineColumn ? px + <span class="number">1</span> : px;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.H; ++i)</span><br><span class="line">      WriteConsoleOutputCharacter(hOut, <span class="string">"|"</span>, <span class="number">1</span>, (COORD)&#123;x, i&#125;, &amp;dword);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p.D + <span class="number">1</span>; i &lt; Lines; ++i)</span><br><span class="line">      WriteConsoleOutputCharacter(hOut, <span class="string">"|"</span>, <span class="number">1</span>, (COORD)&#123;x, i&#125;, &amp;dword);</span><br><span class="line">    WriteConsoleOutputCharacter(hOut, <span class="string">"-"</span>, <span class="number">1</span>, (COORD)&#123;x, p.H&#125;, &amp;dword);</span><br><span class="line">    WriteConsoleOutputCharacter(hOut, <span class="string">"-"</span>, <span class="number">1</span>, (COORD)&#123;x, p.D&#125;, &amp;dword);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">HideCursor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  CONSOLE_CURSOR_INFO cci;</span><br><span class="line">  GetConsoleCursorInfo(hOut,&amp;cci);</span><br><span class="line">  cci.bVisible = FALSE;</span><br><span class="line">  SetConsoleCursorInfo(hOut,&amp;cci);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  srand(time(<span class="literal">NULL</span>));</span><br><span class="line">  <span class="built_in">sprintf</span>(tmp, <span class="string">"mode con lines=%d cols=%d"</span>, Lines, Columns);</span><br><span class="line">  system(tmp);</span><br><span class="line">  hOut = GetStdHandle(STD_OUTPUT_HANDLE);</span><br><span class="line">  HideCursor();</span><br><span class="line">  InitLeftSide();</span><br><span class="line">  WriteMiddle(<span class="string">"Flappy bird (Simple)"</span>, Lines / <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">  WriteMiddle(<span class="string">"--By _wyt"</span>, Lines / <span class="number">2</span>);</span><br><span class="line">  WriteMiddle(<span class="string">"Press any key to start..."</span>, Lines / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">  _getch();</span><br><span class="line">  system(<span class="string">"cls"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pipe pipes[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Init();</span><br><span class="line">  InitLeftSide();</span><br><span class="line">  last_time = start_time = clock();</span><br><span class="line">  score = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> g = <span class="number">35</span>; <span class="comment">// Gravitational acceleration, grid / s^2</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> vx = <span class="number">12.0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> x = <span class="number">27.0</span>;</span><br><span class="line">  <span class="keyword">double</span> y = <span class="number">5.0</span>, vy = <span class="number">0.0</span>;</span><br><span class="line">  <span class="keyword">int</span> pipe_n = <span class="number">0</span>;</span><br><span class="line">  pipes[pipe_n++] = RandomPipe(Columns - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (kbhit()) &#123;</span><br><span class="line">      <span class="keyword">char</span> c = _getch();</span><br><span class="line">      <span class="keyword">if</span> (c == <span class="number">32</span>) vy = <span class="number">-15.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cur_time = clock();</span><br><span class="line">    <span class="keyword">double</span> time_break = (<span class="keyword">double</span>)(cur_time - last_time) / CLOCKS_PER_SEC;</span><br><span class="line">    ClearBird(x, y);</span><br><span class="line">    y = <span class="built_in">std</span>::<span class="built_in">min</span>(vy * time_break + y, <span class="number">33.0</span>);</span><br><span class="line">    vy += g * time_break;</span><br><span class="line">    <span class="keyword">if</span> (y &lt; <span class="number">1</span> - <span class="number">1e-6</span>) &#123; y = <span class="number">1</span>; vy = <span class="number">.0</span>; &#125;</span><br><span class="line">    DrawBird(x, y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pipe_n; ++i) &#123;</span><br><span class="line">      <span class="keyword">double</span> px = pipes[i].x, px2 = pipes[i].x - vx * time_break;</span><br><span class="line">      <span class="keyword">if</span> ((<span class="keyword">int</span>)(px + <span class="number">0.5</span>) != (<span class="keyword">int</span>)(px2 + <span class="number">0.5</span>)) &#123;</span><br><span class="line">        ClearPipe(pipes[i]);</span><br><span class="line">        pipes[i].x = px2;</span><br><span class="line">        DrawPipe(pipes[i]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pipes[i].x = px2;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Columns - pipes[pipe_n - <span class="number">1</span>].x &gt; <span class="number">30</span>)</span><br><span class="line">      DrawPipe(pipes[pipe_n++] = RandomPipe(Columns - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> failed = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pipe_n; ++i) &#123;</span><br><span class="line">      failed = failed || !CheckPipe((<span class="keyword">int</span>)(x + <span class="number">0.5</span>), y, pipes[i]);</span><br><span class="line">      <span class="keyword">if</span> ((<span class="keyword">int</span>)(pipes[i].x + <span class="number">0.5</span>) &gt;= LeftLineColumn)</span><br><span class="line">        pipes[j++] = pipes[i];</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        ++score;</span><br><span class="line">    &#125;</span><br><span class="line">    pipe_n = j;</span><br><span class="line">    DrawLeftSide();</span><br><span class="line">    <span class="keyword">if</span> (y &gt;= <span class="number">33.0</span> - <span class="number">1e-6</span> || failed) &#123;</span><br><span class="line">      DrawBird(x, y);</span><br><span class="line">      WriteMiddle(<span class="string">"-------------------------------"</span>, Lines / <span class="number">2</span> - <span class="number">2</span>);</span><br><span class="line">      WriteMiddle(<span class="string">"|                             |"</span>, Lines / <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">      WriteMiddle(<span class="string">"|                             |"</span>, Lines / <span class="number">2</span>);</span><br><span class="line">      WriteMiddle(<span class="string">"|                             |"</span>, Lines / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">      WriteMiddle(<span class="string">"|                             |"</span>, Lines / <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line">      WriteMiddle(<span class="string">"-------------------------------"</span>, Lines / <span class="number">2</span> + <span class="number">3</span>);</span><br><span class="line">      <span class="built_in">sprintf</span>(tmp, <span class="string">"Your score: %d!"</span>, score);</span><br><span class="line">      WriteMiddle(tmp, Lines / <span class="number">2</span>);</span><br><span class="line">      WriteMiddle(<span class="string">"Press any key to exit..."</span>, Lines / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">      _getch();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    last_time = cur_time;</span><br><span class="line">    Sleep(<span class="number">40</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> _ **** 嘿嘿，慢慢玩 _</p>
]]></content>
      <tags>
        <tag>c++</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>排序入坑之冒泡</title>
    <url>/2019/11/11/%E6%8E%92%E5%BA%8F%E5%85%A5%E5%9D%91%E4%B9%8B%E5%86%92%E6%B3%A1/</url>
    <content><![CDATA[<h3 id="算法入坑第一步，冒泡排序。"><a href="#算法入坑第一步，冒泡排序。" class="headerlink" title="算法入坑第一步，冒泡排序。"></a>算法入坑第一步，冒泡排序。</h3><p>搜索算法是我们学习过程中必不可少的一步，其实理解以后，它也没有那么难…来先看个冒泡吧</p>
<a id="more"></a>
<h5 id="冒泡算法"><a href="#冒泡算法" class="headerlink" title="冒泡算法"></a>冒泡算法</h5><p><strong>如果遇到相等的值不进行交换，那这种排序方式是稳定的排序方式。</strong></p>
<p>原理：比较两个相邻的元素，将值大的元素交换到右边</p>
<p>思路：依次比较相邻的两个数，将比较小的数放在前面，比较大的数放在后面。</p>
<ul>
<li><p>第一次比较：首先比较第一和第二个数，将小数放在前面，将大数放在后面。</p>
</li>
<li><p>比较第2和第3个数，将小数 放在前面，大数放在后面。</p>
<p>  ……</p>
</li>
<li><p>如此继续，知道比较到最后的两个数，将小数放在前面，大数放在后面，重复步骤，直至全部排序完成</p>
</li>
<li><p>在上面一趟比较完成后，最后一个数一定是数组中最大的一个数，所以在比较第二趟的时候，最后一个数是不参加比较的。</p>
</li>
<li><p>在第二趟比较完成后，倒数第二个数也一定是数组中倒数第二大数，所以在第三趟的比较中，最后两个数是不参与比较的。</p>
</li>
<li><p>依次类推，每一趟比较次数减少依次</p>
</li>
</ul>
<p>举例：</p>
<p>　　　　(1)要排序数组:[10,1,35,61,89,36,55]<br>　　　　(2)第一趟排序：</p>
<p>　　　　　　第一次排序：10和1比较，10大于1，交换位置 　　 　  [1,10,35,61,89,36,55]</p>
<p>　　　　　　第二次排序：10和35比较，10小于35，不交换位置　　[1,10,35,61,89,36,55]</p>
<p>　　　　　　第三次排序：35和61比较，35小于61，不交换位置　　[1,10,35,61,89,36,55]</p>
<p>　　　　　　第四次排序：61和89比较，61小于89，不交换位置　　[1,10,35,61,89,36,55]</p>
<p>　　　　　　第五次排序：10和1比较，10大于1，交换位置 　　 　  [1,10,35,61,89,36,55]</p>
<p>　　　　　　第六次排序：89和55比较，89大于55，交换位置　　　[1,10,35,61,36,55,89]</p>
<p>　　　　　　第一趟总共进行了六次比较，排序结果：[1,10,35,61,36,55,89]</p>
<p>　　　　(3)第二趟排序：</p>
<p>　　　　　　第一次排序：1和10比较，1小于10，不交换位置　　[1,10,35,61,36,55,89]</p>
<p>　　　　　　第二次排序：10和35比较，10小于35，不交换位置    [1,10,35,61,36,55,89]</p>
<p>　　　　　　第三次排序：35和61比较，35小于61，不交换位置     [1,10,35,61,36,55,89]</p>
<p>　　　　　　第四次排序：61和36比较，61大于36，交换位置　　　[1,10,35,36,61,55,89]</p>
<p>　　　　　　第五次排序：61和55比较，61大于55，交换位置　　　[1,10,35,36,55,61,89]</p>
<p>　　　　　　第二趟总共进行了5次比较，排序结果：[1,10,35,36,55,61,89]</p>
<p>　　　　(4)第三趟排序：</p>
<p>　　　　　　第一次排序：1和10比较，1小于10，不交换位置　　[1,10,35,36,55,61,89]</p>
<p>　　　　　　第二次排序：10和35比较，10小于35，不交换位置    [1,10,35,36,55,61,89]</p>
<p>　　　　　　第三次排序：35和36比较，35小于36，不交换位置     [1,10,35,36,55,61,89]</p>
<p>　　　　　　第四次排序：36和61比较，36小于61，不交换位置　　　1,10,35,36,55,61,89</p>
<p>　　　　　　第三趟总共进行了4次比较，排序结果：1,10,35,36,55,61,89</p>
<p>　　　　　　到目前位置已经为有序的情形了。　　　　</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span>    <span class="comment">//下面是函数sort的程序 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,temp;    <span class="comment">//定义三个整型变量 </span></span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;n<span class="number">-1</span>;j++)    <span class="comment">//用一个嵌套循环来遍历一遍每一对相邻元素 （所以冒泡函数慢嘛，时间复杂度高）  </span></span><br><span class="line">    &#123;                           </span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>-j;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;a[i+<span class="number">1</span>])  <span class="comment">//从大到小排就把左边的"&gt;"改为"&lt;"</span></span><br><span class="line">            &#123;</span><br><span class="line">                temp=a[i];      <span class="comment">//a[i]与a[i+1](即a[i]后面那个) 交换</span></span><br><span class="line">                a[i]=a[i+<span class="number">1</span>];    <span class="comment">//基本的交换原理"c=a;a=b;b=c" </span></span><br><span class="line">                a[i+<span class="number">1</span>]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.算法分析：</p>
<p>　　　　(1)由此可见：N个数字要排序完成，总共进行N-1趟排序，每i趟的排序次数为(N-i)次，所以可以用双重循环语句，外层控制循环多少趟，内层控制每一趟的循环次数</p>
<p>　　　　(2)冒泡排序的优点：每进行一趟排序，就会少比较一次，因为每进行一趟排序都会找出一个较大值。如上例：第一趟比较之后，排在最后的一个数一定是最大的一个数，第二趟排序的时候，只需要比较除了最后一个数以外的其他的数，同样也能找出一个最大的数排在参与第二趟比较的数后面，第三趟比较的时候，只需要比较除了最后两个数以外的其他的数，以此类推……也就是说，没进行一趟比较，每一趟少比较一次，一定程度上减少了算法的量。<br>　　　　<br>　　　　(3)时间复杂度</p>
<p>　　　　1.如果我们的数据正序，只需要走一趟即可完成排序。所需的比较次数C和记录移动次数M均达到最小值，即：Cmin=n-1;Mmin=0;所以，冒泡排序最好的时间复杂度为O(n)。</p>
<p>　　　　2.如果很不幸我们的数据是反序的，则需要进行n-1趟排序。每趟排序要进行n-i次比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：</p>
<p>　　　　　　综上所述：冒泡排序总的平均时间复杂度为：O(n2) ,时间复杂度和数据状况无关。</p>
]]></content>
      <tags>
        <tag>c++</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>素数，他，他又来了</title>
    <url>/2019/11/10/%E7%B4%A0%E6%95%B0%EF%BC%8C%E4%BB%96%EF%BC%8C%E4%BB%96%E5%8F%88%E6%9D%A5%E4%BA%86/</url>
    <content><![CDATA[<p>是他，是他，就是他，我们的…咳咳，走错片场了。一大堆素数朝你涌来，感谢埃拉托斯特尼，感谢欧拉(其实一点也不╮(╯▽╰)╭)</p>
<a id="more"></a>
<p>上次实际上是对单个数进行判断是否为素数，但是如果我们有一大堆素数，还用上次的方法的话，那么，，，一定很有趣。好吧我就直接说了，一大堆数进行判断，一个一个的进行循环无疑是很浪费时间的，那么我们就可以构建一个素数表，只需要判断一堆数是否在素数表里就可以了。</p>
<p>有请第一位嘉宾——埃拉托斯特尼筛法(简称埃氏筛法)</p>
<h3 id="埃氏筛法"><a href="#埃氏筛法" class="headerlink" title="埃氏筛法"></a>埃氏筛法</h3><p>首先，我们将2到n范围内的所有整数写下来。其中最小的数字2是素数。将表中所有2的倍数都划去。表中剩余的最小数字是3，它不能被更小的数整除，所以是素数。再将表中所有3的倍数都划去。依此类推，如果表中剩余的最小数字是m时，m就是素数。然后将表中所有m的倍数都化去。像这样反复操作，就能依次枚举n以内的素数。</p>
<p>话不多说，上代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> u[MAXN];			<span class="comment">//定义一个筛子</span></span><br><span class="line"><span class="keyword">int</span> su[MAXN], num = <span class="number">0</span>;	<span class="comment">//定义一个素数表及表的长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;		<span class="comment">//埃氏筛法函数</span></span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; MAXN; i++)		<span class="comment">//进行数组初始化</span></span><br><span class="line">		u[i] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; MAXN; i++)			<span class="comment">//从2到MAXN进行循环</span></span><br><span class="line">		<span class="keyword">if</span> (u[i]) &#123;						<span class="comment">//一旦u[i]是素数，那么筛去它小于MAXN的所有倍数</span></span><br><span class="line">			<span class="keyword">for</span> (j = <span class="number">2</span>; i * j &lt; MAXN; j++)</span><br><span class="line">				u[i * j] = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; MAXN; i++)			<span class="comment">//将筛出的素数填入素数表中</span></span><br><span class="line">		<span class="keyword">if</span> (u[i])</span><br><span class="line">			su[++num] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面埃氏筛法中，大家有没有发现一个问题</p>
<p>最小的素数是2，那么2的整数倍都不是素数，删去4,6,8…余下的数里，最小的素数是3，删去6,9,12…最终未被删去的数就是素数。但，这样在效率上有一个问题：一个数会被删去多次。例如42会被2 3 7都删去一遍，其时间复杂度为O(NlogNlogN)，，，所以，，，</p>
<h3 id="有请欧拉上场"><a href="#有请欧拉上场" class="headerlink" title="有请欧拉上场"></a>有请欧拉上场</h3><p>对每个合数a×b，它会被每个质因数都筛去一遍，但我们只要用最小的质因数筛去就好了为此，我们需要记录下所产生的全部素数，上代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> u[MAXN];        <span class="comment">//筛子</span></span><br><span class="line"><span class="keyword">int</span> su[MAXN],num=<span class="number">0</span>;       <span class="comment">//创建素数表及表长</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eulerSieve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(u,<span class="literal">true</span>,<span class="keyword">sizeof</span>(u));       <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;=MAXN; i++)&#123;         <span class="comment">//顺序分析区间表中的每个数</span></span><br><span class="line">        <span class="keyword">if</span>(u[i])</span><br><span class="line">            su[++num]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=num; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i*su[j]&gt;MAXN)        <span class="comment">//如果i与当前素数的乘积大于MAXN，则跳过</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            u[i*su[j]]=<span class="literal">false</span>;       <span class="comment">//素数的倍数必为非素数，筛去</span></span><br><span class="line">            <span class="keyword">if</span>(i%su[j]==<span class="number">0</span>)          <span class="comment">//如果su[j]是i的最小素数，则进行下一个i的判断</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心就是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(i%su[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>如果i能整除su[k]，说明su[k]是i的因子，所以su[k]也是i的任意倍数的因子。所以su[k]也是i×su[x] (x&gt;k)的因子。考虑到primelist单增，对i×su[x]，su[k]就是它的比su[x]更小的因子。故不用考虑其后的质因子了（i×su[x]会被su[k]作为因子在i更大时被筛掉）</p>
]]></content>
      <tags>
        <tag>c++</tag>
        <tag>素数</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的模计算</title>
    <url>/2019/11/10/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%A8%A1%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<p>常用的模计算，没有公式证明，只统计了相关结论</p>
<a id="more"></a>
<h1 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h1><hr>
<h5 id="对于正整数和整数-，定义如下运算："><a href="#对于正整数和整数-，定义如下运算：" class="headerlink" title="对于正整数和整数 , ，定义如下运算："></a>对于正整数和整数 , ，定义如下运算：</h5><p>取模运算：a % p（或a mod p），表示a除以p的余数。</p>
<p>模p加法：(a + b) % p ，其结果是a+b算术和除以p的余数，也就是说，(a+b) = kp +r，则(a + b) % p = r。</p>
<p>模p减法：(a-b) % p ，其结果是a-b算术差除以p的余数。</p>
<p>模p乘法：(a * b) % p，其结果是 a * b算术乘法除以p的余数。</p>
<ol>
<li><p>同余式：正整数a，b对p取模，它们的余数相同，记做 a ≡ b % p或者a ≡ b (mod p)。</p>
</li>
<li><p>n % p得到结果的正负由被除数n决定,与p无关。例如：7%4 = 3， -7%4 = -3， 7%-4 = 3， -7%-4 = -3。 </p>
</li>
</ol>
<p>（1）若p|(a-b)，则a≡b (% p)。例如 11 ≡ 4 (% 7)， 18 ≡ 4(% 7)</p>
<p>（2）(a % p)=(b % p)意味a≡b (% p)</p>
<p>（3）对称性：a≡b (% p)等价于b≡a (% p)</p>
<p>（4）传递性：若a≡b (% p)且b≡c (% p) ，则a≡c (% p) 模运算与基本四则运算有些相似，但是除法例外。其规则如下：</p>
<p>(a + b) % p = (a % p + b % p) % p （1）</p>
<p>(a - b) % p = (a % p - b % p) % p （2）</p>
<p>(a * b) % p = (a % p * b % p) % p （3）</p>
<p>(a^b) % p = ((a % p)^b) % p （4）</p>
<p>结合律：<br>((a+b) % p + c) % p = (a + (b+c) % p) % p （5）</p>
<p>((a<em>b) % p * c)% p = (a * b</em>c) % p （6）// (a%p<em>b)%p=(a</em>b)%p</p>
<p>交换律：<br>(a + b) % p = (b+a) % p （7）</p>
<p>(a * b) % p = (b * a) % p （8）</p>
<p>分配律：<br>((a +b)% p * c) % p = ((a * c) % p + (b * c) % p) % p （9）</p>
<h3 id="重要定理："><a href="#重要定理：" class="headerlink" title="重要定理："></a>重要定理：</h3><p>若a≡b (% p)，则对于任意的c，都有(a + c) ≡ (b + c) (%p)；（10）</p>
<p>若a≡b (% p)，则对于任意的c，都有(a * c) ≡ (b * c) (%p)；（11）</p>
<p>若a≡b (% p)，c≡d (% p)，则 (a + c) ≡ (b + d) (%p)，(a - c) ≡ (b - d) (%p)，<br>(a * c) ≡ (b * d) (%p)，(a / c) ≡ (b / d) (%p)； （12）</p>
<p><del>23333</del></p>
]]></content>
      <tags>
        <tag>随笔</tag>
        <tag>模</tag>
      </tags>
  </entry>
  <entry>
    <title>动规的初级理解</title>
    <url>/2019/11/10/%E5%8A%A8%E8%A7%84%E7%9A%84%E5%88%9D%E7%BA%A7%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>动态规划是学习算法过程中的一道绊脚石，那么今天就让我们，走进动态规划的世界里，不要恐惧它，其实挺有意思的</p>
<a id="more"></a>
<h4 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h4><p>动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。</p>
<h4 id="二、基本思想与策略"><a href="#二、基本思想与策略" class="headerlink" title="二、基本思想与策略"></a>二、基本思想与策略</h4><p>基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。</p>
<p>由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。</p>
<p>与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。</p>
<h4 id="三、适用的情况"><a href="#三、适用的情况" class="headerlink" title="三、适用的情况"></a>三、适用的情况</h4><p>能采用动态规划求解的问题的一般要具有3个性质：</p>
<p>(1) 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。</p>
<p>(2) 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</p>
<p>（3）有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）</p>
<hr>
<hr>
<h4 id="四、求解的基本步骤"><a href="#四、求解的基本步骤" class="headerlink" title="四、求解的基本步骤"></a>四、求解的基本步骤</h4><p>动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。</p>
<p>初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态</p>
<p>图1 动态规划决策过程示意图</p>
<p>(1)划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。</p>
<p>(2)确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。</p>
<p>(3)确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。</p>
<p>(4)寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。</p>
<p>一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。</p>
<p>实际应用中可以按以下几个简化的步骤进行设计：</p>
<p>（1）分析最优解的性质，并刻画其结构特征。</p>
<p>（2）递归的定义最优解。</p>
<p>（3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值</p>
<p>（4）根据计算最优值时得到的信息，构造问题的最优解</p>
<h4 id="五、算法实现的说明"><a href="#五、算法实现的说明" class="headerlink" title="五、算法实现的说明"></a>五、算法实现的说明</h4><p>动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。</p>
<p>使用动态规划求解问题，最重要的就是确定动态规划三要素：</p>
<p>（1）问题的阶段 （2）每个阶段的状态</p>
<p>（3）从前一个阶段转化到后一个阶段之间的递推关系。</p>
<p>递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。</p>
<p>确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">f(n,m)=<span class="built_in">max</span>&#123;f(n<span class="number">-1</span>,m), f(n<span class="number">-1</span>,m-w[n])+P(n,m)&#125;</span><br></pre></td></tr></table></figure>
<h3 id="六、动态规划算法基本框架"><a href="#六、动态规划算法基本框架" class="headerlink" title="六、动态规划算法基本框架"></a>六、动态规划算法基本框架</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=m; j=j+<span class="number">1</span>) <span class="comment">// 第一个阶段</span></span><br><span class="line">   xn[j] = 初始值;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span>(i=n<span class="number">-1</span>; i&gt;=<span class="number">1</span>; i=i<span class="number">-1</span>)<span class="comment">// 其他n-1个阶段</span></span><br><span class="line">   <span class="keyword">for</span>(j=<span class="number">1</span>; j&gt;=f(i); j=j+<span class="number">1</span>)<span class="comment">//f(i)与i有关的表达式</span></span><br><span class="line">     xi[j]=j=<span class="built_in">max</span>（或<span class="built_in">min</span>）&#123;g(xi<span class="number">-1</span>[j1:j2]), ......, g(xi<span class="number">-1</span>[jk:jk+<span class="number">1</span>])&#125;;</span><br><span class="line"> </span><br><span class="line">t = g(x1[j1:j2]); <span class="comment">// 由子问题的最优解求解整个问题的最优解的方案</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(x1[j1]);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;=n<span class="number">-1</span>; i=i+<span class="number">1</span>）</span><br><span class="line">&#123;  </span><br><span class="line">     t = t-xi<span class="number">-1</span>[ji];</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">for</span>(j=<span class="number">1</span>; j&gt;=f(i); j=j+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>(t=xi[ji])</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>c++</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>悲伤发廊</title>
    <url>/2019/11/10/%E6%82%B2%E4%BC%A4%E5%8F%91%E5%BB%8A/</url>
    <content><![CDATA[<h3 id="超级悲伤的理发之行"><a href="#超级悲伤的理发之行" class="headerlink" title="超级悲伤的理发之行"></a>超级悲伤的理发之行</h3><p>发廊深似水，小嘴跑火车，醒着进，晕着出  /欲哭无泪</p>
<a id="more"></a>
<p>超级难受的理发经历，我真的只是想单纯的修一下边，结果操作就开始了。</p>
<p>“我看你头发有点硬啊”</p>
<p>“。。。。。。”</p>
<p>“来做做发根吧，不贵就几十块钱”</p>
<p>“。。。。。。”</p>
<p>“来蓬松蓬松，那样好看，我给你做下哈”</p>
<p>“。。。。。。”</p>
<p>“你想办那个档次的卡”</p>
<p>“。。。。。。”</p>
<p>然后，，，就没有然后了</p>
<p>最后，，，一个简单的发型480？？？？</p>
<p>what？？？  不说了，一把辛酸泪</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title>初级素数判断</title>
    <url>/2019/11/10/%E5%88%9D%E7%BA%A7%E7%B4%A0%E6%95%B0%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<p>这篇只是让大家初步了解如何判断素数，是最基础的内容，之后会讲一些欧拉，埃氏等素数筛的方法</p>
<a id="more"></a>
<h6 id="第一次的想法"><a href="#第一次的想法" class="headerlink" title="第一次的想法:"></a>第一次的想法:</h6><p>==让它爆搜一遍不就好了== <del>爆搜大法好爆搜大法好</del></p>
<blockquote>
<p>具体实现就是让数n从2开始模,一直模到n-1,如果都不能被整除,那就是素数<strong>紧扣定义</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否是素数1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"please inpout a number."</span>;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; m; ++i)</span><br><span class="line">        <span class="keyword">if</span> (m%i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="string">" isn't a prime\n"</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="string">" is a prime\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这么复杂,那来进行下简单优化:<br>如果一个数有因子的话，那么在它的平方根数以内就应该有，否则就没有因子。例如66的平方根在8与9之间，因为66不是素数，，则它一定有比8还小的因子，我们知道66的因子是2、3、6等<br><strong>那我们就可以这样写了</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="built_in">sqrt</span>(m); ++i)&#123;</span><br><span class="line">    <span class="keyword">if</span> (m%i == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="string">" isn't a prime\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>本次初级素数判断就先到这里</strong><br><strong>有没有感觉到循环挺浪费时间的呢</strong><br><strong>那去想想有什么方法能够进一步降低时间复杂度</strong></p>
]]></content>
      <tags>
        <tag>c++</tag>
        <tag>素数</tag>
      </tags>
  </entry>
  <entry>
    <title>hello</title>
    <url>/2019/11/10/hello/</url>
    <content><![CDATA[<h1 id="重建-GitHub-hexo-博客的第一篇笔记"><a href="#重建-GitHub-hexo-博客的第一篇笔记" class="headerlink" title="重建 GitHub+hexo 博客的第一篇笔记"></a>重建 GitHub+hexo 博客的第一篇笔记</h1><p>虽然GitHub有时候不太稳定，但我依然是很爱她的，今后的blog将不再漂泊，我会陆陆续续将其它地方的blog渐渐挪到这上面来，现在虽然用的还是hexo官网上的主题，emmmm，肯定是要好好学学web技术，未来全部换成自己写的组件</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
